<!DOCTYPE html>
<html class="has-navbar-fixed-top">
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
<title>从输入URL到页面加载的过程的知识梳理 - Asensiki</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.css">








    <meta property="og:type" content="article">
<meta property="og:title" content="从输入URL到页面加载的过程的知识梳理">
<meta property="og:url" content="http://asensiki.github.io/2019/08/20/从输入URL到页面加载的过程的知识梳理/index.html">
<meta property="og:site_name" content="Asensiki">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://i.loli.net/2019/08/20/ZxCuOHSi58mGjhW.png">
<meta property="og:image" content="https://i.loli.net/2019/08/20/COAmnpcw7KSgeHy.png">
<meta property="og:image" content="https://i.loli.net/2019/08/21/Gdq4ZUajK8V6BgR.png">
<meta property="og:image" content="https://i.loli.net/2019/08/22/pf6q9NPkWu1iVc2.png">
<meta property="og:image" content="https://i.loli.net/2019/08/22/jishUSAHTNJbuVL.png">
<meta property="og:image" content="https://i.loli.net/2019/08/22/EAtgpZjDMmovRzf.png">
<meta property="og:image" content="https://i.loli.net/2019/08/22/JfHlq7Tp8uwbVEi.png">
<meta property="og:image" content="https://i.loli.net/2019/08/23/myHQdE3vz1YFfae.png">
<meta property="og:updated_time" content="2019-08-22T16:41:15.743Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="从输入URL到页面加载的过程的知识梳理">
<meta name="twitter:image" content="https://i.loli.net/2019/08/20/ZxCuOHSi58mGjhW.png">





<link rel="icon" href="./source/images/logo.png">


<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Ovo|Source+Code+Pro">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/bulma/0.6.2/css/bulma.min.css">


<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/justifiedGallery/3.6.5/css/justifiedGallery.min.css">


<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/ocean.min.css">

<link rel="stylesheet" href="/css/style.css">

<script defer src="//use.fontawesome.com/releases/v5.0.8/js/all.js"></script>


    
    
    
    
    
    
    
    
    
    

    


</head>
<body>
    
<nav class="navbar is-transparent is-fixed-top navbar-main" role="navigation" aria-label="main navigation">
    <div class="container">
        <div class="navbar-brand">
            <a class="navbar-item navbar-logo" href="/">
                
                <img src="/images/logo.png" alt height="28">
                
            </a>
            <div class="navbar-burger">
                <span></span>
                <span></span>
                <span></span>
            </div>
        </div>
        
        <div class="navbar-menu navbar-start">
            
            <a class="navbar-item " href="/archives">Archives</a>
            
            <a class="navbar-item " href="/categories">categories</a>
            
        </div>
        
        <div class="navbar-menu navbar-end">
            
            <a class="navbar-item search" title="Search" href="javascript:;">
                <i class="fas fa-search"></i>
            </a>
            
            
            <div class="navbar-item is-hoverable has-dropdown is-hidden-mobile is-hidden-tablet-only toc">
                <a class="navbar-item" title="Table of Contents">
                    <i class="fa fa-list"></i>
                </a>
                <div class="navbar-dropdown is-right">
                    
                    
                    
                    
                    <a class="navbar-item" href="#知识梳理">1&nbsp;&nbsp;<b>知识梳理</b></a>
                    
                    
                    <hr class="navbar-divider">
                    
                    
                    <a class="navbar-item" href="#浏览器接受URL到开启网络请求">2&nbsp;&nbsp;<b>浏览器接受URL到开启网络请求</b></a>
                    
                    
                    
                    <a class="navbar-item" href="#浏览器知识">2.1&nbsp;&nbsp;浏览器知识</a>
                    
                    
                    
                    <a class="navbar-item" href="#浏览器内核">2.1.1&nbsp;&nbsp;浏览器内核</a>
                    
                    
                    
                    <a class="navbar-item" href="#多线程的内核">2.1.2&nbsp;&nbsp;多线程的内核</a>
                    
                    
                    
                    <a class="navbar-item" href="#URL解析">2.2&nbsp;&nbsp;URL解析</a>
                    
                    
                    <hr class="navbar-divider">
                    
                    
                    <a class="navbar-item" href="#发起一个完整的http请求">3&nbsp;&nbsp;<b>发起一个完整的http请求</b></a>
                    
                    
                    
                    <a class="navbar-item" href="#DNS查询">3.1&nbsp;&nbsp;DNS查询</a>
                    
                    
                    
                    <a class="navbar-item" href="#DNS服务器查询">3.1.1&nbsp;&nbsp;DNS服务器查询</a>
                    
                    
                    
                    <a class="navbar-item" href="#TCP-IP-请求">3.2&nbsp;&nbsp;TCP/IP 请求</a>
                    
                    
                    
                    <a class="navbar-item" href="#三次握手">3.2.1&nbsp;&nbsp;三次握手</a>
                    
                    
                    
                    <a class="navbar-item" href="#四次挥手">3.2.2&nbsp;&nbsp;四次挥手</a>
                    
                    
                    
                    <a class="navbar-item" href="#长连接、短连接">3.2.3&nbsp;&nbsp;长连接、短连接</a>
                    
                    
                    
                    <a class="navbar-item" href="#拾遗">3.2.4&nbsp;&nbsp;*拾遗</a>
                    
                    
                    
                    <a class="navbar-item" href="#建立TCP-IP连接后开始准备传输数据：HTTP报文">3.3&nbsp;&nbsp;建立TCP/IP连接后开始准备传输数据：HTTP报文</a>
                    
                    
                    
                    <a class="navbar-item" href="#报文结构">3.3.1&nbsp;&nbsp;报文结构</a>
                    
                    
                    <hr class="navbar-divider">
                    
                    
                    <a class="navbar-item" href="#服务器接收请求的处理">4&nbsp;&nbsp;<b>服务器接收请求的处理</b></a>
                    
                    
                    
                    <a class="navbar-item" href="#负载均衡">4.1&nbsp;&nbsp;负载均衡</a>
                    
                    
                    <hr class="navbar-divider">
                    
                    
                    <a class="navbar-item" href="#后台处理，返回数据">5&nbsp;&nbsp;<b>后台处理，返回数据</b></a>
                    
                    
                    
                    <a class="navbar-item" href="#断开连接（TCP-IP-四次挥手）">5.1&nbsp;&nbsp;断开连接（TCP/IP 四次挥手）</a>
                    
                    
                    <hr class="navbar-divider">
                    
                    
                    <a class="navbar-item" href="#解析页面">6&nbsp;&nbsp;<b>解析页面</b></a>
                    
                    
                    
                    <a class="navbar-item" href="#基本过程">6.1&nbsp;&nbsp;基本过程</a>
                    
                    
                    
                    <a class="navbar-item" href="#构建DOM树">6.1.1&nbsp;&nbsp;构建DOM树</a>
                    
                    
                    
                    <a class="navbar-item" href="#构建CSSOM树">6.1.2&nbsp;&nbsp;构建CSSOM树</a>
                    
                    
                    
                    <a class="navbar-item" href="#合成render树">6.1.3&nbsp;&nbsp;合成render树</a>
                    
                    
                    
                    <a class="navbar-item" href="#渲染">6.1.4&nbsp;&nbsp;渲染</a>
                    
                    
                    
                    <a class="navbar-item" href="#阻塞渲染">6.1.5&nbsp;&nbsp;* 阻塞渲染</a>
                    
                    
                    
                    <a class="navbar-item" href="#重绘（Reflow）、回流（Repaint）">6.1.6&nbsp;&nbsp;* 重绘（Reflow）、回流（Repaint）</a>
                    
                    
                    <hr class="navbar-divider">
                    
                    
                    <a class="navbar-item" href="#拾遗-1">7&nbsp;&nbsp;<b>拾遗</b></a>
                    
                    
                    
                    <a class="navbar-item" href="#HTTPS">7.1&nbsp;&nbsp;HTTPS</a>
                    
                    
                    
                    <a class="navbar-item" href="#加密">7.1.1&nbsp;&nbsp;加密</a>
                    
                    
                    
                    <a class="navbar-item" href="#SSL-TLS握手流程">7.1.2&nbsp;&nbsp;SSL/TLS握手流程</a>
                    
                    
                    
                    <a class="navbar-item" href="#浏览器安全">7.2&nbsp;&nbsp;*浏览器安全</a>
                    
                    
                    
                    <a class="navbar-item" href="#跨域">7.3&nbsp;&nbsp;跨域</a>
                    
                    
                    
                    <a class="navbar-item" href="#解决方式">7.3.1&nbsp;&nbsp;解决方式</a>
                    
                    
                    
                    <a class="navbar-item" href="#postMessage">7.3.2&nbsp;&nbsp;postMessage</a>
                    
                    
                    
                    <a class="navbar-item" href="#跨域cookie处理">7.3.3&nbsp;&nbsp;跨域cookie处理</a>
                    
                    
                    
                    <a class="navbar-item" href="#浏览器缓存机制">7.4&nbsp;&nbsp;浏览器缓存机制</a>
                    
                    
                    
                    <a class="navbar-item" href="#缓存位置">7.4.1&nbsp;&nbsp;缓存位置</a>
                    
                    
                    
                    <a class="navbar-item" href="#缓存策略">7.4.2&nbsp;&nbsp;缓存策略</a>
                    
                    
                    
                    <a class="navbar-item" href="#实际应用">7.4.3&nbsp;&nbsp;实际应用</a>
                    
                    
                    
                    <a class="navbar-item" href="#Javascript引擎解析过程">7.5&nbsp;&nbsp;Javascript引擎解析过程</a>
                    
                </div>
            </div>
            
            
            <a class="navbar-item" title="GitHub" href="https://github.com/asensiki">
                
                <i class="fab fa-github"></i>
                
            </a>
               
            
        </div>
    </div>
</nav>

    <section class="section">
    <div class="container">
    <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            从输入URL到页面加载的过程的知识梳理
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2019-08-20T14:03:55.000Z" itemprop="datePublished">8月 20 2019</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/Web/">Web</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            1 小时 read (About 6831 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <p><img src="https://i.loli.net/2019/08/20/ZxCuOHSi58mGjhW.png" alt></p>
<a id="more"></a>
<h1 id="知识梳理"><a href="#知识梳理" class="headerlink" title="知识梳理"></a>知识梳理</h1><ol>
<li>浏览器接受URL到开启网络请求</li>
<li>发起一个完整的http请求</li>
<li>服务器接收到请求到后台处理</li>
<li>后台与前端的http交互</li>
<li>浏览器接受到http数据包后的解析过程</li>
<li>补充<ol>
<li>JS引擎解析过程</li>
<li>http缓存</li>
<li>跨域、web安全等。</li>
</ol>
</li>
</ol>
<h1 id="浏览器接受URL到开启网络请求"><a href="#浏览器接受URL到开启网络请求" class="headerlink" title="浏览器接受URL到开启网络请求"></a>浏览器接受URL到开启网络请求</h1><h2 id="浏览器知识"><a href="#浏览器知识" class="headerlink" title="浏览器知识"></a>浏览器知识</h2><p><strong>浏览器是多进程的</strong>，比如Chrome，存在的进程包括主进程、GPU、浏览器内核等。</p>
<h3 id="浏览器内核"><a href="#浏览器内核" class="headerlink" title="浏览器内核"></a>浏览器内核</h3><p>浏览器内核简单来说就是渲染引擎，通过获取得页面内容、整理信息（CSS）、计算和组合出最终输出可视化内容。</p>
<p>在Chrome中，每打开一个标签页相当于开启了一个进程，每个Tab进程都有独立的渲染引擎实例互不干扰。</p>
<h3 id="多线程的内核"><a href="#多线程的内核" class="headerlink" title="多线程的内核"></a>多线程的内核</h3><p>浏览器内核由以下常驻线程组成</p>
<ul>
<li>GUI渲染线程：负责渲染浏览器界面HTML元素,当界面需要重绘(Repaint)或由于某种操作引发回流(reflow)时,该线程就会执行。</li>
</ul>
<ul>
<li>JavaScript引擎线程：负责解析Javascript脚本，运行代码。</li>
</ul>
<ul>
<li>定时触发器线程：浏览器定时计数器并不是由JavaScript引擎计数的, 因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确, 因此通过单独线程来计时并触发定时</li>
</ul>
<ul>
<li>事件触发器线程：当一个事件被触发时该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理。这些事件可以是当前执行的代码块如定时任务、也可来自浏览器内核的其他线程如鼠标点击、AJAX异步请求等，但由于JS的单线程关系所有这些事件都得排队等待JS引擎处理。</li>
</ul>
<ul>
<li>异步http请求线程：在XMLHttpRequest在连接后是通过浏览器新开一个线程请求， 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件放到 JavaScript引擎的处理队列中等待处理。</li>
</ul>
<h2 id="URL解析"><a href="#URL解析" class="headerlink" title="URL解析"></a>URL解析</h2><p>当在地址栏输入URL时，第一件事情就是对URL进行解析。</p>
<p>URL的组成：</p>
<ul>
<li>protocol：协议头（Http、ftp）</li>
<li>host：域名或IP地址</li>
<li>port：端口号（默认80）</li>
<li>path：目录路径</li>
<li>query：请求参数</li>
<li>fragment：#后的hash值，用来定位到某个位置</li>
</ul>
<h1 id="发起一个完整的http请求"><a href="#发起一个完整的http请求" class="headerlink" title="发起一个完整的http请求"></a>发起一个完整的http请求</h1><p>URL解析完毕后获域名，需要对域名进行DNS查询。解析成IP</p>
<h2 id="DNS查询"><a href="#DNS查询" class="headerlink" title="DNS查询"></a>DNS查询</h2><ol>
<li>如果浏览器有缓存，则是用浏览器缓存，否则使用系统本地缓存，</li>
<li>如果本机上也没有，则向DNS域名服务器查询（这个过程可能经过路由器，如果路由器中有缓存，则使用路由器缓存）。</li>
</ol>
<h3 id="DNS服务器查询"><a href="#DNS服务器查询" class="headerlink" title="DNS服务器查询"></a>DNS服务器查询</h3><p>本地域名服务器上都维护一份高速缓存，存放最近使用过的域名及对应的IP地址。如果在此没有找到，则发起递归查询。</p>
<h2 id="TCP-IP-请求"><a href="#TCP-IP-请求" class="headerlink" title="TCP/IP 请求"></a>TCP/IP 请求</h2><p>http本质上是TCP/IP请求。</p>
<p>经过DNS查询找到IP地址，根据IP地址向目标服务器发起请求，建立TCP/IP链接。</p>
<h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p><img src="https://i.loli.net/2019/08/20/COAmnpcw7KSgeHy.png" alt></p>
<p>基本过程：</p>
<ol>
<li><p>客户端：Hi～，你是Server吗？</p>
<ul>
<li>客户端将SYN段发送到服务器。SYN代表同步，这意味着客户端请求服务器与客户端将使用的序列号同步（每个新事务生成新的序列号）。</li>
</ul>
</li>
<li><p>服务器：Hi！，我是Server，你是Client吗？</p>
<ul>
<li>收到请求后，服务器会响应类似的消息。首先，它通过确认客户端发送的序列号来确认（ACK）请求。其次，它还请求客户端序列号的同步（SYN）。</li>
</ul>
</li>
<li><p>客户端：Yeah！我是Client。</p>
<ul>
<li>最后一步来自客户端，它确认（ACK）服务器发送的序列号。传输已准备好开始。</li>
</ul>
</li>
</ol>
<h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><blockquote>
<ol>
<li>A：向B发送一个FIN报文（表示没什么东西发送了，但是可以接收）要关闭连接了，这时A进入FIN_WAIT_1状态。</li>
<li>B：接收到A发送的FIN报文，然后向A发送一个ACK报文（表明已收到请求，但还没准备要关闭连接），进入ClOSE_WAIT状态。这时A收到确认包进入FIN_WAIT_2状态。</li>
<li>B：向A发送FIN报文（关闭连接请求）进入LAST_ACK（等待客户端确认的ACK包）。</li>
<li>A：收到B发送的FIN报文（关闭请求），向B发送ACK包，进入TIME_WAIT（等待B回应）。B收到确认包并关闭连接，这时A等待超时，关闭连接。</li>
</ol>
</blockquote>
<h3 id="长连接、短连接"><a href="#长连接、短连接" class="headerlink" title="长连接、短连接"></a>长连接、短连接</h3><blockquote>
<p>TCP/IP</p>
<ul>
<li>长连接：一个tcp/ip连接上可以连续发送多个数据包，在tcp连接保持期间，如果没有数据包发送，需要双方发检测包以维持此连接，一般需要自己做在线维持（类似于心跳包）</li>
<li>短连接：通信双方有数据交互时，就建立一个tcp连接，数据发送完成后，则断开此tcp连接</li>
</ul>
</blockquote>
<blockquote>
<p>http层面</p>
<ul>
<li><code>http1.0</code>中，默认使用的是短连接，也就是说，浏览器没进行一次http操作，就建立一次连接，任务结束就中断连接，譬如每一个静态资源请求时都是一个单独的连接</li>
<li>http1.1起，默认使用长连接，使用长连接会有这一行<code>Connection: keep-alive</code>，在长连接的情况下，当一个网页打开完成后，客户端和服务端之间用于传输http的tcp连接不会关闭，如果客户端再次访问这个服务器的页面，会继续使用这一条已经建立的连接</li>
</ul>
</blockquote>
<blockquote class="colorquote danger"><p><strong>keep-alive不会永远保持，它有一个持续时间，一般在服务器中配置（如apache），另外长连接需要客户端和服务器都支持时才有效</strong></p>
</blockquote>
<h3 id="拾遗"><a href="#拾遗" class="headerlink" title="*拾遗"></a>*拾遗</h3><h4 id="因特网协议栈（五层）"><a href="#因特网协议栈（五层）" class="headerlink" title="因特网协议栈（五层）"></a>因特网协议栈（五层）</h4><ol>
<li>应用层</li>
<li>传输层</li>
<li>网络层</li>
<li>数据链路层</li>
<li>物理层</li>
</ol>
<blockquote>
<p>从应用层发起http请求，到传输层经过三次握手建立TCP/IP连接，接着到网络层的IP寻址，再到数据链路层封装成帧，最后物理层利用物理链路传输。</p>
</blockquote>
<h4 id="OSI"><a href="#OSI" class="headerlink" title="OSI"></a>OSI</h4><p>开放系统互连参考模型 (Open System Interconnect 简称OSI）。</p>
<ol>
<li>物理层</li>
<li>数据链路层</li>
<li>网络层</li>
<li>传输层</li>
<li>会话层</li>
<li>表示层</li>
<li>应用层</li>
</ol>
<blockquote>
<p>会话层：管理不同用户和进程之间的对话</p>
<p>表示层：主要处理两个通信端的信息交换方式，如数据加密与解密、数据格式交换。</p>
</blockquote>
<h2 id="建立TCP-IP连接后开始准备传输数据：HTTP报文"><a href="#建立TCP-IP连接后开始准备传输数据：HTTP报文" class="headerlink" title="建立TCP/IP连接后开始准备传输数据：HTTP报文"></a>建立TCP/IP连接后开始准备传输数据：HTTP报文</h2><p><img src="https://i.loli.net/2019/08/21/Gdq4ZUajK8V6BgR.png" alt></p>
<h3 id="报文结构"><a href="#报文结构" class="headerlink" title="报文结构"></a>报文结构</h3><h4 id="通用头部"><a href="#通用头部" class="headerlink" title="通用头部"></a>通用头部</h4><h5 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h5><ul>
<li>GET：请求一个指定资源的表示形式. 使用GET的请求应该只被用于获取数据.</li>
<li>HEAD：请求一个与GET请求的响应相同的响应，但没有响应体.</li>
<li>POST：用于将实体提交到指定的资源，通常导致在服务器上的状态变化或副作用. </li>
<li>PUT：用请求有效载荷替换目标资源的所有当前表示。</li>
<li>DELETE：删除指定的资源。</li>
<li>CONNECT建立一个到由目标资源标识的服务器的隧道。</li>
<li>OPTIONS：用于描述目标资源的通信选项。</li>
<li>TRACE：沿着到目标资源的路径执行一个消息环回测试。</li>
<li>PATCH：用于对资源应用部分修改。</li>
</ul>
<h5 id="状态码（Status-Code）"><a href="#状态码（Status-Code）" class="headerlink" title="状态码（Status Code）"></a>状态码（Status Code）</h5><ul>
<li>1xx——指示信息，表示请求已接收，继续处理</li>
<li>2xx——成功，表示请求已被成功接收、理解、接受</li>
<li>3xx——重定向，要完成请求必须进行更进一步的操作</li>
<li>4xx——客户端错误，请求有语法错误或请求无法实现</li>
<li>5xx——服务器端错误，服务器未能实现合法的请求</li>
</ul>
<blockquote>
<p>常用状态码：</p>
<p>200——表明该请求被成功地完成，所请求的资源发送回客户端<br>304——自从上次请求后，请求的网页未修改过，请客户端使用本地缓存<br>400——客户端请求有错（譬如可以是安全模块拦截）<br>401——请求未经授权<br>403——禁止访问（譬如可以是未登录时禁止）<br>404——资源未找到<br>500——服务器内部错误<br>503——服务不可用</p>
</blockquote>
<h4 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h4><blockquote>
<p>Access-Control-Allow-Headers: 服务器端允许的请求Headers<br>Access-Control-Allow-Methods: 服务器端允许的请求方法<br>Access-Control-Allow-Origin: 服务器端允许的请求Origin头部（譬如为*）<br>Content-Type：服务端返回的实体内容的类型<br>Date：数据从服务器发送的时间<br>Cache-Control：告诉浏览器或其他客户，什么环境可以安全的缓存文档<br>Last-Modified：请求资源的最后修改时间<br>Expires：应该在什么时候认为文档已经过期,从而不再缓存它<br>Max-age：客户端的本地资源应该缓存多少秒，开启了Cache-Control后有效<br>ETag：请求变量的实体标签的当前值<br>Set-Cookie：设置和页面关联的cookie，服务器通过这个头部把cookie传给客户端<br>Keep-Alive：如果客户端有keep-alive，服务端也会有响应（如timeout=38）<br>Server：服务器的一些相关信息</p>
</blockquote>
<h4 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h4><blockquote>
<p>Accept: 接收类型，表示浏览器支持的MIME类型<br>（对标服务端返回的Content-Type）<br>Accept-Encoding：浏览器支持的压缩类型,如gzip等,超出类型不能接收<br>Content-Type：客户端发送出去实体内容的类型<br>Cache-Control: 指定请求和响应遵循的缓存机制，如no-cache<br>If-Modified-Since：对应服务端的Last-Modified，用来匹配看文件是否变动，只能精确到1s之内，http1.0中<br>Expires：缓存控制，在这个时间内不会请求，直接使用缓存，http1.0，而且是服务端时间<br>Max-age：代表资源在本地缓存多少秒，有效时间内不会请求，而是使用缓存，http1.1中<br>If-None-Match：对应服务端的ETag，用来匹配文件内容是否改变（非常精确），http1.1中<br>Cookie: 有cookie并且同域访问时会自动带上<br>Connection: 当浏览器与服务器通信时对于长连接如何进行处理,如keep-alive<br>Host：请求的服务器URL<br>Origin：最初的请求是从哪里发起的（只会精确到端口）,Origin比Referer更尊重隐私<br>Referer：该页面的来源URL(适用于所有类型的请求，会精确到详细页面地址，csrf拦截常用到这个字段)<br>User-Agent：用户客户端的一些必要信息，如UA头部等</p>
</blockquote>
<h1 id="服务器接收请求的处理"><a href="#服务器接收请求的处理" class="headerlink" title="服务器接收请求的处理"></a>服务器接收请求的处理</h1><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>用户发起的请求都指向调度服务器（反向代理服务器nginx控制负载均衡），然后调度服务器根据实际的调度算法，分配不同的请求给对应集群中的服务器执行，然后调度器等待实际服务器的HTTP响应，并将它反馈给用户。</p>
<h1 id="后台处理，返回数据"><a href="#后台处理，返回数据" class="headerlink" title="后台处理，返回数据"></a>后台处理，返回数据</h1><p>##nginx、node(express/jwt)、mongoDB</p>
<p>一般过程：</p>
<blockquote>
<p>统一的验证，如安全拦截，跨域验证，如不符合规则，就直接返回了相应的http报文。</p>
<p>验证通过后，进入实际的后台代码，此时是程序接收到请求，然后执行（譬如查询数据库，大量计算等等）。</p>
<p>执行完毕后，就会返回一个http响应包（一般这一步也会经过多层封装）然后就是将这个包从后端发送到前端，完成交互。</p>
</blockquote>
<h2 id="断开连接（TCP-IP-四次挥手）"><a href="#断开连接（TCP-IP-四次挥手）" class="headerlink" title="断开连接（TCP/IP 四次挥手）"></a>断开连接（TCP/IP 四次挥手）</h2><h1 id="解析页面"><a href="#解析页面" class="headerlink" title="解析页面"></a>解析页面</h1><p>浏览器解析页面是边解析边渲染的过程。</p>
<h2 id="基本过程"><a href="#基本过程" class="headerlink" title="基本过程"></a>基本过程</h2><ol>
<li>解析HTML，构建DOM树。</li>
<li>解析CSS，生成CSS规则树。</li>
<li>合并DOM、CSS规则树生成render树。</li>
<li>布局render树（Reflow），负责计算各个元素的尺寸，位置。</li>
<li>绘制render树（Repaint），绘制页面像素位置。（根据渲染树以及回流得到的几何信息，得到节点的绝对像素）</li>
<li>浏览器将给层的信息发送给GPU，GPU将各层合成（composite），显示在屏幕上。</li>
</ol>
<p><img src="https://i.loli.net/2019/08/22/pf6q9NPkWu1iVc2.png" alt="browser_rending"></p>
<h3 id="构建DOM树"><a href="#构建DOM树" class="headerlink" title="构建DOM树"></a>构建DOM树</h3><blockquote>
<p>Bytes → characters → tokens → nodes → DOM</p>
<p>因为我们是以字节数据进行数据传输的，首先将字节数据转化为字符串，然后浏览器将字符串进行词法分析转为标记（token），接着转化为node，这些node会根据不同node之间的联系构建成DOM树。</p>
</blockquote>
<h4 id="🌰"><a href="#🌰" class="headerlink" title="🌰"></a>🌰</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width,initial-scale=1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"style.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Asensiki<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello<span class="tag">&lt;<span class="name">span</span>&gt;</span>web<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"awesome.jpg"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>处理过程：</p>
<p><img src="https://i.loli.net/2019/08/22/jishUSAHTNJbuVL.png" alt></p>
<p>在解析HTML的过程中会遇到CSS、Javascript文件，这时候浏览器会下载这些文件。</p>
<h3 id="构建CSSOM树"><a href="#构建CSSOM树" class="headerlink" title="构建CSSOM树"></a>构建CSSOM树</h3><blockquote>
<p>Bytes → characters → tokens → nodes → CSSOM</p>
</blockquote>
<h4 id="🌰-style-css"><a href="#🌰-style-css" class="headerlink" title="🌰 style.css"></a>🌰 style.css</h4><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123; </span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">16px</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">p</span> &#123; </span><br><span class="line">  <span class="attribute">font-weight</span>: bold;</span><br><span class="line">  <span class="selector-tag">span</span> &#123; </span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">    <span class="attribute">display</span>: none</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">weight</span>: <span class="number">300px</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">img</span> &#123; </span><br><span class="line">  <span class="attribute">float</span>: right</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>生成的CSSOM树如下：</p>
<p><img src="https://i.loli.net/2019/08/22/EAtgpZjDMmovRzf.png" alt>    </p>
<h3 id="合成render树"><a href="#合成render树" class="headerlink" title="合成render树"></a>合成render树</h3><p>当DOM树和CSSOM构建完毕后，开始合成渲染树。</p>
<p>渲染树只会包括<strong>需要显示的节点</strong>和这些节点的样式信息，如果某个节点是 <code>display: none</code> 的，那么就不会在渲染树中显示。</p>
<p><img src="https://i.loli.net/2019/08/22/JfHlq7Tp8uwbVEi.png" alt></p>
<h3 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h3><p>合成<code>render tree</code> 后开始渲染。</p>
<blockquote>
<p>基本步骤：</p>
<ol>
<li>计算CSS样式。</li>
<li>构建渲染树。</li>
<li>布局，定位坐标、大小、z-index 等。（这里也叫回流）</li>
<li>绘制。</li>
</ol>
</blockquote>
<h3 id="阻塞渲染"><a href="#阻塞渲染" class="headerlink" title="* 阻塞渲染"></a>* 阻塞渲染</h3><p>渲染的过程需要先解析HTML，生成DOM Tree、CSSOM Tree并合成Render Tree 后才会进行。</p>
<p>所以说解析HTML、CSS时会阻塞渲染。</p>
<h4 id="CSS阻塞"><a href="#CSS阻塞" class="headerlink" title="CSS阻塞"></a>CSS阻塞</h4><ul>
<li>CSS下载时异步，不会阻塞浏览器构建DOM树</li>
<li>但是会阻塞渲染，也就是在构建render时，会等到css下载解析完毕后才进行（这点与浏览器优化有关，防止css规则不断改变，避免了重复的构建）</li>
<li>有例外，<code>media query</code>声明的CSS是不会阻塞渲染的</li>
</ul>
<h4 id="JS阻塞"><a href="#JS阻塞" class="headerlink" title="JS阻塞"></a>JS阻塞</h4><p><strong>当 HTML 解析器遇到一个 script 标记时，它会暂停构建 DOM，将控制权移交给 JavaScript 引擎；等 JavaScript 引擎运行完毕，浏览器会从中断的地方恢复 DOM 构建。</strong>也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 <code>script</code> 标签放在 <code>body</code> 标签底部的原因。</p>
<p>但不一定都要放在底部。也可以给<code>script</code>标签加上<code>defer</code> 或者 <code>async</code> 属性。</p>
<blockquote>
<p>Defer： html解析完成后才根据顺序执行下载。</p>
<p>Async：异步下载，谁先下载完先执行谁，这样也会阻塞，所以根据情况使用。</p>
</blockquote>
<h3 id="重绘（Reflow）、回流（Repaint）"><a href="#重绘（Reflow）、回流（Repaint）" class="headerlink" title="* 重绘（Reflow）、回流（Repaint）"></a>* 重绘（Reflow）、回流（Repaint）</h3><ul>
<li>Reflow：元素的内容、结构、位置或尺寸发生了变化，需要重新计算样式和渲染树。</li>
<li>Repaint：元素发生的改变只是影响了元素的一些外观之类的时候（例如，背景色，边框颜色，文字颜色等），此时只需要应用新样式绘制这个元素就可以了。</li>
</ul>
<p>在页面显示的过程中会多次进行Reflow和Repaint操作，而Reflow的成本比Repaint的成本高得多的多。因为Repaint只是将某个部分进行重新绘制而不用改变页面的布局，如：改变了某个元素的背景颜色。而如果将元素的display属性由block改为none则需要Reflow。</p>
<p><strong>回流还要进行重绘。</strong></p>
<h4 id="引起回流的操作"><a href="#引起回流的操作" class="headerlink" title="引起回流的操作"></a>引起回流的操作</h4><blockquote>
<ul>
<li>页面首次渲染</li>
<li>浏览器窗口大小发生改变</li>
<li>元素尺寸或位置发生改变</li>
<li>元素内容变化（文字数量或图片大小等等）</li>
<li>元素字体大小变化</li>
<li>添加或者删除<strong>可见</strong>的<code>DOM</code>元素</li>
<li>激活<code>CSS</code>伪类（例如：<code>:hover</code>）</li>
<li>查询某些属性或调用某些方法</li>
</ul>
</blockquote>
<h1 id="拾遗-1"><a href="#拾遗-1" class="headerlink" title="拾遗"></a>拾遗</h1><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><blockquote>
<p>https与http的区别就是： <strong>在请求前，会建立ssl连接，确保接下来的通信都是加密的，无法被轻易截取分析</strong>。</p>
<p>开启https需要后端服务器支持（申请证书）。</p>
<p>https开销比http要大，因为要额外建立安全链接和加密。</p>
</blockquote>
<h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3><ul>
<li>对称加密：两边拥有相同的秘钥，两边都知道如何将密文加密解密</li>
<li>非对称加密：服务端将公钥公布，客户端创建一个秘钥，然后通过服务端的公钥加密并发送给服务端，服务端接收到密文以后通过自己的私钥解密出正确的客户端秘钥，这时候两端就都知道秘钥是什么了。</li>
</ul>
<h3 id="SSL-TLS握手流程"><a href="#SSL-TLS握手流程" class="headerlink" title="SSL/TLS握手流程"></a>SSL/TLS握手流程</h3><ol>
<li>客户端发送一个随机值（Client-Radom）以及需要的协议和加密方式。</li>
<li>服务端收到客户端发送的随机值，回复一个随机值（Server-Random），选出确定的加密算法，并将自己的身份信息以证书的方式发送。</li>
<li>客户端收到服务器发来的证书。<ol>
<li>验证证书的合法性。</li>
<li>产生一个新的随机值，通过证书中的公钥以及指定的算法加密后发送给服务器。</li>
<li>利用三个随机值通过算法生成Http连接数据传输的对称加密key（session-key）。</li>
<li>使用约定好的HASH算法计算握手消息，并使用生成的<code>session key</code>对消息进行加密，最后将之前生成的所有信息发送给服务端。</li>
</ol>
</li>
<li>服务器收到客户端回复<ol>
<li>利用指定的加解密方式与自己的私钥进行解密，获得第三个随机值。</li>
<li>生成<code>session-key</code>。</li>
<li>使用<code>session-key</code>解密握手信息，验证hash值。</li>
<li>使用<code>session key</code>加密一段握手消息，发送给客户端</li>
</ol>
</li>
<li>客户端解密并验证握手信息的hash，一致则握手结束。</li>
</ol>
<p><strong>之后所有的https通信数据将由之前浏览器生成的session key并利用对称加密算法进行加密</strong></p>
<h2 id="浏览器安全"><a href="#浏览器安全" class="headerlink" title="*浏览器安全"></a>*浏览器安全</h2><ul>
<li>CSRF：跨站点请求伪造，通过伪造后台地址，诱导或者某些方式自动发送请求。<ul>
<li>防御<ol>
<li>使用Token验证。</li>
<li>cookie限制</li>
<li>阻止第三方站点请求（验证referrer）</li>
</ol>
</li>
</ul>
</li>
<li>XSS：代码注入，跨站点脚本攻击。<ul>
<li>攻击类型<ol>
<li>存储型：通过用户提交表单等方式向后台DB注入恶意代码。</li>
<li>DOM：包含恶意代码的URL诱导用户点击。</li>
<li>反射型：拼接包含恶意代码的URL，通过用户点击传递。</li>
</ol>
</li>
<li>防御<ol>
<li>HTML转译。</li>
<li>CSP（content-security-policy）：建立白名单<ol>
<li>禁止外域提交、加载代码。</li>
<li>禁止内联脚本运行。</li>
</ol>
</li>
<li>用户提交需要验证码。</li>
<li>HTTP-Only-Cookie</li>
<li>前端渲染，代码数据分离。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h2><p>浏览器为了安全策略使用同源政策，协议、域名或者端口有一个不同就是跨域。</p>
<h3 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h3><h4 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h4><p>利用 <code>&lt;script&gt;</code> 标签没有跨域限制的漏洞。通过 <code>&lt;script&gt;</code> 标签指向一个需要访问的地址并提供一个回调函数来接收数据当需要通讯时。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"http://domain/api?param1=a&amp;param2=b&amp;callback=jsonp"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonp</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    	<span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 封装</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonp</span>(<span class="params">url, jsonpCallback, success</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>)</span><br><span class="line">  script.src = url</span><br><span class="line">  script.async = <span class="literal">true</span></span><br><span class="line">  script.type = <span class="string">'text/javascript'</span></span><br><span class="line">  <span class="built_in">window</span>[jsonpCallback] = <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    success &amp;&amp; success(data)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(script)</span><br><span class="line">&#125;</span><br><span class="line">jsonp(<span class="string">'http://xxx'</span>, <span class="string">'callback'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>JSOPN 只能用于GET请求</p>
</blockquote>
<h4 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h4><p>CROS 需要后端和浏览器同时支持。（万恶之源IE系列）。</p>
<p>后端则需要设置<code>Access-Control-Allow-Origin：*</code>。（值可以自己限制那些域名，*表示所有）。</p>
<p>虽然设置 CORS 和前端没什么关系，但是通过这种方式解决跨域问题的话，会在发送请求时出现两种情况，分别为<strong>简单请求</strong>和<strong>复杂请求</strong>。</p>
<ol>
<li><p>简单请求：</p>
<ul>
<li><p>请求类型</p>
<ol>
<li>GET</li>
<li>POST</li>
<li>HEAD</li>
</ol>
</li>
<li><p>Content-Type</p>
<ol>
<li>text/plain</li>
<li>multipart/form-data</li>
<li>application/x-www-form-urlencoded</li>
</ol>
</li>
</ul>
</li>
<li><p>复杂请求</p>
<p>不符合以上条件的请求就肯定是复杂请求了。 复杂请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求,该请求是 option 方法的，通过该请求来知道服务端是否允许跨域请求。</p>
<p>Node.js  (express)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">  res.header(<span class="string">'Access-Control-Allow-Origin'</span>, <span class="string">'*'</span>)</span><br><span class="line">  res.header(<span class="string">'Access-Control-Allow-Methods'</span>, <span class="string">'PUT, GET, POST, DELETE, OPTIONS'</span>)</span><br><span class="line">  res.header(</span><br><span class="line">    <span class="string">'Access-Control-Allow-Headers'</span>,</span><br><span class="line">    <span class="string">'Origin, X-Requested-With, Content-Type, Accept, Authorization, Access-Control-Allow-Credentials'</span></span><br><span class="line">  )</span><br><span class="line">  next()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="Nginx反向代理"><a href="#Nginx反向代理" class="headerlink" title="Nginx反向代理"></a>Nginx反向代理</h4><h4 id="document-domain"><a href="#document-domain" class="headerlink" title="document.domain"></a>document.domain</h4><p>该方式只能用于<strong>二级域名相同</strong>的情况下，比如 <code>a.test.com</code> 和 <code>b.test.com</code> 适用于该方式。只需要给页面添加 <code>document.domain = &#39;test.com&#39;</code> 表示二级域名都相同就可以实现跨域</p>
<h3 id="postMessage"><a href="#postMessage" class="headerlink" title="postMessage"></a>postMessage</h3><p>这种方式通常用于获取嵌入页面中的第三方页面数据。一个页面发送消息，另一个页面判断来源并接收消息。</p>
<hr>
<h3 id="跨域cookie处理"><a href="#跨域cookie处理" class="headerlink" title="跨域cookie处理"></a>跨域cookie处理</h3><blockquote>
<ol>
<li>设置<code>withCredentials</code>为<code>true</code>即可让该跨域请求携带 Cookie。 注意携带的是目标页面所在域的 Cookie。</li>
<li>服务器同时设置<a href="https://www.w3.org/TR/cors/#access-control-allow-credentials-response-header" target="_blank" rel="noopener"><code>Access-Control-Allow-Credentials</code></a>响应头为<code>&quot;true&quot;</code>， 即可允许跨域请求携带 Cookie。</li>
<li><code>Access-Control-Allow-Origin</code><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS" target="_blank" rel="noopener">不允许使用通配符</a>。</li>
</ol>
</blockquote>
<h2 id="浏览器缓存机制"><a href="#浏览器缓存机制" class="headerlink" title="浏览器缓存机制"></a>浏览器缓存机制</h2><h3 id="缓存位置"><a href="#缓存位置" class="headerlink" title="缓存位置"></a>缓存位置</h3><ol>
<li><p>Service Worker</p>
<p>Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们<strong>自由控制</strong>缓存哪些文件、如何匹配缓存、如何读取缓存，并且<strong>缓存是持续性的</strong>。</p>
<p>当 Service Worker 没有命中缓存的时候，我们需要去调用 <code>fetch</code> 函数获取数据。也就是说，如果我们没有在 Service Worker 命中缓存的话，会根据缓存查找优先级去查找数据。<strong>但是不管我们是从 Memory Cache 中还是从网络请求中获取的数据，浏览器都会显示我们是从 Service Worker 中获取的内容。</strong></p>
</li>
<li><p>Memory Cache</p>
<p>Memory Cache 也就是内存中的缓存，读取内存中的数据肯定比磁盘快。<strong>但是内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。</strong> 一旦我们关闭 Tab 页面，内存中的缓存也就被释放</p>
</li>
<li><p>Disk Cache</p>
<p>Disk Cache 也就是存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之 Memory Cache <strong>胜在容量和存储时效性上。</strong></p>
<p>在所有浏览器缓存中，Disk Cache 覆盖面基本是最大的。它会根据 HTTP Herder 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。<strong>并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。</strong></p>
</li>
<li><p>Push Cache</p>
<p>Push Cache 是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用。<strong>并且缓存时间也很短暂，只在会话（Session）中存在，一旦会话结束就被释放。</strong></p>
</li>
<li><p>网络请求</p>
</li>
</ol>
<h3 id="缓存策略"><a href="#缓存策略" class="headerlink" title="缓存策略"></a>缓存策略</h3><p>浏览器缓存策略分为两种：<strong>强缓存</strong>和<strong>协商缓存</strong>，并且缓存策略都是通过设置 HTTP Header 来实现。</p>
<p><img src="https://i.loli.net/2019/08/23/myHQdE3vz1YFfae.png" alt></p>
<h4 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h4><p>强缓存（<code>200 from cache</code>）时，浏览器如果判断本地缓存未过期，就直接使用，无需发起http请求。</p>
<p>通过设置HTTP Header实现：<code>Expires</code>、<code>Cache-Control</code>。</p>
<p><strong>Cache-Control的优先级比Expires高</strong>。</p>
<p>一般使用<code>Cache-control: max-age=XXX</code></p>
<h4 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h4><p>如果缓存过期，则需要发起请求验证是否需要更新资源，协商缓存可以通过设置HTTP Header的<code>LastModified</code>、<code>Etag</code>实现。</p>
<p>当发起请求验证资源时，如果资源不需要更新，则服务器会返回<code>304</code>状态码，并且更新缓存有效期。</p>
<ul>
<li>Last-Modified：表示本地文件最后修改日期，<code>If-Modified-Since</code> 会将 <code>Last-Modified</code> 的值发送给服务器，询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来，否则返回 304 状态码。</li>
<li>Etag：是一种指纹机制，代表文件相关指纹只有文件变才会变，也只要文件变就会变，也没有精确时间的限制，只要文件一改变，立马E-tag就不一样了。</li>
</ul>
<h3 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h3><blockquote>
<p>对于频繁变动的资源，首先需要使用 <code>Cache-Control: no-cache</code> 使浏览器每次都请求服务器，然后配合 <code>ETag</code> 或者 <code>Last-Modified</code> 来验证资源是否有效。这样的做法虽然不能节省请求数量，但是能显著减少响应数据大小。</p>
</blockquote>
<h2 id="Javascript引擎解析过程"><a href="#Javascript引擎解析过程" class="headerlink" title="Javascript引擎解析过程"></a>Javascript引擎解析过程</h2><!-- tip -->
<blockquote class="colorquote info|success|warning|danger"></blockquote>
<!-- 代码 -->
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
    
    </div>
    
    
    <div class="columns is-mobile is-multiline article-nav">
        <span class="column is-12-mobile is-half-desktop is-hidden-mobile article-nav-prev">
            
        </span>
        <span class="column is-12-mobile is-half-desktop  article-nav-next">
            
            <a href="/2019/08/20/拾遗JavaScript——关于闭包/">拾遗JavaScript——关于闭包</a>
            
        </span>
    </div>
    
</article>




    </div>
</section>
    <footer class="footer">
    <div class="container">
        <div class="columns content">
            <div class="column is-narrow has-text-centered">
                &copy; 2019 mzw&nbsp;
                Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> & <a href="http://github.com/ppoffice/hexo-theme-minos">Minos</a>
            </div>
            <div class="column is-hidden-mobile"></div>

            
            <div class="column is-narrow">
                <div class="columns is-mobile is-multiline is-centered">
                
                    
                <a class="column is-narrow has-text-black" title="GitHub" href="https://github.com/asensiki">
                    
                    GitHub
                    
                </a>
                
                </div>
            </div>
            
            
        </div>
    </div>
</footer>
    <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script>

<!-- test if the browser is outdated -->
<div id="outdated">
    <h6>Your browser is out-of-date!</h6>
    <p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" href="http://outdatedbrowser.com/">Update my browser now </a></p>
    <p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p>
</div>
<script src="//cdnjs.cloudflare.com/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.js"></script>
<script>
    $(document).ready(function () {
        // plugin function, place inside DOM ready function
        outdatedBrowser({
            bgColor: '#f25648',
            color: '#ffffff',
            lowerThan: 'flex'
        })
    });
</script>

<script>
    window.FontAwesomeConfig = {
        searchPseudoElements: true
    }
    moment.locale("zh-CN");
</script>


    
    
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<script>
    MathJax.Hub.Config({
        "HTML-CSS": {
            matchFontHeight: false
        },
        SVG: {
            matchFontHeight: false
        },
        CommonHTML: {
            matchFontHeight: false
        },
        tex2jax: {
            inlineMath: [
                ['$','$'],
                ['\\(','\\)']
            ]
        }
    });
</script>

    
    
    
    
<script src="//cdnjs.cloudflare.com/ajax/libs/lightgallery/1.6.8/js/lightgallery-all.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/justifiedGallery/3.6.5/js/jquery.justifiedGallery.min.js"></script>
<script>
    (function ($) {
        $(document).ready(function () {
            if (typeof($.fn.lightGallery) === 'function') {
                $('.article.gallery').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof($.fn.justifiedGallery) === 'function') {
                $('.justified-gallery').justifiedGallery();
            }
        });
    })(jQuery);
</script>

    
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script>
    <style>
        .hljs {
            position: relative;
        }

        .hljs .clipboard-btn {
            float: right;
            color: #9a9a9a;
            background: none;
            border: none;
            cursor: pointer;
        }

        .hljs .clipboard-btn:hover {
          color: #8a8a8a;
        }

        .hljs > .clipboard-btn {
            display: none;
            position: absolute;
            right: 4px;
            top: 4px;
        }

        .hljs:hover > .clipboard-btn {
            display: inline;
        }

        .hljs > figcaption > .clipboard-btn {
            margin-right: 4px;
        }
    </style>
    <script>
      $(document).ready(function () {
        $('figure.hljs').each(function(i, figure) {
          var codeId = 'code-' + i;
          var code = figure.querySelector('.code');
          var copyButton = $('<button>Copy <i class="far fa-clipboard"></i></button>');
          code.id = codeId;
          copyButton.addClass('clipboard-btn');
          copyButton.attr('data-clipboard-target-id', codeId);

          var figcaption = figure.querySelector('figcaption');

          if (figcaption) {
            figcaption.append(copyButton[0]);
          } else {
            figure.prepend(copyButton[0]);
          }
        })

        var clipboard = new ClipboardJS('.clipboard-btn', {
          target: function(trigger) {
            return document.getElementById(trigger.getAttribute('data-clipboard-target-id'));
          }
        });
        clipboard.on('success', function(e) {
          e.clearSelection();
        })
      })
    </script>

    
    

    


<script src="/js/script.js"></script>

    
    <div class="searchbox ins-search">
    <div class="searchbox-mask"></div>
    <div class="searchbox-container ins-search-container">
        <div class="searchbox-input-wrapper">
            <input type="text" class="searchbox-input ins-search-input" placeholder="Type something...">
            <span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="searchbox-result-wrapper ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
    (function (window) {
        var INSIGHT_CONFIG = {
            TRANSLATION: {
                POSTS: 'Posts',
                PAGES: 'Pages',
                CATEGORIES: 'Categories',
                TAGS: 'Tags',
                UNTITLED: '(Untitled)',
            },
            CONTENT_URL: '/content.json',
        };
        window.INSIGHT_CONFIG = INSIGHT_CONFIG;
    })(window);
</script>
<script src="/js/insight.js"></script>
    
</body>
</html>