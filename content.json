{"pages":[{"title":"categories","text":"","link":"/categories/index.html"}],"posts":[{"title":"Hola","text":"心情不好～写点什么…","link":"/2019/03/01/Hola/"},{"title":"拾遗JavaScript——Promise","text":"","link":"/2019/03/10/拾遗JavaScript——Promise/"},{"title":"拾遗JavaScript——async-await","text":"async/await async/await 同 Promise、callback 一样是一种编写异步代码的方法。 async/await 实际上是建立在 promises 之上的，其返回的是一个 promise。 async/await 是非阻塞的。 async/await 更像是同步代码，如果多个异步代码没有依赖性却使用了 await 会导致性能上的降低。 描述当调用一个 async 函数时，会返回一个 Promise 对象。当这个 async 函数返回一个值时，Promise 的 resolve 方法会负责传递这个值；当 async 函数抛出异常时，Promise 的 reject 方法也会传递这个异常值。 async 函数中可能会有 await 表达式，这会使 async 函数暂停执行，等待 Promise 的结果出来，然后恢复 async 函数的执行并返回解析值（resolved）。 注意， await 关键字仅仅在 async function中有效。如果在 async function函数体外使用 await ，你只会得到一个语法错误（SyntaxError）。 https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/async_function 🌰假设一个函数getJsonData() 来获取 Json 数据。 promise 12345const request = url =&gt; &#123; getJsonData(url).then(response =&gt; &#123; console.log(response.data); &#125;);&#125;; async/await 123const request = async url =&gt; &#123; console.log(await getJsonData(url));&#125;; 看这样看起来，async/await 是不是简洁了很多？ 毕竟写一堆 then 也是很烦的。 错误处理 (try/catch)1code snippet async/await hellasync/await 把我们从曾经的callback hell 中解放，而现在，我们陷入了async/await hell。","link":"/2019/03/12/拾遗JavaScript——async-await/"},{"title":"拾遗JavaScript——var-let-const","text":"变量的声明方式var声明局部变量和全局变量。 let声明一个块级作用域的局部变量。 const声明一个块级作用域的只读常量(需要初始值)。 变量提升12console.log(a);var a = 1; // undefined 实际上上部分的代码可以理解为: 123var a;console.log(a);a = 1; 这就是变量提升。 对于函数来说，只有函数声明会被提升到顶部，而函数表达式不会被提升。 12345baz(); // baz is not a functionvar baz = function() &#123; console.log(\"bar2\");&#125;; 暂时性死区let（const）将不会提升变量到代码块的顶部。因此，在变量声明之前引用这个变量，将抛出引用错误（ReferenceError）。这个变量将从代码块一开始的时候就处在一个“暂时性死区”，直到这个变量被声明为止。 12console.log(a);let a = 1; //a is not defined","link":"/2019/03/27/拾遗JavaScript——var-let-const/"},{"title":"拾遗JavaScript——this","text":"一、Thisthis 到底是什么？如何确定 this 的指向性？ index.js1","link":"/2019/03/22/拾遗JavaScript——this/"},{"title":"拾遗JavaScript——深、浅拷贝","text":"数据类型JavaScript 中变量的数据类型分两种： 基本类型 （存储与栈内存中，值存储） 引用类型 （存储堆内存中，通过指针去寻找所指向的内存空间） 对于值类型的复制操作是直接堆变量的值进行拷贝；对于引用类型的复制操作是对存储变量的指针进行拷贝，指向同一内存空间，修改其中一个会影响另一方。 深浅拷贝只针对于 Array、Object 这样复杂的对象 浅拷贝只拷贝基本类型的数据，对于引用的类型数据，复制后也是会发生引用，这种拷贝就叫做浅拷贝 🌰： 对于对象来说，可以通过Object.assign()、...来实现浅拷贝1、Object.assign()1234567let obj = &#123; name: \"ken\"&#125;;let newObj = Object.assign(&#123;&#125;, obj);obj.name = \"obi\";console.log(obj.name); // name:obiconsole.log(newObj.name); // name: ken 2、...展开运算符123456789let obj = &#123; name: \"ken\"&#125;;let newObj = &#123; ...obj&#125;;obj.name = \"obi\";console.log(obj.name); // name:obiconsole.log(newObj.name); // name: ken 🌰：对于数组，可以通过concat()、slice() 来实现浅拷贝1、concat()concat() 方法用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。concat 方法不会改变 this 或任何作为参数提供的数组，而是返回一个浅拷贝，它包含与原始数组相结合的相同元素的副本。 原始数组的元素将复制到新数组中。 https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/concat 12345let arr = [1, 2, 3];let newArr = arr.concat();arr.push(4);console.log(arr); //[1,2,3,4]console.log(newArr); //[1,2,3] 2、slice()slice() 方法返回一个新的数组对象，这一对象是一个由 begin 和 end（不包括 end）决定的原数组的浅拷贝。原始数组不会被改变。 https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/slice 12345let arr = [1, 2, 3];let newArr = arr.slice();arr.push(4);console.log(arr); //[1,2,3,4]console.log(newArr); //[1,2,3] 当面对复杂一点的对象或者数组，使用 Object.assign(),Array.slice() 会怎么样？例如:1234567891011121314let obj = &#123; a: 1, b: 2, c: &#123; d: 1, e: 2 &#125;&#125;;let newObj = Object.assign(&#123;&#125;, obj);obj.a = 2;newObj.c.d = 2;console.log(obj); // &#123;a:2,b:2,c:&#123;d:2,e:2&#125;&#125;console.log(newObj); // &#123;a:1,b:2,c:&#123;d:2,e:2&#125;&#125; 12345678let arr = [1, 2, [1, 2], 3];let newArr = arr.concat();arr.push(4);arr[2].push(3);console.log(arr); //[1,2,[1,2,3],3,4]console.log(newArr); //[1,2,[1,2,3],3] 代码里修改了obj.a的值，并没对newObj造成影响，而修改了newObj.c.d的值，obj.c.d的值也随着改变。这是因为Object.assign()是浅拷贝，只拷贝了一层，对于obj.c是一个对象，所以newObj.c存储的是指向obj.c所指向的指针地址。同理...展开运算符、Array.concat()/Array.slice() 深拷贝解决上述问题最常见的实现方式就是：JSON.parse(JSON.stringify(object)) 123456789101112131415let obj = &#123; a: 1, b: 2, c: &#123; d: 1, e: 2 &#125;&#125;;let newObj = JSON.parse(JSON.stringify(obj));obj.a = 2;newObj.c.d = 2;console.log(obj); //&#123;a:2,b:2,c:&#123;d:1,e:2&#125;&#125;console.log(newObj); //&#123;a:1,b:2,c:&#123;d:2,e:2&#125;&#125; 当然，对象的序列化反序列化JSON.parse(JSON.stringify())并不是万能的。 忽略 undefined 忽略 symbol 不能序列化函数 不能解决循环引用的对象 https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify 12345678910111213141516171819202122232425let obj = &#123; a: () =&gt; &#123; console.log(\"copy\"); &#125;, b: undefined, c: Symbol, d: \"obi\"&#125;;let newObj = JSON.parse(JSON.stringify(obj));console.log(newObj); // &#123;d:obi&#125; 忽略undefined、symbol、不能序列化化函数let obj = &#123; a: 1, b: &#123; c: 2 &#125;&#125;;obj.c = obj.b; // `obj.c` 引用 `obj.b`obj.b.c = obj.c; // `obj.b.c` 又引用 `obj.c`let newObj = JSON.parse(JSON.stringify(obj));console.log(newObj); // 直接报错 实现简易的浅拷贝、深拷贝浅拷贝1234567891011121314151617181920const fn = (data, target = &#123;&#125;) =&gt; &#123; for (let item in data) &#123; if (data.hasOwnProperty(item)) &#123; target[item] = data[item]; &#125; &#125; return target;&#125;;let obj = &#123; a: 1, b: 2&#125;;let newObj = fn(obj);obj.a = 2;console.log(obj); //&#123;a:2,b:2&#125;console.log(newObj); //&#123;a:1,b:2&#125; 浅拷贝就是一个for..in循环,Object.prototype.hasOwnProperty的作用是检测目标是否属于自有属性,是则复制 深拷贝123456789101112131415161718192021222324252627282930const isObj = o =&gt; &#123; return typeof o === \"object\" || (typeof o === \"function\" &amp;&amp; o !== null);&#125;;const deepClone = obj =&gt; &#123; if (!isObj(obj)) &#123; throw new Error(\"not a Object！\"); &#125; let newObj = Array.isArray(obj) ? [] : &#123;&#125;; // 判断是否是数组或者是对象,设置初始值为空值 Object.keys(obj).forEach(key =&gt; &#123; newObj[key] = isObj(obj[key]) ? deepClone(obj[key]) : obj[key]; &#125;); return newObj;&#125;;let obj = &#123; a: [1, 2, 3], b: &#123; c: 2, d: 3 &#125;&#125;;let newObj = deepClone(obj);newObj.b.c = 1;console.log(obj.b.c); // 2console.log(newObj.b.c); // 1 这只是简单的深拷贝，未考虑其他情况，其余另做探究。 参考来自 Google、MDN","link":"/2019/03/05/拾遗JavaScript——深、浅拷贝/"},{"title":"拾遗webpack4（一）——入门","text":"webpack4 初体验webpack 是一个现代 JavaScript 应用程序的静态模块打包工具。当 webpack 处理应用程序时，它会在内部构建一个 依赖图(dependency graph)，此依赖图会映射项目所需的每个模块，并生成一个或多个 bundle。 从 4.0 版本开始，webpack 抛弃以前版本的那种繁琐、晦涩令初学者怯步的配置文件，开始零配置靠拢； 这无疑对于初学者来说，亲和力上了一层楼。 但它仍然具有可配置性满足多种需求。 在开始之前先了解核心概念 入口（entry） 输出（output） loader 插件（plugin） 模式（mode） 浏览器兼容性（bowser compatibility） 项目搭建创建空文件夹 webpack_demo，运行以下命令生成 package.json 1npm init 或者 npm init -y Tip-y 参数表示所有 package.json 参为默认 引入 webpack 1npm install webpack --save-dev 这里还需要使用 webpack-cli 脚手架 1npm install webpack-cli --save-dev 查看 package.json 文件可以看到目前使用的版本 12345\"devDependencies\": &#123; \"webpack\": \"^4.30.0\", \"webpack-cli\": \"^3.3.0\" &#125; 接下来在 packege.json 中增加 npm scripts 12345\"scripts\": &#123; \"build\": \"webpack\", \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" &#125; 到这里基本的项目搭建完毕，运行 npm run build 命令看看效果。 从图片里的报错信息可以得知：“未能找到入口文件” 回到文章开始讲的：webpack 中的核心概念：入口(entry) 入口(entry)入口起点(entry point)指示 webpack 应该使用哪个模块，来作为构建其内部 依赖图(dependency graph) 的开始。进入入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的。 https://webpack.docschina.org/concepts/#%E5%85%A5%E5%8F%A3-entry- webpack 的入口默认是 .src/index.js ,但我们可以通过 webpack.config.js 中去配置指定具体的入口起点。 webpack.config.js 12345module.exports = &#123; entry: &#123; app: \"./app.js\" &#125;&#125;; 现在新建一个src目录并添加入口文件 index.js 运行npm run build,可以看到控制台输出打包成功 并在目录下创建了dist文件夹和里面已经打包压缩好的文件main.js 这里讲一个 webpack 的一个核心概念：输出（output） 输出(output)output 属性告诉 webpack 在哪里输出它所创建的 bundle，以及如何命名这些文件。主要输出文件的默认值是 ./dist/main.js，其他生成文件默认放置在 ./dist 文件夹中。 https://webpack.docschina.org/concepts/#%E5%85%A5%E5%8F%A3-entry- 同样我们也可以在webpack.config.js 中去自定义输出点(output) webpack.config.js 1234567module.exports = &#123; output: &#123; publicPath: __dirname + \"/dist/\", // js 引用的路径或者CDN地址 path: path.resolve(__dirname, \"dist\"), // 打包文件的输出目录 filename: \"bundle.js\" // 打包后生产的js文件 &#125;&#125;; 模式(mode)前面运行npm run build 的过程中，虽然打包成功，但是控制台还输出几行警告信息: “没有设置 mode option” 这里就要讲到 webpack 中的一个核心点：mode， production development 我们可以在npm scripts 中告诉webpack-cli 以什么样的 mode 去构建例如: 1234567&#123; \"scripts\": &#123; \"dev\": \"webpack --mode development\", \"build\": \"webpack --mode production\", \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" &#125;&#125; 或者在webpack.config.js中设置 123module.exports = &#123; mode: \"production\"&#125;; 如果不设置的话，默认mode为production 现在我们来看看两中模式下的简单区别 执行 npm run dev 执行 npm run build 通过对比，在 dev 模式下，js 文件没有被压缩 一个完整的 Web 项目除了 js 脚本文件，应该还包含有 CSS、HTML 以及其他资源，如图片、字体等;那么在 webpack 中如何去处理这些资源呢？首先从处理 CSS 开始 loaderwebpack 只能理解 JavaScript 和 JSON 文件。loader 让 webpack 能够去处理其他类型的文件，并将它们转换为有效 模块，以供应用程序使用，以及被添加到依赖图中。 https://webpack.docschina.org/concepts/#loader 1、添加style.css2、处理 css 需要安装以下 loader 配合使用，执行npm i --save-dev style-loader css-loader css-loader：解析 CSS 代码，处理 CSS 中的依赖（@import、url()等） style-loader：将css-loader解析结果转变为 js 并动态插入 style 标签 123456\"devDependencies\": &#123; \"css-loader\": \"^2.1.1\", \"style-loader\": \"^0.23.1\", \"webpack\": \"^4.30.0\", \"webpack-cli\": \"^3.3.0\" &#125; 3、配置webpack.config.js 12345678910module.exports = &#123; module: &#123; rules: [ &#123; test: /\\.css$/, use: [\"style-loader\", \"css-loader\"] &#125; ] &#125;&#125;; 4、style.css 123.hola &#123; color: blue;&#125; 5、在index.js中 引入style.css 1import \"./style.css\"; 6、执行npm run build 7、在index.html中引入打包好的文件bundle.js 8、在浏览器中打开 index.html,在控制台可以看到 css 样式已经通过&lt;style&gt; 标签注入 处理sass、less，可以使用less-loader\\sass-loader 插件（plugin）在 html 文件中引入打包好后的 js 文件，如果更改了打包后的文件名称或者代码分割成多个文件，又要去一个个引入，甚是麻烦，这个时候就要使用html-webpack-plugin，打包完之后自动生成 HTML 文件，并自动引入打包后的 js 文件。 1、执行npm i html-webpack-plugin html-loader --save-dev2、配置webpack.config.js3、执行npm run build4、在dist文件夹下打开index.html 要部署到服务器前，这里要把webpack的output改为相对路径publicPath:&#39;./&#39;","link":"/2019/03/02/拾遗webpack4（一）——入门/"},{"title":"拾遗webpack4（三）——处理图片","text":"","link":"/2019/03/05/拾遗webpack4（三）——处理图片/"},{"title":"拾遗webpack4（二）——Babel","text":"BabelBabel 是什么？主要用于将 ECMAScript 2015+ 版本的代码转换为向后兼容的 JavaScript 语法，以便能够运行在当前和旧版本的浏览器或其他环境中。 1、执行以下命令安装所需要的 package 12npm install --save-dev babel-loader @babel/core @babel/preset-envnpm install --save @babel/polyfill babel-loader : 这是 Webpack 的 Babel 插件，它将被添加到 Webpack 配置中，以指示它在捆绑过程中通过 Babel 运行目标文件； @babel/core @babel/preset-env：通过根据目标浏览器或运行时环境自动确定所需的 Babel 插件和 polyfill，将代码编译为 ES5 @babel/polyfill：垫片，转化 ES6 内置语法（Array.from,Object.assign 等） 1234567891011\"devDependencies\": &#123; \"@babel/core\": \"^7.4.3\", \"@babel/preset-env\": \"^7.4.3\", \"babel-loader\": \"^8.0.5\", \"clean-webpack-plugin\": \"^2.0.1\", \"webpack\": \"^4.30.0\", \"webpack-cli\": \"^3.3.0\" &#125;, \"dependencies\": &#123; \"@babel/polyfill\": \"^7.4.3\" &#125; 2、新建 babel 配置文件.babelrc 来配置 babel 123&#123; \"presets\": [\"@babel/preset-env\"]&#125; 3、在webpack.config.js中配置 babel-loader 123456789module: &#123; rules: [ &#123; test: /\\.js$/, //匹配js文件 exclude: /node_modules/, //忽略目标文件夹 loader: \"babel-loader\" // 使用babel-loader &#125; ];&#125; 4、验证 在 index.js 中使用 ES6 语法 12345// import '@babel/polyfill'const arr = [\"1\", \"2\", \"3\"];const fn = () =&gt; console.log(...arr);fn(); 这里还需要import &#39;@babel/polyfill&#39;全局引入打包后体积大、根据需要转译的文件按需引用又很麻烦，这里只需要配置一下babelrc，babel 自动转译 .babelrc1234567891011&#123; \"presets\": [ [ \"@babel/preset-env\", &#123; \"useBuiltIns\": \"usage\", \"corejs\": \"3\" //使用core-js@3版本 &#125; ] ]&#125; 这里遇到一个小坑，配置完.babelrc后执行npm run build，控制台首先会提示一段警告: 大概意思就是指定用什么版本的core-js,默认使用core-js@2版本 然后报错 这里配置一下core-js的版本 执行npm run build 浏览器中打开dist文件夹下的index.html，查看控制台输出。 Chrome 最新版是支持 ES6 语法的，最好的还是在 IE 下测试。","link":"/2019/03/04/拾遗webpack4（二）——Babel/"},{"title":"拾遗JavaScript——Event Loop","text":"Event Loop一、基础知识预备 1、进程与线程 进程：应用程序的执行实例，每一个进程都是由私有的虚拟地址空间、代码、数据个其他系统资源组成。 线程：线程是进程内的一个独立执行单元，在不同的线程之间可以进行资源共享。 进程拥有独立的堆栈空间和数据段，每当启动一个新的进程必须分配给它独立的地址空间，建立众多的数据表来维护它的代码段、堆栈段和数据段。 线程拥有独立的堆栈空间，但是共享数据段，它们彼此之间使用相同的地址空间，共享大部分数据，比进程更加节俭，开销比较小，切换速度快，效率高。 一句话总结: 进程：资源分配的最小单位 线程：程序执行的最小单位 123","link":"/2019/04/09/拾遗JavaScript——Event-Loop/"},{"title":"拾遗JavaScript——原型与原型链","text":"一、原型prototype基本上每个函数都有 一个特殊的属性——原型（prototype），它是一个显式属性。 当我们创建一个函数时，这个属性就自动被创建。 1function fn()&#123;&#125; 函数的prototype是什么？ prototype 属性：继承成员定义的地方。 通俗的理解为：当我们实例化一个对象时，该对象会从原型中“继承”属性和方法。 12345678910111213141516function animal()&#123;&#125;;animal.prototype.class = \"animal\";animal.prototype.eat = function() &#123; console.log(\"eat something\");&#125;var cat = new animal();cat.eat(); // eat somethingconsole.log(cat.class); // \"animal\" 😪 抽象能力差怎么办？————画图 当我们打印cat这个实例时…….. What？？？ OOP思想中的继承（java，C++等）是一种对属性方法的复制操作，但对象实例cat中并没有复制过来的属性和方法，但在调用class属性和eat()方法时都可以正常调用。这？？？在JavaScript 的继承操作其实是一种“链接”操作，是一种委托，通过__proto__ 链接到构造函数的prototype。 __proto____proto__ 是每一个对象（除了null）都有的隐式属性，它指向创建该对象的构造函数的[[prototype]]，因此我们可以访问到定义在构造函数的prototype上的属性和方法。 1console.log(cat.__proto__ == animal.prototype); // true 当使用cat.__proto__ 时，实际上是返回Object.getPrototypeOf(cat)。可以理解为一种getter/setter操作。 😪 抽象能力差怎么办？——画图 constructor 在animal.prototype中还有一个属性constructor,它是干什么用的？ constructor:每一个实例对象都从原型中继承一个 constructor 属性，它指向构造此实例对象的构造函数； 因此实例cat的构造函数是function animal() 12console.log(animal.prototype.constructor === animal); // trueconsole.log(cat.constructor === animal); // true 我们还可以这样去创建animal的实例，但一般来说知道原始构造器function animal()的情况下不会用这样的方式。 1234const dog = new cat.constructor();dog.class // animaldog.eat() // eat somethingconsole.log(dog.constructor === animal); // true 画图捋一捋～ 原型的原型 ？捋清了实例与原型的关系,那原型的原型是什么？ animal.prototype 中也有一个属性__proto__ , 这个__proto__属性指向哪？ 在JavaScript中，函数其实也是Object，animal.prototype.__proto__ 指向的是Object.prototype 而Object.prototype.__proto__ === null 原型链1234567891011121314function animal()&#123;&#125;;animal.prototype.class = \"animal\";var cat = new animal();cat.class = \"cat\";console.log(cat.class); // catdelete cat.class; // 删除 cat 的 class 属性console.log(cat.class); // animalcat.isPrototypeOf();cat.valueOf() 由以上代码可以看出:1、cat.class 首先在实例cat上寻找属性class，输出“cat”2、删除实例cat上的属性class，仍能调用，但输出的是&quot;animal&quot;这是因为当在实例上寻找不到属性class时，会通过__proto__找到aminal.prototype，在上面寻找到class，并输出&quot;animal&quot;3、并没有在实例cat或者animal.prototype上定义isPrototypeOf()/valueOf()，为什么还能调用？这是因为当在实例、实例原型animal.prototype上找不时，解析器会继续往上，即animal.prototype.__proto__，直到__proto__指向null则停止寻找。此时animal.prototype.__proto__指向的是Object.prototype，所以调用上面定义的方法isPrototypeOf()/valueOf() 实例cat、构造函数animal的原型prototype、Object.prototype 以__proto__链接起来的关系就形成了原型链。 图腾","link":"/2019/04/10/拾遗JavaScript——原型与原型链/"}],"tags":[],"categories":[{"name":"Web","slug":"Web","link":"/categories/Web/"},{"name":"Javascript","slug":"Web/Javascript","link":"/categories/Web/Javascript/"},{"name":"Webpack","slug":"Web/Webpack","link":"/categories/Web/Webpack/"}]}