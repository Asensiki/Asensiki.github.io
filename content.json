{"pages":[{"title":"categories","text":"","link":"/categories/index.html"}],"posts":[{"title":"拾遗JavaScript——async-await","text":"async/await async/await 同 Promise、callback 一样是一种编写异步代码的方法。 async/await 实际上是建立在 promises 之上的，其返回的是一个 promise。 async/await 是非阻塞的。 async/await 更像是同步代码，如果多个异步代码没有依赖性却使用了 await 会导致性能上的降低。 描述当调用一个 async 函数时，会返回一个 Promise 对象。当这个 async 函数返回一个值时，Promise 的 resolve 方法会负责传递这个值；当 async 函数抛出异常时，Promise 的 reject 方法也会传递这个异常值。 async 函数中可能会有 await 表达式，这会使 async 函数暂停执行，等待 Promise 的结果出来，然后恢复 async 函数的执行并返回解析值（resolved）。 注意， await 关键字仅仅在 async function中有效。如果在 async function函数体外使用 await ，你只会得到一个语法错误（SyntaxError）。 https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/async_function 🌰假设一个函数getJsonData() 来获取 Json 数据。 promise 12345const request = url =&gt; &#123; getJsonData(url).then(response =&gt; &#123; console.log(response.data); &#125;);&#125;; async/await 123const request = async url =&gt; &#123; console.log(await getJsonData(url));&#125;; 看这样看起来，async/await 是不是简洁了很多？ 毕竟写一堆 then 也是很烦的。 错误处理 (try/catch)1code snippet async/await hellasync/await 把我们从曾经的callback hell 中解放，而现在，我们陷入了async/await hell。","link":"/2019/03/12/拾遗JavaScript——async-await/"},{"title":"拾遗JavaScript——this","text":"thisthis 到底是什么？如何确定 this 的指向性？ this 是让人困惑的东西～ this 在每个函数的作用域中被自动创建，当函数被调用时，一个执行上下文(execution context) 被创建 执行上下文 中包含一下信息 函数在哪调用（call-stack） 函数怎么被调用 作用域链 对象参数 this … this，指向函数执行期间的this对象。 1、this不是创建时绑定，而是动态绑定（runtime binding） 2、 this的上下文基于函数的调用情况，和函数在哪定义没有关系。 调用情况分析1.全局作用域（global context）1.1 浏览器中，this指向windowindex.js1console.log(this) // window; 1.2 在nodejs中，this指向 globalindex.js1console.log(this) // global; 2.函数作用域在函数内部，this由函数如何调用来确定指向 2.1 作为函数调用作为函数调用时，this并没有通过call指定，但this必须指定对象，因此默认指向window，所以调用foo()输出1。index.js12345function foo() &#123; return this.a;&#125;var a = 1;console.log(foo()); // 1 在严格模式下，this会保持在进入执行上下文时所设置的指向，如果没有设置，默认指向undefined。 index.js12345678910111213function fn() &#123; 'use strict' return this;&#125;console.log(fn()); //undefinedfunction foo() &#123; 'use strict' return this.a;&#125;var a = 1;console.log(foo()); // TypeError: Cannot read property 'a' of undefined 2.2 对象方法调用函数作为对象的方法调用时，this指向该对象。 index.js1234567const animal = &#123; name: \"animal\", sayName: function() &#123; console.log(this.name); &#125;&#125;;animal.sayName(); // animal 原型链上的方法调用与对象方法调用一样，this指向对象方法调用时的对象。 index.js12345678910function Person(name, age) &#123; this.name = name; this.age = age; &#125;Person.prototype.getName = function() &#123; return this.name;&#125;var p1 = new Person(‘Ken’, 20);p1.getName(); // Ken 下面讲new 调用构造函数所发生的事。 2.3 构造函数调用构造函数调用，this指向当前实例对象。 index.js1const a = new foo(); // this指向a; new调用构造函数： 1、创建一个新的对象 2、将新对象的原型设置为构造函数的原型对象prototype 3、执行构造函数，将this指向新对象 4、返回这个新对象 模拟实现： new.js123456789101112131415161718192021222324function create() &#123; let obj = new Object(); //从Object.prototype上克隆一个对象 //let obj = &#123;&#125;; let Constructor = [].shift.call(arguments); //获取传入的构造函数 obj.proto = Constructor.prototype; // 将新对象的proto指向构造函数的prototype let result = Constructor.apply(obj, arguments); // 将this指向新对象,并执行构造函数 return result instanceof Object ? result : obj; // 确保返回的是对象&#125;function animal(name, fit) &#123; this.name = name; this.fit = fit;&#125;animal.prototype.sayName = function() &#123; console.log(this.name);&#125;;const pig = create(animal, “Ken”, 12);pig.sayName(); // Ken 2.4 apply、call、bind2.4.1 apply、callcall： 使用一个指定的this和若干指定参数的前提下，调用某个函数或方法。apply： 与call类似，只是提供参数的方式不一样，apply的参数是数组。 12345678910function sum(c, d) &#123; return this.a + this.b + c + d;&#125;const obj = &#123; a: 1, b: 2&#125;;console.log(sum.call(obj, 1, 2)); // 6console.log(sum.apply(obj, [3, 4])); // 10 2.4.2 bind bind： 方法创建一个新的函数，在bind()被调用时，这个新函数的this被bind的第一个参数指定，其余的参数将作为新函数的参数供调用时使用。 MDN: https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind 与apply,call 不同的是，bind 返回一个原函数的拷贝。 123456789101112var a = 10;const module = &#123; a:1, getA:function() &#123; return this.a; &#125;&#125;module.getA(); // 1; 对象方法调用，`this`指向moduleconst getValueA = module.getA;getValueA(); // 10 全局作用域中调用getA()，所以这里输出10.const fn = getValueA.bind(module); //把 'this' 绑定到 module 对象fn(); // 1 如果将null/undefined作为this传入，在被调用的时候会被忽略，使用默认绑定（window）。可以传{}让this为空。 无论bind()多少次，this的指向永远由第一决定。 2.5 箭头函数 箭头函数的this继承于包裹它的第一个普通函数的this，如果没有普通函数，则为全局对象。 箭头函数的this在第一次绑定后就不会再改变。 不能使用new来调用 1234567891011121314151617181920212223242526function fn() &#123; return () =&gt; &#123; return () =&gt; &#123; console.log(this) &#125; &#125;&#125;console.log(fn()()()) // Windowvar name = \"Ken\"const module = &#123; name: \"module\", getName: function() &#123; const fn = ()=&gt; &#123; console.log(this.name) &#125; fn(); &#125;, // 外层没有普通函数包裹，因此`this`指向全局作用域 arrowFn: ()=&gt; &#123; console.log(this.name) &#125;&#125;module.getName(); // modulemodule.arrowFn(); // ken 总结this的绑定规则可以分为 new绑定 显示绑定：call、apply、bind 隐式绑定：作为对象方法调用 默认绑定：函数调用 优先级：new &gt; call、apply、bind &gt; obj.fn() &gt; fn()","link":"/2019/03/22/拾遗JavaScript——this/"},{"title":"拾遗JavaScript——var-let-const","text":"变量的声明方式var声明局部变量和全局变量。 let声明一个块级作用域的局部变量。 const声明一个块级作用域的只读常量(需要初始值)。 变量提升12console.log(a);var a = 1; // undefined 实际上上部分的代码可以理解为: 123var a;console.log(a);a = 1; 这就是变量提升。 对于函数来说，只有函数声明会被提升到顶部，而函数表达式不会被提升。 12345baz(); // baz is not a functionvar baz = function() &#123; console.log(\"bar2\");&#125;; 暂时性死区let（const）将不会提升变量到代码块的顶部。因此，在变量声明之前引用这个变量，将抛出引用错误（ReferenceError）。这个变量将从代码块一开始的时候就处在一个“暂时性死区”，直到这个变量被声明为止。 12console.log(a);let a = 1; //a is not defined","link":"/2019/03/27/拾遗JavaScript——var-let-const/"},{"title":"Hola","text":"心情不好～写点什么…","link":"/2019/03/01/Hola/"},{"title":"拾遗JavaScript——深、浅拷贝","text":"数据类型JavaScript 中变量的数据类型分两种： 基本类型 （存储与栈内存中，值存储） 引用类型 （存储堆内存中，通过指针去寻找所指向的内存空间） 对于值类型的复制操作是直接堆变量的值进行拷贝；对于引用类型的复制操作是对存储变量的指针进行拷贝，指向同一内存空间，修改其中一个会影响另一方。 深浅拷贝只针对于 Array、Object 这样复杂的对象 浅拷贝只拷贝基本类型的数据，对于引用的类型数据，复制后也是会发生引用，这种拷贝就叫做浅拷贝 🌰： 对于对象来说，可以通过Object.assign()、...来实现浅拷贝1、Object.assign()1234567let obj = &#123; name: \"ken\"&#125;;let newObj = Object.assign(&#123;&#125;, obj);obj.name = \"obi\";console.log(obj.name); // name:obiconsole.log(newObj.name); // name: ken 2、...展开运算符123456789let obj = &#123; name: \"ken\"&#125;;let newObj = &#123; ...obj&#125;;obj.name = \"obi\";console.log(obj.name); // name:obiconsole.log(newObj.name); // name: ken 🌰：对于数组，可以通过concat()、slice() 来实现浅拷贝1、concat()concat() 方法用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。concat 方法不会改变 this 或任何作为参数提供的数组，而是返回一个浅拷贝，它包含与原始数组相结合的相同元素的副本。 原始数组的元素将复制到新数组中。 https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/concat 12345let arr = [1, 2, 3];let newArr = arr.concat();arr.push(4);console.log(arr); //[1,2,3,4]console.log(newArr); //[1,2,3] 2、slice()slice() 方法返回一个新的数组对象，这一对象是一个由 begin 和 end（不包括 end）决定的原数组的浅拷贝。原始数组不会被改变。 https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/slice 12345let arr = [1, 2, 3];let newArr = arr.slice();arr.push(4);console.log(arr); //[1,2,3,4]console.log(newArr); //[1,2,3] 当面对复杂一点的对象或者数组，使用 Object.assign(),Array.slice() 会怎么样？例如:1234567891011121314let obj = &#123; a: 1, b: 2, c: &#123; d: 1, e: 2 &#125;&#125;;let newObj = Object.assign(&#123;&#125;, obj);obj.a = 2;newObj.c.d = 2;console.log(obj); // &#123;a:2,b:2,c:&#123;d:2,e:2&#125;&#125;console.log(newObj); // &#123;a:1,b:2,c:&#123;d:2,e:2&#125;&#125; 12345678let arr = [1, 2, [1, 2], 3];let newArr = arr.concat();arr.push(4);arr[2].push(3);console.log(arr); //[1,2,[1,2,3],3,4]console.log(newArr); //[1,2,[1,2,3],3] 代码里修改了obj.a的值，并没对newObj造成影响，而修改了newObj.c.d的值，obj.c.d的值也随着改变。这是因为Object.assign()是浅拷贝，只拷贝了一层，对于obj.c是一个对象，所以newObj.c存储的是指向obj.c所指向的指针地址。同理...展开运算符、Array.concat()/Array.slice() 深拷贝解决上述问题最常见的实现方式就是：JSON.parse(JSON.stringify(object)) 123456789101112131415let obj = &#123; a: 1, b: 2, c: &#123; d: 1, e: 2 &#125;&#125;;let newObj = JSON.parse(JSON.stringify(obj));obj.a = 2;newObj.c.d = 2;console.log(obj); //&#123;a:2,b:2,c:&#123;d:1,e:2&#125;&#125;console.log(newObj); //&#123;a:1,b:2,c:&#123;d:2,e:2&#125;&#125; 当然，对象的序列化反序列化JSON.parse(JSON.stringify())并不是万能的。 忽略 undefined 忽略 symbol 不能序列化函数 不能解决循环引用的对象 https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify 12345678910111213141516171819202122232425let obj = &#123; a: () =&gt; &#123; console.log(\"copy\"); &#125;, b: undefined, c: Symbol, d: \"obi\"&#125;;let newObj = JSON.parse(JSON.stringify(obj));console.log(newObj); // &#123;d:obi&#125; 忽略undefined、symbol、不能序列化化函数let obj = &#123; a: 1, b: &#123; c: 2 &#125;&#125;;obj.c = obj.b; // `obj.c` 引用 `obj.b`obj.b.c = obj.c; // `obj.b.c` 又引用 `obj.c`let newObj = JSON.parse(JSON.stringify(obj));console.log(newObj); // 直接报错 实现简易的浅拷贝、深拷贝浅拷贝1234567891011121314151617181920const fn = (data, target = &#123;&#125;) =&gt; &#123; for (let item in data) &#123; if (data.hasOwnProperty(item)) &#123; target[item] = data[item]; &#125; &#125; return target;&#125;;let obj = &#123; a: 1, b: 2&#125;;let newObj = fn(obj);obj.a = 2;console.log(obj); //&#123;a:2,b:2&#125;console.log(newObj); //&#123;a:1,b:2&#125; 浅拷贝就是一个for..in循环,Object.prototype.hasOwnProperty的作用是检测目标是否属于自有属性,是则复制 深拷贝123456789101112131415161718192021222324252627282930const isObj = o =&gt; &#123; return typeof o === \"object\" || (typeof o === \"function\" &amp;&amp; o !== null);&#125;;const deepClone = obj =&gt; &#123; if (!isObj(obj)) &#123; throw new Error(\"not a Object！\"); &#125; let newObj = Array.isArray(obj) ? [] : &#123;&#125;; // 判断是否是数组或者是对象,设置初始值为空值 Object.keys(obj).forEach(key =&gt; &#123; newObj[key] = isObj(obj[key]) ? deepClone(obj[key]) : obj[key]; &#125;); return newObj;&#125;;let obj = &#123; a: [1, 2, 3], b: &#123; c: 2, d: 3 &#125;&#125;;let newObj = deepClone(obj);newObj.b.c = 1;console.log(obj.b.c); // 2console.log(newObj.b.c); // 1 这只是简单的深拷贝，未考虑其他情况，其余另做探究。 参考来自 Google、MDN","link":"/2019/03/05/拾遗JavaScript——深、浅拷贝/"},{"title":"拾遗webpack4（一）——入门","text":"webpack4 初体验webpack 是一个现代 JavaScript 应用程序的静态模块打包工具。当 webpack 处理应用程序时，它会在内部构建一个 依赖图(dependency graph)，此依赖图会映射项目所需的每个模块，并生成一个或多个 bundle。 从 4.0 版本开始，webpack 抛弃以前版本的那种繁琐、晦涩令初学者怯步的配置文件，开始零配置靠拢； 这无疑对于初学者来说，亲和力上了一层楼。 但它仍然具有可配置性满足多种需求。 在开始之前先了解核心概念 入口（entry） 输出（output） loader 插件（plugin） 模式（mode） 浏览器兼容性（bowser compatibility） 项目搭建创建空文件夹 webpack_demo，运行以下命令生成 package.json 1npm init 或者 npm init -y Tip-y 参数表示所有 package.json 参为默认 引入 webpack 1npm install webpack --save-dev 这里还需要使用 webpack-cli 脚手架 1npm install webpack-cli --save-dev 查看 package.json 文件可以看到目前使用的版本 12345\"devDependencies\": &#123; \"webpack\": \"^4.30.0\", \"webpack-cli\": \"^3.3.0\" &#125; 接下来在 packege.json 中增加 npm scripts 12345\"scripts\": &#123; \"build\": \"webpack\", \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" &#125; 到这里基本的项目搭建完毕，运行 npm run build 命令看看效果。 从图片里的报错信息可以得知：“未能找到入口文件” 回到文章开始讲的：webpack 中的核心概念：入口(entry) 入口(entry)入口起点(entry point)指示 webpack 应该使用哪个模块，来作为构建其内部 依赖图(dependency graph) 的开始。进入入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的。 https://webpack.docschina.org/concepts/#%E5%85%A5%E5%8F%A3-entry- webpack 的入口默认是 .src/index.js ,但我们可以通过 webpack.config.js 中去配置指定具体的入口起点。 webpack.config.js 12345module.exports = &#123; entry: &#123; app: \"./app.js\" &#125;&#125;; 现在新建一个src目录并添加入口文件 index.js 运行npm run build,可以看到控制台输出打包成功 并在目录下创建了dist文件夹和里面已经打包压缩好的文件main.js 这里讲一个 webpack 的一个核心概念：输出（output） 输出(output)output 属性告诉 webpack 在哪里输出它所创建的 bundle，以及如何命名这些文件。主要输出文件的默认值是 ./dist/main.js，其他生成文件默认放置在 ./dist 文件夹中。 https://webpack.docschina.org/concepts/#%E5%85%A5%E5%8F%A3-entry- 同样我们也可以在webpack.config.js 中去自定义输出点(output) webpack.config.js 1234567module.exports = &#123; output: &#123; publicPath: __dirname + \"/dist/\", // js 引用的路径或者CDN地址 path: path.resolve(__dirname, \"dist\"), // 打包文件的输出目录 filename: \"bundle.js\" // 打包后生产的js文件 &#125;&#125;; 模式(mode)前面运行npm run build 的过程中，虽然打包成功，但是控制台还输出几行警告信息: “没有设置 mode option” 这里就要讲到 webpack 中的一个核心点：mode， production development 我们可以在npm scripts 中告诉webpack-cli 以什么样的 mode 去构建例如: 1234567&#123; \"scripts\": &#123; \"dev\": \"webpack --mode development\", \"build\": \"webpack --mode production\", \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" &#125;&#125; 或者在webpack.config.js中设置 123module.exports = &#123; mode: \"production\"&#125;; 如果不设置的话，默认mode为production 现在我们来看看两中模式下的简单区别 执行 npm run dev 执行 npm run build 通过对比，在 dev 模式下，js 文件没有被压缩 一个完整的 Web 项目除了 js 脚本文件，应该还包含有 CSS、HTML 以及其他资源，如图片、字体等;那么在 webpack 中如何去处理这些资源呢？首先从处理 CSS 开始 loaderwebpack 只能理解 JavaScript 和 JSON 文件。loader 让 webpack 能够去处理其他类型的文件，并将它们转换为有效 模块，以供应用程序使用，以及被添加到依赖图中。 https://webpack.docschina.org/concepts/#loader 1、添加style.css2、处理 css 需要安装以下 loader 配合使用，执行npm i --save-dev style-loader css-loader css-loader：解析 CSS 代码，处理 CSS 中的依赖（@import、url()等） style-loader：将css-loader解析结果转变为 js 并动态插入 style 标签 123456\"devDependencies\": &#123; \"css-loader\": \"^2.1.1\", \"style-loader\": \"^0.23.1\", \"webpack\": \"^4.30.0\", \"webpack-cli\": \"^3.3.0\" &#125; 3、配置webpack.config.js 12345678910module.exports = &#123; module: &#123; rules: [ &#123; test: /\\.css$/, use: [\"style-loader\", \"css-loader\"] &#125; ] &#125;&#125;; 4、style.css 123.hola &#123; color: blue;&#125; 5、在index.js中 引入style.css 1import \"./style.css\"; 6、执行npm run build 7、在index.html中引入打包好的文件bundle.js 8、在浏览器中打开 index.html,在控制台可以看到 css 样式已经通过&lt;style&gt; 标签注入 处理sass、less，可以使用less-loader\\sass-loader 插件（plugin）在 html 文件中引入打包好后的 js 文件，如果更改了打包后的文件名称或者代码分割成多个文件，又要去一个个引入，甚是麻烦，这个时候就要使用html-webpack-plugin，打包完之后自动生成 HTML 文件，并自动引入打包后的 js 文件。 1、执行npm i html-webpack-plugin html-loader --save-dev2、配置webpack.config.js3、执行npm run build4、在dist文件夹下打开index.html 要部署到服务器前，这里要把webpack的output改为相对路径publicPath:&#39;./&#39;","link":"/2019/03/02/拾遗webpack4（一）——入门/"},{"title":"拾遗webpack4（三）——处理图片","text":"","link":"/2019/03/05/拾遗webpack4（三）——处理图片/"},{"title":"拾遗webpack4（二）——Babel","text":"BabelBabel 是什么？主要用于将 ECMAScript 2015+ 版本的代码转换为向后兼容的 JavaScript 语法，以便能够运行在当前和旧版本的浏览器或其他环境中。 1、执行以下命令安装所需要的 package 12npm install --save-dev babel-loader @babel/core @babel/preset-envnpm install --save @babel/polyfill babel-loader : 这是 Webpack 的 Babel 插件，它将被添加到 Webpack 配置中，以指示它在捆绑过程中通过 Babel 运行目标文件； @babel/core @babel/preset-env：通过根据目标浏览器或运行时环境自动确定所需的 Babel 插件和 polyfill，将代码编译为 ES5 @babel/polyfill：垫片，转化 ES6 内置语法（Array.from,Object.assign 等） 1234567891011\"devDependencies\": &#123; \"@babel/core\": \"^7.4.3\", \"@babel/preset-env\": \"^7.4.3\", \"babel-loader\": \"^8.0.5\", \"clean-webpack-plugin\": \"^2.0.1\", \"webpack\": \"^4.30.0\", \"webpack-cli\": \"^3.3.0\" &#125;, \"dependencies\": &#123; \"@babel/polyfill\": \"^7.4.3\" &#125; 2、新建 babel 配置文件.babelrc 来配置 babel 123&#123; \"presets\": [\"@babel/preset-env\"]&#125; 3、在webpack.config.js中配置 babel-loader 123456789module: &#123; rules: [ &#123; test: /\\.js$/, //匹配js文件 exclude: /node_modules/, //忽略目标文件夹 loader: \"babel-loader\" // 使用babel-loader &#125; ];&#125; 4、验证 在 index.js 中使用 ES6 语法 12345// import '@babel/polyfill'const arr = [\"1\", \"2\", \"3\"];const fn = () =&gt; console.log(...arr);fn(); 这里还需要import &#39;@babel/polyfill&#39;全局引入打包后体积大、根据需要转译的文件按需引用又很麻烦，这里只需要配置一下babelrc，babel 自动转译 .babelrc1234567891011&#123; \"presets\": [ [ \"@babel/preset-env\", &#123; \"useBuiltIns\": \"usage\", \"corejs\": \"3\" //使用core-js@3版本 &#125; ] ]&#125; 这里遇到一个小坑，配置完.babelrc后执行npm run build，控制台首先会提示一段警告: 大概意思就是指定用什么版本的core-js,默认使用core-js@2版本 然后报错 这里配置一下core-js的版本 执行npm run build 浏览器中打开dist文件夹下的index.html，查看控制台输出。 Chrome 最新版是支持 ES6 语法的，最好的还是在 IE 下测试。","link":"/2019/03/04/拾遗webpack4（二）——Babel/"},{"title":"The Boring Project——驾校管理系统","text":"～ 1","link":"/2019/08/11/The-Boring-Project——驾校管理系统/"},{"title":"拾遗JavaScript——关于闭包","text":"闭包闭包真的是一个很大的话题～ 定义 MDN：闭包是由函数以及创建该函数的词法环境组合而成。这个环境包含了这个闭包创建时所能访问的所有局部变量。 《Javascript高级程序设计》：闭包是指有权访问另一个函数作用域中的变量的函数。 《你不知道的JS》：当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。这样的函数称之为闭包。 因此可以看出闭包由函数及函数可以访问的自由变量组成，那自由变量又是啥？ 自由变量：在函数中使用的变量，但它既不是函数的参数，也不是函数的局部变量。 🌰 112345678function foo() &#123; var a = 1; function bar() &#123; console.log(a); &#125; bar(); &#125;foo(); // 1 在这个例子中，bar() 中，变量a既不是bar()的参数也不在bar()的作用域中，因此变量a是一个自由变量。 那么bar()就是一个闭包囖？ 理论来说，是的。但严格意义上及实践角度来说并不是。 bar()能访问到变量a只是基于是词法作用域的查找规则。 🌰 2123456789function foo() &#123; var a = 1; function bar() &#123; console.log(a); &#125; return bar; &#125;const fn = foo(); fn(); 分析当函数foo()执行时，bar()当作返回值bar返回给fn，执行fn()其实就是执行bar()。 foo() 执行完毕后，通常意义上的理解是，当执行foo()时，foo()被推入执行栈中，执行完毕后推出执行栈，foo()随即被销毁，即内存回收机制。 bar()在定义它的词法作用域外执行，却可以访问到变量a，并输出变量a的值。这就是闭包的作用。 闭包使得函数foo()的内部作用域依旧存在，因为函数bar()依旧在使用它（内部函数从父函数中返回）。 因此，闭包包含了函数及函数所声明时的词法作用域。 经典案例闭包与循环🌰12345for (var i = 0; i &lt; 10; i++) &#123; setTimeout(function() &#123; console.log(i); &#125;, 500);&#125; 正常理解的结果是分别输出1-9，但这段代码最后会输出十次10。 因为setTimeout是一个异步回调函数，它会在for循环结束之后才会执行，此时i=10（i=10循环才会结束）。 这段代码其实是在一个全局作用域中执行的，变量i在全局作用域中定义，因此只有一个变量i（虽然循环中的setTimeout在每个循环迭代中定义一次，但它们都共享引用一个变量i）。 如何解决？IIFE（立即执行函数）立即执行函数会创建一个封闭的作用域，通过变量j存储i的值，在每次循环迭代中创建一个封闭作用域，通过变量j保持正确的i的值。 12345678for (var i = 0; i &lt; 10; i++) &#123; (function(j) &#123; j = i; setTimeout(function() &#123; console.log(j); &#125;, 500); &#125;)(i);&#125; 块级作用域12345for (let i = 0; i &lt; 10; i++) &#123; setTimeout(() =&gt; &#123; console.log(i); &#125;, 500);&#125; 闭包的使用如果将函数（访问它们各自的词法作用域）当作第一级的值类型并到处传递，你就会看到闭包在这些函数中的应用。在定时器、事件监听器、Ajax 请求、跨窗口通信、Web Workers 或者任何其他的异步（或者同步）任务中，只要使用了回调函数，实际上就是在使用闭包！ 定义私有方法12345678910111213141516171819202122232425const makeCounter = function() &#123; var privateCounter = 0; function changeBy(val) &#123; privateCounter += val; &#125; return &#123; increment: function() &#123; changeBy(1); &#125;, decrement: function() &#123; changeBy(-1); &#125;, value: function() &#123; return privateCounter; &#125; &#125;;&#125;;const counter1 = makeCounter();const counter2 = makeCounter();counter1.increment();console.log(counter1.value()); // 1counter2.increment();console.log(counter2.value()); // 1// https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures 两个计数器 counter1 和 counter2 是如何维护它们各自的独立性的。每个闭包都是引用自己词法作用域内的变量 privateCounter 。 每次调用其中一个计数器时，通过改变这个变量的值，会改变这个闭包的词法环境。然而在一个闭包内对变量的修改，不会影响到另外一个闭包中的变量。 如果不是某些特定任务需要使用闭包，在其它函数中创建函数是不明智的，因为闭包在处理速度和内存消耗方面对脚本性能具有负面影响。","link":"/2019/08/20/拾遗JavaScript——关于闭包/"},{"title":"Javascript——防抖与节流","text":"防抖防止函数多次调用，例如一个用户一直触发这个函数，且每次触发函数的间隔小于 wait，防抖的情况下只会调用一次。 Code123456789101112131415161718192021222324252627/** *防抖函数 * @param &#123;function&#125; fn 需要执行的函数，（例如网络请求） * @param &#123;number&#125; wait 等待时间，预设 50ms * @returns &#123;function&#125; 需要进行防抖处理的函数 */const debounce = (fn, wait = 50) =&gt; &#123; let timer = 0; //初始化一个定时器 // 返回进行防抖处理的函数 return function(...arguments) &#123; // 如果定时器存在则清空上一次的定时器 if (timer) &#123; clearTimeout(timer); &#125; // 重新计时，延迟执行传入的函数 timer = setTimeout(() =&gt; &#123; fn.apply(this, arguments); &#125;, wait); &#125;;&#125;;// Button 按钮document.getElementById(\"btn\").addEventListener( \"click\", debounce(function(e) &#123; console.log(\"change\", e.target.value, new Date() - 0); &#125;, 350)); 一般防抖都会有一个选项：是否立即调用。在不同使用场景进行区分使用。例如： 在搜索引擎搜索问题的时候，我们当然是希望用户输入完最后一个字才调用查询接口，这个时候适用延迟执行的防抖函数，它总是在一连串（间隔小于 wait 的）函数触发之后调用。 文本输入的验证（连续输入文字后发送请求进行验证，验证一次就好)。 比如一个 start 按钮，当点击按钮的时候立刻改变按钮形状，这时候用户可以知道交互操作正在进行，那么需要立即执行函数。 改造：加入立即执行选项1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * 防抖 * @param &#123;function&#125; fn 需要执行的函数，（例如网络请求） * @param &#123;Boolean&#125; immediate 是否立即执行，默认 true * @param &#123;Number&#125; wait 等待时间，预设 50ms * @returns &#123;function&#125; 需要进行防抖处理的函数 */const debounce = (fn, immediate = true, wait = 50) =&gt; &#123; let timer = 0; //初始化一个定时器 let context, args; //执行上下文、参数 // 延迟执行函数 const later = () =&gt; setTimeout(() =&gt; &#123; // 延迟函数执行完毕，清空缓存的定时器 timer = null; if (!immediate) &#123; // 执行函数 fn.apply(context, args); // 重置执行上下文和参数 context = args = null; &#125; &#125;, wait); // 返回进行防抖处理的函数 return function(...arguments) &#123; // 如果定时器不存在则创建延迟定时器。 if (!timer) &#123; timer = later(); // 如果是立即执行，则执行函数 if (immediate) &#123; fn.apply(this, arguments); &#125; else &#123; //缓存执行上下文和参数 context = this; args = arguments; &#125; &#125; else &#123; // 如果已有延迟执行函数（later），调用的时候清除原来的并重新设定一个. // 这样做延迟函数会重新计时 clearTimeout(timer); timer = later(); &#125; &#125;;&#125;; 对于按钮的点击来说，假设你连续点击了 10 次，如果网络请求防抖是立即执行的，在这 10 次过程中，函数只在点击的第一次立即执行。其余的 9 次都在重置定时器，等到最后一次设定的计时器计时时间到，再次点击才重新执行。 节流简单可以理解为：将多次执行的函数固定成每隔一段时间执行。 一般情况下有 2 中不同的限制方式适用不同需求 首次是否执行 结束后是否执行 Code使用时间戳实现思路 变量previous记录调用方法的时间戳. 对比之前的时间错，如果大于设置的时间错，则执行函数。执行后更新时间戳为当前时间。 123456789101112const throttle = (func, delay) =&gt; &#123; let previous = 0; return function(...args) &#123; let now = +new Date(); // 将当前时间和上一次执行函数时间对比 // 如果差值大于设置的等待时间就执行函数 if (now - previous &gt; delay) &#123; previous = now; func.apply(this, args); &#125; &#125;;&#125;; 代码分析 1.第一次执行时，if (now - previous &gt; delay)，previous=0，所以方法立即执行，随后记录previous=now()，每隔 1s 执行一次方法。 2.但不会触发最后一次执行。 使用setTimeout实现思路 当执行 throttle 函数时，判断是否存在定时器，如果不存在，则开启一个定时器， 123456789101112const throttle = (func, delay) =&gt; &#123; let timer; return function(...args) &#123; // 如果定时器不存在，则开启一个定时器。 if (!timer) &#123; timer = setTimeout(() =&gt; &#123; func.apply(this, args); timer = null; &#125;, delay); &#125; &#125;;&#125;; 代码分析 当连续调用 throttle 函数时，方法func不会立即执行，之后根据设定的 delay 时间间隔执行。 结束调用后还会执行一次。 两者之间的区别在与是否首次执行和是否结束后执行。 完善思路 增加options选项，可选 leading:false 表示禁用第一次执行、trailing:false 表示禁用停止触发的回调 1234567891011121314151617181920212223242526272829const throttle = (func, delay, option) =&gt; &#123; let timer, previous = null; // const later = function() &#123; previous = option.leading === false ? 0 : +new Date(); func.apply(this, arguments); timer = null; &#125;; return function(...args) &#123; // 如果定时器不存在，则开启一个定时器。 let now = +new Date(); // 如果leading===false表示第一次调用不执行； if (option.leading === false &amp;&amp; !previous) &#123; previous = now; &#125; // 根据时间戳对比是否在限制时间内 if (now - previous &gt; delay) &#123; if (timer) &#123; clearTimeout(timer); timer = null; &#125; func.apply(this, args); previous = now; &#125; else if (!timer &amp;&amp; option.trailing !== false) &#123; timer = setTimeout(later, delay); &#125; &#125;;&#125;;","link":"/2019/08/09/防抖与节流/"},{"title":"拾遗JavaScript——原型与原型链","text":"一、原型prototype基本上每个函数都有 一个特殊的属性——原型（prototype），它是一个显式属性。 当我们创建一个函数时，这个属性就自动被创建。 1function fn()&#123;&#125; 函数的prototype是什么？ prototype 属性：继承成员定义的地方。 通俗的理解为：当我们实例化一个对象时，该对象会从原型中“继承”属性和方法。 12345678910111213141516function animal()&#123;&#125;;animal.prototype.class = \"animal\";animal.prototype.eat = function() &#123; console.log(\"eat something\");&#125;var cat = new animal();cat.eat(); // eat somethingconsole.log(cat.class); // \"animal\" 😪 抽象能力差怎么办？————画图 当我们打印cat这个实例时…….. What？？？ OOP思想中的继承（java，C++等）是一种对属性方法的复制操作，但对象实例cat中并没有复制过来的属性和方法，但在调用class属性和eat()方法时都可以正常调用。这？？？在JavaScript 的继承操作其实是一种“链接”操作，是一种委托，通过__proto__ 链接到构造函数的prototype。 __proto____proto__ 是每一个对象（除了null）都有的隐式属性，它指向创建该对象的构造函数的[[prototype]]，因此我们可以访问到定义在构造函数的prototype上的属性和方法。 1console.log(cat.__proto__ == animal.prototype); // true 当使用cat.__proto__ 时，实际上是返回Object.getPrototypeOf(cat)。可以理解为一种getter/setter操作。 😪 抽象能力差怎么办？——画图 constructor 在animal.prototype中还有一个属性constructor,它是干什么用的？ constructor:每一个实例对象都从原型中继承一个 constructor 属性，它指向构造此实例对象的构造函数； 因此实例cat的构造函数是function animal() 12console.log(animal.prototype.constructor === animal); // trueconsole.log(cat.constructor === animal); // true 我们还可以这样去创建animal的实例，但一般来说知道原始构造器function animal()的情况下不会用这样的方式。 1234const dog = new cat.constructor();dog.class // animaldog.eat() // eat somethingconsole.log(dog.constructor === animal); // true 画图捋一捋～ 原型的原型 ？捋清了实例与原型的关系,那原型的原型是什么？ animal.prototype 中也有一个属性__proto__ , 这个__proto__属性指向哪？ 在JavaScript中，函数其实也是Object，animal.prototype.__proto__ 指向的是Object.prototype 而Object.prototype.__proto__ === null 原型链1234567891011121314function animal()&#123;&#125;;animal.prototype.class = \"animal\";var cat = new animal();cat.class = \"cat\";console.log(cat.class); // catdelete cat.class; // 删除 cat 的 class 属性console.log(cat.class); // animalcat.isPrototypeOf();cat.valueOf() 由以上代码可以看出:1、cat.class 首先在实例cat上寻找属性class，输出“cat”2、删除实例cat上的属性class，仍能调用，但输出的是&quot;animal&quot;这是因为当在实例上寻找不到属性class时，会通过__proto__找到aminal.prototype，在上面寻找到class，并输出&quot;animal&quot;3、并没有在实例cat或者animal.prototype上定义isPrototypeOf()/valueOf()，为什么还能调用？这是因为当在实例、实例原型animal.prototype上找不时，解析器会继续往上，即animal.prototype.__proto__，直到__proto__指向null则停止寻找。此时animal.prototype.__proto__指向的是Object.prototype，所以调用上面定义的方法isPrototypeOf()/valueOf() 实例cat、构造函数animal的原型prototype、Object.prototype 以__proto__链接起来的关系就形成了原型链。 图腾","link":"/2019/04/10/拾遗JavaScript——原型与原型链/"},{"title":"拾遗JavaScript——Promise","text":"基本使用没啥好记录～ 具体参考 MDN Promise https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise Promise 具体用法 https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Using_promises Promise.all()Promise.all() 参数一个可迭代对象，如 Array 或 String。 返回值 如果传入的参数是一个空的对象，则返回一个已完成（already resolved）状态的 Promise。 如果传入的参数不包含任何 promise，则返回一个异步完成（asynchronously resolved） Promise。 1、Promise.all 返回的 promise 的完成状态的结果都是一个数组。2、如果所有传入的 promise 都变为完成状态，或者传入的可迭代对象内没有 promise，Promise.all 返回的 promise 异步地变为完成3、如果传入的 promise 中有一个失败（rejected），Promise.all 异步地将失败的那个结果给失败状态的回调函数，而不管其它 promise 是否完成，从而丢弃其他Promise的完成结果。 🌰当我们在同时发起多个网络请求时，可以用Promise.all()来处理。 promise.js12345678910111213141516function fetchData(url) &#123;return new Promise((resolve, reject) =&gt; &#123;const requet = new XMLHttpRequest();requet.open(\"GET\", url);requet.onload = () =&gt; resolve(requet.responseText);requet.onerror = () =&gt; reject(requet.statusText);requet.send();&#125;);&#125;const fetch_1 = fetchData(topNewsUrl)const fetch_2 = fetchData(topNewsUrl)const fetch_3 = fetchData(topNewsUrl)Promise.all([fetch_1,fetch_2,fetch_3]).then(res=&gt;&#123;console.log(res);&#125;) 但是当Promise.all()中有一个promise的状态为rejected，则会抛弃其他已完成的结果。 promise.js1234567891011const fetch_1 = fetchData(topNewsUrl);const fetch_2 = fetchData(topNewsUrl);const fetch_3 = Promise.reject(\"err\");Promise.all([fetch_1, fetch_2, fetch_3]).then(res =&gt; &#123;console.log(res);&#125;).catch(err =&gt; &#123;console.log(err);&#125;); 但是有时候我们想要同时得到正确处理的结果和失败结果，可以这样处理promise.js1234567891011121314151617const fetch_1 = fetchData(topNewsUrl);const fetch_2 = fetchData(topNewsUrl);// 用 catch()捕获当前 promise reject(\"err\")，并返回。// catch() 返回值是一个 promise，如果不被 rejected，则它显示为成功(resolved)const fetch_3 = Promise.reject(\"err\").catch(err =&gt;&#123;return err;&#125;);const fetchs = [fetch_1, fetch_2, fetch_3];Promise.all(fetchs).then(res =&gt; &#123;console.log(res);&#125;).catch(err =&gt; &#123;console.log(err);&#125;); 同时也可以使用Promise.allSettled() Promise.allSettled()Promise.allSettled()： 无论是成功或拒绝。返回数组包含原始promises集中每个promise的结果。 1234567const fetch_1 = Promise.resolve(1);const fetch_2 = Promise.reject(2);const fetch_3 = Promise.resolve(3);const fetchs = [fetch_1, fetch_2, fetch_3];console.log(Promise.allSettled(fetchs)); Promise.finally()finally() 方法返回一个Promise。在promise结束时，无论结果是fulfilled或者是rejected，都会执行指定的回调函数。这为在Promise是否成功完成后都需要执行的代码提供了一种方式 12345678Promise.resolve(1) .then(res =&gt; console.log(res)) // 1 .catch(err =&gt; console.log(err)) .finally(() =&gt; console.log(\"finally\")); // finallyPromise.reject(2) .then(res =&gt; console.log(res)) .catch(err =&gt; console.log(err)) // 2 .finally(() =&gt; console.log(\"finally\")); //finally Promise ? async/await当一个网络请求需要依赖上一个请求的结果时： Promise Promise.js12345678910fetchData(topNewsUrl) .then(res =&gt; &#123; return res.data[0].id; &#125;) .then(itemID =&gt; &#123; return fetchData(newsDetailUtl + itemID); &#125;) .then(res =&gt; &#123; console.log(res); &#125;); async/await async/await.js12345async function asyncFetch() &#123; const news = await fetchData(topNewsUrl) const res = await fetchData(newsDetailUtl + news.data[0].id); console.log(res);&#125; 对比两者显然async/await 代码更简洁容易理解。 实现一个 Promise基础简易版myPromise.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869// Promise三种状态;const PENDING = \"pendding\"; //等待const FULFILLED = \"fulfilled\"; // 完成const REJECTED = \"rejected\"; //拒绝class myPromise &#123; constructor(executor) &#123; this.state = PENDING; //初始状态 this.value = null; // 完成结果 this.reason = null; // 拒绝原因 const resolve = value =&gt; &#123; if (this.state === PENDING) &#123; this.value = value; // 保存完成结果 this.state = FULFILLED; // 保存状态为完成 &#125; &#125;; const reject = value =&gt; &#123; if (this.state == PENDING) &#123; this.reason = value; // 保留拒绝原因 this.state = REJECTED; // 保存状态为拒绝 &#125; &#125;; /** * executor: Promise中首先传了一个executor，它是一个函数 * executor函数中又传了两个函数，分别是resolve和reject * @param resolve:成功回调 * @param reject:拒绝回调 */ executor(resolve, reject); &#125; /** * 根据成功或失败的状态去执行相关成功onFilfulled()或者失败onRejected()的回调方法 * @param &#123;*&#125; onFulfilled ：成功 * @param &#123;*&#125; onRejected ：拒绝 */ then(onFulfilled, onRejected) &#123; switch (this.state) &#123; case FULFILLED: //执行成功的回调函数onFilfulled，传入成功结果 this.value onFulfilled(this.value); break; case REJECTED: //执行成功的回调函数onRejected，传入拒绝结果 this.reason onRejected(this.reason); break; default: break; &#125; &#125; /** * * @param &#123;*&#125; onRejected ：拒绝 */ catch(onRejected) &#123; return this.then(null, onRejected); &#125;&#125;const p = new myPromise((resolve, reject) =&gt; &#123; resolve(1);&#125;);p.then(res =&gt; &#123; console.log(res); // 1&#125;); 很显然，测试结果反应代码没有问题，但是如果加个异步函数呢？ 异步处理myPromise.js12345678const p = new myPromise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(1); &#125;, 1000);&#125;);p.then(res =&gt; &#123; console.log(res); &#125;); 很显然，控制台不会输出什么，因为setTimeout是异步任务，会被加入到Task Queue 当调用then()时，myPromise.state 还是 PENDING，此时then()函数并不知道到底是执行onFulfilled()，还是onRejected()。 改造….myPromise.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697// Promise三种状态;const PENDING = \"pendding\"; //等待const FULFILLED = \"fulfilled\"; // 完成const REJECTED = \"rejected\"; //拒绝class myPromise &#123; constructor(executor) &#123; this.state = PENDING; //初始状态 this.value = null; // 完成结果 this.reason = null; // 拒绝原因 this.onFulfilledCallbacks = []; // 保存完成回调 this.onRejectedCallbacks = []; // 保存拒绝回调 const resolve = value =&gt; &#123; if (this.state === PENDING) &#123; this.value = value; // 保存完成结果 this.state = FULFILLED; // 保存状态为完成 // 状态变更后 立即执行之前存放在相应数组中所有完成的回调函数. this.onFulfilledCallbacks.map(cb =&gt; &#123; cb(); &#125;); &#125; &#125;; const reject = value =&gt; &#123; if (this.state == PENDING) &#123; this.reason = value; // 保留拒绝原因 this.state = REJECTED; // 保存状态为拒绝 // 状态变更后 立即执行之前存放在相应数组中所有拒绝的回调函数 this.onRejectedCallbacks.map(cb =&gt; &#123; cb(); &#125;); &#125; &#125;; try &#123; /** * executor: Promise中首先传了一个executor，它是一个函数 * executor函数中又传了两个函数，分别是resolve和reject * @param resolve:成功回调 * @param reject:拒绝回调 */ executor(resolve, reject); &#125; catch (err) &#123; // 如果出错，直接进入reject() reject(err); &#125; &#125; /** * 根据成功或失败的状态去执行相关成功onFilfulled()或者失败onRejected()的回调方法 * @param &#123;*&#125; onFulfilled ：成功 * @param &#123;*&#125; onRejected ：拒绝 */ then(onFulfilled, onRejected) &#123; switch (this.state) &#123; // 针对可能存在的异步调用，在PENDING状态时将完成、失败的回调函数push到对应的数组中，待状态改变时执行。 // 这种方式可以称为订阅 case PENDING: this.onFulfilledCallbacks.push(() =&gt; &#123; onFulfilled(this.value); &#125;); this.onRejectedCallbacks.push(() =&gt; &#123; onRejected(this.reason); &#125;); break; case FULFILLED: //执行成功的回调函数onFilfulled，传入成功结果 this.value onFulfilled(this.value); break; case REJECTED: //执行成功的回调函数onRejected，传入拒绝结果 this.reason onRejected(this.reason); break; default: break; &#125; &#125; /** * 捕获reject * @param &#123;*&#125; onRejected ：拒绝 */ catch(onRejected) &#123; return this.then(null, onRejected); &#125;&#125;const p = new myPromise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(1); &#125;, 1000);&#125;);p.then(res =&gt; &#123; console.log(res); // 1&#125;); then()链式调用 如果一个then方法返回一个普通值的话，这个值会传递给下一个then中作为resolve成功的结果如果一个then方法返回一个promise的话，会根据返回的promise是成功还是失败，决定下一个then是成功还是失败 myPromise.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118// Promise三种状态;const PENDING = \"pendding\"; //等待const FULFILLED = \"fulfilled\"; // 完成const REJECTED = \"rejected\"; //拒绝class myPromise &#123; constructor(executor) &#123; this.state = PENDING; //初始状态 this.value = null; // 完成结果 this.reason = null; // 拒绝原因 this.onFulfilledCallbacks = []; // 保存完成回调 this.onRejectedCallbacks = []; // 保存拒绝回调 const resolve = value =&gt; &#123; // 为了保证函数执行顺序，需要将两个函数体代码使用 setTimeout 包裹起来 setTimeout(() =&gt; &#123; if (this.state === PENDING) &#123; this.value = value; // 保存完成结果 this.state = FULFILLED; // 保存状态为完成 // 状态变更后 立即执行之前存放在相应数组中所有完成的回调函数. this.onFulfilledCallbacks.forEach(cb =&gt; &#123; cb(); &#125;); &#125; &#125;, 0); &#125;; const reject = value =&gt; &#123; //为了保证函数执行顺序，需要将两个函数体代码使用 setTimeout 包裹起来 setTimeout(() =&gt; &#123; if (this.state == PENDING) &#123; this.reason = value; // 保留拒绝原因 this.state = REJECTED; // 保存状态为拒绝 // 状态变更后 立即执行之前存放在相应数组中所有拒绝的回调函数 this.onRejectedCallbacks.forEach(cb =&gt; &#123; cb(); &#125;); &#125; &#125;, 0); &#125;; try &#123; /** * executor: Promise中首先传了一个executor，它是一个函数 * executor函数中又传了两个函数，分别是resolve和reject * @param resolve:成功回调 * @param reject:拒绝回调 */ executor(resolve, reject); &#125; catch (err) &#123; // 如果出错，直接进入reject() reject(err); &#125; &#125; /** * 根据成功或失败的状态去执行相关成功onFilfulled()或者失败onRejected()的回调方法 * @param &#123;*&#125; onFulfilled ：成功 * @param &#123;*&#125; onRejected ：拒绝 */ then(onFulfilled, onRejected) &#123; // return 一个 promise return new myPromise((resolve, reject) =&gt; &#123; switch (this.state) &#123; // 针对可能存在的异步调用，在PENDING状态时将完成、失败的回调函数push到对应的数组中，待状态改变时执行。 // 这种方式可以称为订阅 case PENDING: this.onFulfilledCallbacks.push(() =&gt; &#123; try &#123; const x = onFulfilled(this.value); resolve(x); &#125; catch (err) &#123; reject(err); &#125; &#125;); this.onRejectedCallbacks.push(() =&gt; &#123; try &#123; const x = onRejected(this.reason); resolve(x); &#125; catch (err) &#123; reject(err); &#125; &#125;); break; case FULFILLED: //执行成功的回调函数onFilfulled，传入成功结果 this.value try &#123; const x = onFulfilled(this.value); resolve(x); &#125; catch (err) &#123; reject(err); &#125; break; case REJECTED: //执行成功的回调函数onRejected，传入拒绝结果 this.reason try &#123; const x = onRejected(this.reason); resolve(x); &#125; catch (err) &#123; reject(err); &#125; break; default: break; &#125; &#125;); &#125; /** * 捕获reject * @param &#123;*&#125; onRejected ：拒绝 */ catch(onRejected) &#123; return this.then(null, onRejected); &#125;&#125; 测试myPromise.js123456789101112131415161718192021222324const p = new myPromise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(1); &#125;, 1000);&#125;);p.then(res =&gt; &#123; console.log(res); // 1 return \"2\"; &#125;) .then(res =&gt; &#123; console.log(res); // 2 return &#123; a: 3 &#125;; &#125;) .then(res =&gt; &#123; console.log(res); // &#123;a:3&#125; return undefined; &#125;) .then(res =&gt; &#123; console.log(res); // undefined &#125;) .then(res =&gt; &#123; console.log(res); // undefined &#125;); then中函数返回值的处理 非普通值情况。 这里还有类型判断、参数透传等问题处理，后续完成 Promise/A+规范 Promise/A+ 规范","link":"/2019/03/10/拾遗JavaScript——Promise/"},{"title":"Javascript——关于继承","text":"继承《JavaScript高级程序设计》看了忘，忘了记～ 原型链继承 每个对象都有一个隐式属性__proto__其指向该对象的构造函数的原型对象。prototype。 构造函数的原型对象prototype中包含一个constructor属性，其指向构造函数本身。 因此，可以通过重写原型对象，替换为父类的实例，从而拥有父类实例的全部属性及方法。这种方式即原型链继承 🌰123456789101112131415function Parent() &#123; this.name = \"Parent\"; this.numbers = [1, 2];&#125;Parent.prototype.getNumbers = function() &#123; console.log(this.numbers);&#125;;function Child() &#123;&#125;// 重写原型对象Child.prototype = new Parent();const child_1 = new Child();console.log(child_1.name); // Parentchild_1.getNumbers(); // [1, 2] 这种继承方式很明显的缺点是: 对于引用类型的属性，它会被所有实例共享。 无法向父类传递参数 123child_1.numbers.push(3);const child_2 = new Child();console.log(child_2.numbers); // [1, 2, 3] 借用构造函数🌰1234567891011121314function Parent(numbers) &#123; this.numbers = numbers;&#125;function Child(numbers) &#123; // 调用父类构造函数 Parent.call(this, numbers);&#125;const child_1 = new Child([3, 4]);console.log(child_1.numbers); //[3, 4]const child_2 = new Child([5]);console.log(child_2.numbers); // [5] 相较与原型式继承，借用构造函数的方式可以： 传递参数 引用类型属性不会被实例共享 但…. 12345678910// 父类原型属性中的方法，子类无法访问Parent.prototype.getNumbers = function() &#123; console.log(this.numbers);&#125;;const child_1 = new Child([3, 4]);child_1.getNumbers(); // TypeError: child_1.getNumbers is not a functionconst child_2 = new Child([5]);child_2.getNumbers(); // TypeError: child_1.getNumbers is not a function 很明显的缺点是: 父类的原型方法子类是无法访问到的，必须在构造函数中定义。因此，对于方法定义来说，每次创建实例都重新创建一遍方法。 组合继承（原型加借用构造函数的方式）🌰1234567891011121314151617181920212223242526272829303132function Parent(name) &#123; this.name = name; this.colors = [\"red\", \"blue\"];&#125;Parent.prototype.getColors = function() &#123; console.log(this.colors);&#125;;function Child(name, age) &#123; // 借用父类构造函数 Parent.call(this, name); this.age = age;&#125;// 重写原型对象（原型链继承）Child.prototype = new Parent();Child.prototype.constructor = Child;Child.prototype.getAge = function() &#123; console.log(this.age);&#125;;const child_1 = new Child(\"Ben\", 12);console.log(child_1.name); // Benchild_1.getAge(); // 12child_1.colors.push(\"gray\"); child_2.getColors(); // [\"red\",\"blue\",\"gray\"]const child_2 = new Child(\"Obi\", 20);console.log(child_2.name); // Obichild_2.getAge(); // 20child_2.getColors(); // [\"red\",\"blue\"] 组合继承很好的避开了原型链继承与借用构造函数继承的缺点，避免了引用类型属性共享又可以对方法进行复用。 但是…还有一个缺陷就是：在创建子类的实例时，会调用2次父类的的构造函数，从而子类的prototype上会有不必要多余的属性。 12345function Child(name, age) &#123; // 借用父类构造函数 Parent.call(this, name);&#125;Child.prototype = new Parent(); 原型继承 借助原型可以基于已有的的对象创建新对象，同时还不必因此创建自定义类型。—— 道格拉斯·克罗克福德 12345function object(obj) &#123; function F()&#123;&#125; F.prototype = o; retrun new F();&#125; 上面的方法object()，也是ES5中object.create()的模拟实现。 在object()函数内部，创建一个临时构造函数，将传入的对象作为这个构造函数的原型，然后返回这个临时类型的一个新的实例。 🌰12345678910111213var Parent = &#123; name: \"Parent\", colors: [\"red\", \"green\"]&#125;;const child_1 = object(Parent);child_1.name = \"child_1\";child_1.colors.push(\"blue\");console.log(child_1.name); // child_1const child_2 = object(Parent);child_2.name = \"child_2\";console.log(child_2.name); // child_2console.log(child_2.colors); //[\"red\", \"green\", \"blue\"] 这种方式与原型链继承一样，对于引用类型的属性会被所以实例共享。 寄生式继承寄生式继承依赖原型继承模式，类似与工厂模式，仅是在函数内部对对象进行增强，最后返回对象。 🌰1234567891011121314function factory(o) &#123; let clone = Object.create(o); clone.sayHi = function() &#123; console.log(\"Hi!\"); &#125;; return clone;&#125;var Parent = &#123; name: \"Parent\"&#125;;const child = factory(Parent);child.sayHi(); // Hi! 组合寄生式继承🌰1234567891011121314151617181920212223242526272829303132function Parent(name) &#123; this.name = name; this.colors = [\"red\", \"blue\"];&#125;Parent.prototype.getColors = function() &#123; console.log(this.colors);&#125;;function Child(name, age) &#123; // 借用父类构造函数 Parent.call(this, name); this.age = age;&#125;// 重写子类原型// 获得父类原型的副本Child.prototype = Object.create(Parent.prototype);Child.prototype.constructor = Child; // 上一行代码重写了子类的原型，因此要重新指定子类的构造函数Child.prototype.getAge = function() &#123; console.log(this.age);&#125;;const child_1 = new Child(\"Ben\", 12);console.log(child_1.name); // Benchild_1.getAge(); // 12child_1.colors.push(\"gray\");const child_2 = new Child(\"Obi\", 20);console.log(child_2.name); // Obichild_2.getAge(); // 20child_2.getColors(); // [\"red\", \"blue\"] 组合式继承有一个缺点就是会调用父类构造函数2次，寄生组合式继承避免了这一点，同时保持原型链不变，能正常instanceof、isPrototypeOf。因此是最理想的继承方式。 对比 组合继承 可以看到在子类的原型prototype上，多了colors,name属性 寄生组合继承 colors、name，是父类的实例属性，在重写子类原型属性prototype时（Child.prototype = new Parent()），子类的原型属性便获得了父类属性的副本colors,name。 const child = new Child()：调用子类Child()构造函数时又一次调用父类的构造函数(Parent.call(this, name))。子类实例child_1因此获得父类的实例属性colors,name，同时也屏蔽了子类原型属性prototype中的colors,name。 两次调用父类构造函数导致了子类Child()的原型属性prototype和子类实例child_1中都获得了父类的实例属性colors,name。 寄生组合式继承的基本思路就是：通过借用构造函数来继承属性，通过原型链来继承方法。 总结Javascript主要通过原型链实现继承。 原型链的构建是通过将一个类型的实例赋予另一个构造函数的原型属性prototype而实现的。通过这样的方式，子类就能访问父类的所有属性及方法。原型链的方式存在一个缺点就是所有实例共享所有属性及方法。因此需要借用构造函数的方式——在子类的构造函数中调用父类的构造函数，这样子类实例都会有单独的属性和方法。 原型链继承：通过重写子类原型的方式获得父类属性及方法及指向父类构造函数的指针。 缺点 引用类型所有实例共享。 无法传递参数。 构造函数继承：通过子类的构造函数中调用父类构造函数从而获父类属性。 优点 每个子类实例都有一份父类属性的拷贝，解决引用类型属性共享的问题。 缺点 子类实例无法访问父类prototype中定义的方法，因此方法必须定义在构造函数中，每次创建实例都要重新创建一次方法。 组合继承（经典继承）： 优点 避开了原型链继承及构造函数继承的缺点。 缺点 两次调用父类的构造函数。 原型式继承：无需定义构造函数的情况下实现继承。其本质是对目标对象的浅复制，从而得到对象的副本。 缺点 与原型链式继承一样，所有实例共享引用类型属性。 寄生式继承：类似与工厂模式，结合原型式继承的方式，对目标对象进行浅复制获得新对象，并对新对象进行增强加工，最后返回这个新对象 缺点 每次创建实例就是一次对象增强加工，因此都会创建一遍对象的方法。 寄生组合式继承: 结合寄生继承及组合式继承的优点，是继承最有效的方式。","link":"/2019/08/13/Javascript——关于继承/"},{"title":"拾遗JavaScript——call、apply、bind","text":"call()call() 方法使用一个指定的 this 值和单独给出的一个或多个参数来调用一个函数。(MDN) https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call 🌰基本用法123456789101112var a = 2;function foo() &#123; console.log(this.a);&#125;const bar = &#123; a: 1&#125;;var a = 2;// 隐式调用，this指向windowfoo(); // 2 // 改变this指向barfoo.call(bar); // 2 构造函数式继承在一个子构造函数中，通过调用父构造函数的 call 方法来实现继承。 123456789101112function Product(name, price) &#123; this.name = name; this.price = price;&#125;function Food(name, price) &#123; // 在Food的构造函数中调用父类Product的构造函数 // this指向Food Product.call(this, name, price); this.categroy = \"food\";&#125;// 对象实例拥有在 Product 构造函数中添加的 name 属性和 price 属性。const cheese = new Food(\"cheese\", 10); 如何模拟实现call()语法：fun.call(thisArg, arg1, arg2, ...) 1234567891011function foo() &#123; console.log(this.a);&#125;const bar = &#123; a: 1, foo: function() &#123; console.log(this.a); &#125;&#125;;bar.foo(); // 1foo.call(bar); // 1 假设当调用foo.call(bar)时，其实是在bar上添加一个foo属性，这样foo函数中的this便指向了bar。 bar.fn = foo; bar.fn(); delete bar.fn Step 11234567891011121314Function.prototype.customizeCall = function(context) &#123; context.fn = this; // 获取调用customizeCall的函数，添加到临时属性fn context.fn(); // 执行函数 delete context.fn; // 删除fn属性&#125;;function foo() &#123; console.log(this.a);&#125;const bar = &#123; a: 1&#125;;foo.customizeCall(bar); // 1 Step 2fun.call() 除了传入运行时指定的绑定this的目标，还需要传入参数列表args 12345678910111213141516171819202122232425262728293031Function.prototype.customizeCall = function(context) &#123; // 获取调用customizeCall方法的函数，添加到临时属性fn context.fn = this; // 获取传入的参数 // 函数参数数组arguments是一个类数组，可以for循环 let args = []; // 保存参数 for (let i = 1; i &lt; arguments.length; i++) &#123; // 拼接参数为字符串push进args，后续需要用到eval() // args[\"arguments[1]\", \"arguments[2]\", ...] args.push(\"arguments[\" + i + \"]\"); &#125; // eval() 函数会将传入的字符串当做 JavaScript 代码进行执行。 // context.fn(arguments[1], ...); console.log(args); eval(\"context.fn(\" + args + \")\"); // context.fn(); delete context.fn;&#125;;function foo(name, age) &#123; console.log(this.a); console.log(name); console.log(age);&#125;const bar = &#123; a: 1&#125;;foo.customizeCall(bar, \"Ken\", 12); // 1, ken, 12 Step 3 call 方法可以不指定第一个参数的（this）的。 没有传递第一个参数，this 的值将会被绑定为全局对象。 严格模式下指向undefined。 call 方法是可以有返回值的。 123456789101112131415161718192021222324252627282930313233343536Function.prototype.customizeCall = function(context) &#123; //不传入this的情况下默认指向window // Object(context)：确保传入的是对象 context = Object(context) || window; // 获取调用customizeCall方法的函数，添加到临时属性fn context.fn = this; // 获取传入的参数 // 函数参数数组arguments是一个类数组，可以for循环 let args = []; // 保存参数 for (let i = 1; i &lt; arguments.length; i++) &#123; // 拼接参数为字符串 // args[\"arguments[1]\", \"arguments[2]\", ...] args.push(\"arguments[\" + i + \"]\"); &#125; // eval() 函数会将传入的字符串当做 JavaScript 代码进行执行。 // context.fn(arguments[1], ...); console.log(args); const result = eval(\"context.fn(\" + args + \")\"); // context.fn(); delete context.fn; return result;&#125;;function foo(name, age) &#123; return &#123; a: this.a, name: name, age: age &#125;;&#125;const bar = &#123; a: 1&#125;;console.log(foo.customizeCall(bar, \"Ken\", 12)); // &#123;a:1, name:ken, age:12&#125; 使用ES6语法实现 1234567891011Function.prototype.customizeCall = function(context, …args) &#123; //不传入this的情况下默认指向window // Object(context)：确保传入的是对象 context = Object(context) || window;; // 获取调用customizeCall方法的函数，添加到临时属性fn context.fn = this; // …扩展语法获取传入的参数，并添加到执行的函数里 const result = context.fn(…args); delete context.fn; return result;&#125;; apply()apply() 方法调用一个具有给定this值的函数，以及作为一个数组（或类似数组对象）提供的参数。 与call()方法类似，区别就是call()方法接受的是参数列表，而apply()方法接受的是一个参数数组。MDN:https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply 模拟实现1234567891011121314151617181920212223242526272829303132333435363738394041Function.prototype.customizeApply = function(context, arr) &#123; //不传入this的情况下默认指向window // Object(context)：确保传入的是对象 context = Object(context) || window; // 获取调用customizeCall方法的函数，添加到临时属性fn context.fn = this; let result = null; // 如果没有传入参数列表，则直接执行 if (!arr) &#123; result = context.fn(); &#125; else &#123; // 获取传入的参数 // for循环函数参数数组arr // 保存参数 let args = []; for (let i = 0; i &lt; arr.length; i++) &#123; // 拼接参数为字符串 // args[\"arr[1]\", \"arr[2]\", ...] args.push(\"arr[\" + i + \"]\"); &#125; // eval() 函数会将传入的字符串当做 JavaScript 代码进行执行。 // context.fn(arguments[1], ...); result = eval(\"context.fn(\" + args + \")\"); &#125; // context.fn(); delete context.fn; return result;&#125;;function foo(name, age) &#123; return &#123; a: this.a, name: name, age: age &#125;;&#125;const bar = &#123; a: 1&#125;;console.log(foo.customizeApply(bar, [\"Ken\", 12])); // &#123;a:1, name:ken, 12&#125; 使用ES6扩展语法实现 123456789101112131415Function.prototype.customizeApply = function(context, arr) &#123; //不传入this的情况下默认指向window // Object(context)：确保传入的是对象 context = Object(context) || window; // 获取调用customizeCall方法的函数，添加到临时属性fn context.fn = this; let result = null; if (!arr) &#123; result = context.fn(); &#125; else &#123; result = context.fn(…arr); &#125; delete context.fn; return result;&#125;; bind()bind()方法创建一个新的函数，在bind()被调用时，这个新函数的this被bind的第一个参数指定，其余的参数将作为新函数的参数供调用时使用。 bind() 最简单的用法是创建一个函数，不论怎么调用，这个函数都有同样的 this 值。 可以传参 返回一个函数 MDN:https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind 模拟实现123456789101112131415161718192021222324252627282930313233Function.prototype.customizeBind = function(toThis) &#123; //bind 的不是函数时抛出错误 if (typeof this !== \"function\") &#123; throw new Error( \"Function.prototype.bind - what is trying to be bound is not callable\" ); &#125; // 获取传入的参数 var args = Array.prototype.slice(arguments, 1), self = this, fNOP = function() &#123;&#125;, fBound = function() &#123; return self.apply( // this instanceof fBound === true时,说明返回的fBound被当做new的构造函数调用,将绑定函数的 this 指向该实例，可以让实例获得来自绑定函数的值; // this instanceof fBound === false时，说明fBound被当做普通函数调用，this 指向 window，将绑定函数的 this 指向 toThis; this instanceof fBound ? this : toThis, // 获取调用时(fBound)的传参 args.concat(Array.prototype.slice.call(arguments)) ); &#125;; // 维护原型关系 // 返回的函数 if (this.prototype) &#123; //返回函数的 prototype 为绑定函数的 prototype， fNOP.prototype = this.prototype; &#125; // 实例就可以继承绑定函数的原型中的值（__proto__指向fNOP的实例） fBound.prototype = new fNOP(); // 返回函数 // 返回一个原函数的拷贝，并拥有指定的this值和初始参数 return fBound;&#125;; 模拟实现参考mqyqingfeng:https://github.com/mqyqingfeng/Blog/issues/11","link":"/2019/06/10/拾遗JavaScript——call、apply、bind/"},{"title":"拾遗JavaScript——Event Loop","text":"Event Loop 一、基础知识1、进程与线程 进程：应用程序的执行实例，每一个进程都是由私有的虚拟地址空间、代码、数据个其他系统资源组成。 线程：线程是进程内的一个独立执行单元，在不同的线程之间可以进行资源共享。 进程拥有独立的堆栈空间和数据段，每当启动一个新的进程必须分配给它独立的地址空间，建立众多的数据表来维护它的代码段、堆栈段和数据段。 线程拥有独立的堆栈空间，但是共享数据段，它们彼此之间使用相同的地址空间，共享大部分数据，比进程更加节俭，开销比较小，切换速度快，效率高。 一句话总结: 进程：资源分配的最小单位 线程：程序执行的最小单位 Javascript是一门单线程语言Why??众所周知，多线程操作可以实现应用的并行处理，充分利用CPU资源提高性能和吞吐量。现在很多语言都支持多核并行处理技术。 但Javascript….😂 Javascript 是一门脚本语言，最初设计用于运行在浏览器环境，试想一下如果有2个同步线程在跑，一个在执行DOM的插入，另一个删除DOM，浏览器会？？？？ So…这意味着它可以一次处理一个任务或一次处理一段代码。它有一个调用堆栈，它与堆之类的其他部分一起构成了Javascript并发模型（在V8内部实现）。 Call StackCall Stack：它是一个记录函数调用的数据结构，当我们调用函数时，函数会被推入这个堆栈，但函数返回时按先入后出的规则依次推出。 123456789101112function multiply(a, b) &#123; return a * b;&#125;function square(n) &#123; return multiply(n, n);&#125;function printSquare(n) &#123; var squared = square(n); console.log(squared);&#125;printSquare(4); 通过断点调试可以很清楚的看到调用堆栈 当函数执行完返回时，依次从栈顶推出。 Heapheap：变量所有的内存分配都在在堆中进行。 QueueJavascript单线程任务被分为同步任务和异步任务，同步任务会在调用栈中按照顺序等待主线程依次执行，异步任务会在异步任务有了结果后，将注册的回调函数放入任务队列中等待主线程空闲的时候（调用栈被清空），被读取到栈内等待主线程的执行。 1234567891011console.log(\"1\");setTimeout(() =&gt; &#123; console.log(\"2\");&#125;, 3 * 1000);console.log(\"3\");// 1// 3// 2 如图所示：执行栈先处理同步任务console.log(&#39;1&#39;)，执行完后推出栈，控制台输出1,setTimeout()进入执行栈但不会执行，而是由Web API 处理完毕后，加入任务队列等待执行栈的同步任务执行完，同步任务console.log(&#39;3&#39;)进入执行栈，执行完毕后推出栈，当执行栈为null时，任务队列中的任务推入执行栈执行。 整个过程是循环不断的，这样的运行机制称为Event Loop Event Loop 侵删 补充宏任务/微任务宏任务（Task）： 整体代码script setTimeout setInterval setImmediate requestAnimationFrame I/O UI rendering 微任务(Microtask)： Promise（Promise中的then、catch才是宏任务，本身内部代码并不是） process.nextTick（nodejs环境中） MutationObserver： 提供了监视对DOM树所做更改的能力（https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver） 12345678910111213141516setTimeout(() =&gt; console.log('setTimeout1'), 0);setTimeout(() =&gt; &#123; console.log('setTimeout2'); Promise.resolve().then(() =&gt; &#123; console.log('promise2'); Promise.resolve().then(() =&gt; &#123; console.log('promise3'); &#125;) console.log(5) &#125;) setTimeout(() =&gt; console.log('setTimeout4'), 0);&#125;, 0);setTimeout(() =&gt; console.log('setTimeout3'), 0);Promise.resolve().then(() =&gt; &#123; console.log('promise1');&#125;) 逐步分析代码执行过程:1、Run Script2、开始轮询： setTimeout1、setTimeout2、setTimeout3 被推入Task Queue，promise1被推入Microtasks Queue。此时Task Queue中：[setTimeout1,setTimeout2,setTimeout3]，Microtasks Queue中：[promise1]。3、微任务优于宏任务之前执行，所以先执行Microtasks Queue中的队列promise1，控制台输出：promise1。随后依次执行setTimeout1、setTimeout2、setTimeout3，4、执行：setTimeout1： 输出setTimeout1；执行setTimeout2: 输出setTimeout2，发现一个微任务promise2,将它加入到Microtasks Queue，发现一个宏任务setTimeout4，将它加入Task；执行setTimeout3：输出 setTimeout3;5、此时Microtasks Queue中有[promise2]，执行promise2,输出promise2，这里又有个微任务promise3,将promise3加入Microtasks Queue，执行console.log(5),输出5。6、此时Microtasks Queue不为null，还有任务promise3,执行输出promise3。7、Microtasks Queue为null，检查Task Queue，发现还有一个宏任务 setTimeout4，执行并输出setTimeout4。 因此代码执行的结果为： 12345678promise1setTimeout1setTimeout2setTimeout3promise25promise3setTimeout4 微任务比宏任务优先执行，当微任务队列不为null时，继续处理微任务队列，等到全部处理完毕，则检查宏任务队列并处理队列的任务。 async/awaitasync/await 与 promise 一样同属于微任务。（async函数返回的是一个promise） 123456789101112131415161718192021async function async1() &#123; console.log(\"async1 start\"); await async2(); console.log(\"async1 end\");&#125;async function async2() &#123; console.log(\"async2\");&#125;console.log(\"script start\");setTimeout(function() &#123; console.log(\"setTimeout\");&#125;, 0);async1();new Promise(function(resolve) &#123; console.log(\"promise1\"); resolve();&#125;).then(function() &#123; console.log(\"promise2\");&#125;);console.log(\"script end\"); 以上代码执行过程：1、async1()、async2（）函数定义。2、同步任务，控制台输出：script start。3、setTimeout,加入宏任务队列。4、执行函数async1()。 a：同步任务，控制台输出async1 start。 b：await async2() ，此时线程被阻塞，无法执行当前函数下面的代码。 5、async2()：同步任务，控制台输出async2，6、由于async1()中，await阻塞里线程，无法回到async1()，因此继续执行async1()外面的代码。7、Promise，控制台输出promise1，将then()=&gt;{console.log(&quot;promise2&quot;)}回调加入微任务队列。8、同步任务,控制台输出script end，此时代码执行完。9、await阻塞线程结束。 a:回到函数async1()，async2()返回一个promise.resolve(undefined).then(undefined)，将then(undefined)加入微任务队列。 b:处理微任务队列then()=&gt;{console.log(&quot;promise2&quot;)}、then(undefined)，控制台输出promise2。 c:执行console.log(&quot;async1 end&quot;)，控制台输出async1 end。 10、处理宏任务队列，控制台输出setTimeout。 所以控制台输出：12345678script startasync1 startasync2promise1script endpromise2async1 endsetTimeout async/await本质上还是基于Promise的一些封装。执行async函数内遇到await fn()时，会阻塞线程跳出async函数，然后再次回到await fn()处，如果fn()返回的是Promise对象还要再次跳出async1()函数体外继续执行以外的代码。 补充在最新的Chrome（76.0.3809.87）中测试以上代码得到结果为： 12345678script startasync1 startasync2promise1script endasync1 endpromise2setTimeout","link":"/2019/04/09/拾遗JavaScript——Event-Loop/"},{"title":"从输入URL到页面加载的过程的知识梳理","text":"知识梳理 浏览器接受URL到开启网络请求 发起一个完整的http请求 服务器接收到请求到后台处理 后台与前端的http交互 浏览器接受到http数据包后的解析过程 补充 JS引擎解析过程 http缓存 跨域、web安全等。 浏览器接受URL到开启网络请求浏览器知识浏览器是多进程的，比如Chrome，存在的进程包括主进程、GPU、浏览器内核等。 浏览器内核浏览器内核简单来说就是渲染引擎，通过获取得页面内容、整理信息（CSS）、计算和组合出最终输出可视化内容。 在Chrome中，每打开一个标签页相当于开启了一个进程，每个Tab进程都有独立的渲染引擎实例互不干扰。 多线程的内核浏览器内核由以下常驻线程组成 GUI渲染线程：负责渲染浏览器界面HTML元素,当界面需要重绘(Repaint)或由于某种操作引发回流(reflow)时,该线程就会执行。 JavaScript引擎线程：负责解析Javascript脚本，运行代码。 定时触发器线程：浏览器定时计数器并不是由JavaScript引擎计数的, 因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确, 因此通过单独线程来计时并触发定时 事件触发器线程：当一个事件被触发时该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理。这些事件可以是当前执行的代码块如定时任务、也可来自浏览器内核的其他线程如鼠标点击、AJAX异步请求等，但由于JS的单线程关系所有这些事件都得排队等待JS引擎处理。 异步http请求线程：在XMLHttpRequest在连接后是通过浏览器新开一个线程请求， 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件放到 JavaScript引擎的处理队列中等待处理。 URL解析当在地址栏输入URL时，第一件事情就是对URL进行解析。 URL的组成： protocol：协议头（Http、ftp） host：域名或IP地址 port：端口号（默认80） path：目录路径 query：请求参数 fragment：#后的hash值，用来定位到某个位置 发起一个完整的http请求URL解析完毕后获域名，需要对域名进行DNS查询。解析成IP DNS查询 如果浏览器有缓存，则是用浏览器缓存，否则使用系统本地缓存， 如果本机上也没有，则向DNS域名服务器查询（这个过程可能经过路由器，如果路由器中有缓存，则使用路由器缓存）。 DNS服务器查询本地域名服务器上都维护一份高速缓存，存放最近使用过的域名及对应的IP地址。如果在此没有找到，则发起递归查询。 TCP/IP 请求http本质上是TCP/IP请求。 经过DNS查询找到IP地址，根据IP地址向目标服务器发起请求，建立TCP/IP链接。 三次握手 基本过程： 客户端：Hi～，你是Server吗？ 客户端将SYN段发送到服务器。SYN代表同步，这意味着客户端请求服务器与客户端将使用的序列号同步（每个新事务生成新的序列号）。 服务器：Hi！，我是Server，你是Client吗？ 收到请求后，服务器会响应类似的消息。首先，它通过确认客户端发送的序列号来确认（ACK）请求。其次，它还请求客户端序列号的同步（SYN）。 客户端：Yeah！我是Client。 最后一步来自客户端，它确认（ACK）服务器发送的序列号。传输已准备好开始。 四次挥手 A：向B发送一个FIN报文（表示没什么东西发送了，但是可以接收）要关闭连接了，这时A进入FIN_WAIT_1状态。 B：接收到A发送的FIN报文，然后向A发送一个ACK报文（表明已收到请求，但还没准备要关闭连接），进入ClOSE_WAIT状态。这时A收到确认包进入FIN_WAIT_2状态。 B：向A发送FIN报文（关闭连接请求）进入LAST_ACK（等待客户端确认的ACK包）。 A：收到B发送的FIN报文（关闭请求），向B发送ACK包，进入TIME_WAIT（等待B回应）。B收到确认包并关闭连接，这时A等待超时，关闭连接。 长连接、短连接 TCP/IP 长连接：一个tcp/ip连接上可以连续发送多个数据包，在tcp连接保持期间，如果没有数据包发送，需要双方发检测包以维持此连接，一般需要自己做在线维持（类似于心跳包） 短连接：通信双方有数据交互时，就建立一个tcp连接，数据发送完成后，则断开此tcp连接 http层面 http1.0中，默认使用的是短连接，也就是说，浏览器没进行一次http操作，就建立一次连接，任务结束就中断连接，譬如每一个静态资源请求时都是一个单独的连接 http1.1起，默认使用长连接，使用长连接会有这一行Connection: keep-alive，在长连接的情况下，当一个网页打开完成后，客户端和服务端之间用于传输http的tcp连接不会关闭，如果客户端再次访问这个服务器的页面，会继续使用这一条已经建立的连接 keep-alive不会永远保持，它有一个持续时间，一般在服务器中配置（如apache），另外长连接需要客户端和服务器都支持时才有效 *拾遗因特网协议栈（五层） 应用层 传输层 网络层 数据链路层 物理层 从应用层发起http请求，到传输层经过三次握手建立TCP/IP连接，接着到网络层的IP寻址，再到数据链路层封装成帧，最后物理层利用物理链路传输。 OSI开放系统互连参考模型 (Open System Interconnect 简称OSI）。 物理层 数据链路层 网络层 传输层 会话层 表示层 应用层 会话层：管理不同用户和进程之间的对话 表示层：主要处理两个通信端的信息交换方式，如数据加密与解密、数据格式交换。 建立TCP/IP连接后开始准备传输数据：HTTP报文 报文结构通用头部Method GET：请求一个指定资源的表示形式. 使用GET的请求应该只被用于获取数据. HEAD：请求一个与GET请求的响应相同的响应，但没有响应体. POST：用于将实体提交到指定的资源，通常导致在服务器上的状态变化或副作用. PUT：用请求有效载荷替换目标资源的所有当前表示。 DELETE：删除指定的资源。 CONNECT建立一个到由目标资源标识的服务器的隧道。 OPTIONS：用于描述目标资源的通信选项。 TRACE：沿着到目标资源的路径执行一个消息环回测试。 PATCH：用于对资源应用部分修改。 状态码（Status Code） 1xx——指示信息，表示请求已接收，继续处理 2xx——成功，表示请求已被成功接收、理解、接受 3xx——重定向，要完成请求必须进行更进一步的操作 4xx——客户端错误，请求有语法错误或请求无法实现 5xx——服务器端错误，服务器未能实现合法的请求 常用状态码： 200——表明该请求被成功地完成，所请求的资源发送回客户端304——自从上次请求后，请求的网页未修改过，请客户端使用本地缓存400——客户端请求有错（譬如可以是安全模块拦截）401——请求未经授权403——禁止访问（譬如可以是未登录时禁止）404——资源未找到500——服务器内部错误503——服务不可用 响应头 Access-Control-Allow-Headers: 服务器端允许的请求HeadersAccess-Control-Allow-Methods: 服务器端允许的请求方法Access-Control-Allow-Origin: 服务器端允许的请求Origin头部（譬如为*）Content-Type：服务端返回的实体内容的类型Date：数据从服务器发送的时间Cache-Control：告诉浏览器或其他客户，什么环境可以安全的缓存文档Last-Modified：请求资源的最后修改时间Expires：应该在什么时候认为文档已经过期,从而不再缓存它Max-age：客户端的本地资源应该缓存多少秒，开启了Cache-Control后有效ETag：请求变量的实体标签的当前值Set-Cookie：设置和页面关联的cookie，服务器通过这个头部把cookie传给客户端Keep-Alive：如果客户端有keep-alive，服务端也会有响应（如timeout=38）Server：服务器的一些相关信息 请求头 Accept: 接收类型，表示浏览器支持的MIME类型（对标服务端返回的Content-Type）Accept-Encoding：浏览器支持的压缩类型,如gzip等,超出类型不能接收Content-Type：客户端发送出去实体内容的类型Cache-Control: 指定请求和响应遵循的缓存机制，如no-cacheIf-Modified-Since：对应服务端的Last-Modified，用来匹配看文件是否变动，只能精确到1s之内，http1.0中Expires：缓存控制，在这个时间内不会请求，直接使用缓存，http1.0，而且是服务端时间Max-age：代表资源在本地缓存多少秒，有效时间内不会请求，而是使用缓存，http1.1中If-None-Match：对应服务端的ETag，用来匹配文件内容是否改变（非常精确），http1.1中Cookie: 有cookie并且同域访问时会自动带上Connection: 当浏览器与服务器通信时对于长连接如何进行处理,如keep-aliveHost：请求的服务器URLOrigin：最初的请求是从哪里发起的（只会精确到端口）,Origin比Referer更尊重隐私Referer：该页面的来源URL(适用于所有类型的请求，会精确到详细页面地址，csrf拦截常用到这个字段)User-Agent：用户客户端的一些必要信息，如UA头部等 服务器接收请求的处理负载均衡用户发起的请求都指向调度服务器（反向代理服务器nginx控制负载均衡），然后调度服务器根据实际的调度算法，分配不同的请求给对应集群中的服务器执行，然后调度器等待实际服务器的HTTP响应，并将它反馈给用户。 后台处理，返回数据##nginx、node(express/jwt)、mongoDB 一般过程： 统一的验证，如安全拦截，跨域验证，如不符合规则，就直接返回了相应的http报文。 验证通过后，进入实际的后台代码，此时是程序接收到请求，然后执行（譬如查询数据库，大量计算等等）。 执行完毕后，就会返回一个http响应包（一般这一步也会经过多层封装）然后就是将这个包从后端发送到前端，完成交互。 断开连接（TCP/IP 四次挥手）解析页面浏览器解析页面是边解析边渲染的过程。 基本过程 解析HTML，构建DOM树。 解析CSS，生成CSS规则树。 合并DOM、CSS规则树生成render树。 布局render树（Reflow），负责计算各个元素的尺寸，位置。 绘制render树（Repaint），绘制页面像素位置。（根据渲染树以及回流得到的几何信息，得到节点的绝对像素） 浏览器将给层的信息发送给GPU，GPU将各层合成（composite），显示在屏幕上。 构建DOM树 Bytes → characters → tokens → nodes → DOM 因为我们是以字节数据进行数据传输的，首先将字节数据转化为字符串，然后浏览器将字符串进行词法分析转为标记（token），接着转化为node，这些node会根据不同node之间的联系构建成DOM树。 🌰1234567891011&lt;html&gt; &lt;head&gt; &lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1\"&gt; &lt;link href=\"style.css\" rel=\"stylesheet\"&gt; &lt;title&gt;Asensiki&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;Hello&lt;span&gt;web&lt;/span&gt;&lt;/p&gt; &lt;div&gt;&lt;img src=\"awesome.jpg\"&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 处理过程： 在解析HTML的过程中会遇到CSS、Javascript文件，这时候浏览器会下载这些文件。 构建CSSOM树 Bytes → characters → tokens → nodes → CSSOM 🌰 style.css1234567891011121314151617body &#123; font-size: 16px&#125;p &#123; font-weight: bold; span &#123; color: red; display: none &#125;&#125;div &#123; weight: 300px&#125;img &#123; float: right&#125; 生成的CSSOM树如下： 合成render树当DOM树和CSSOM构建完毕后，开始合成渲染树。 渲染树只会包括需要显示的节点和这些节点的样式信息，如果某个节点是 display: none 的，那么就不会在渲染树中显示。 渲染合成render tree 后开始渲染。 基本步骤： 计算CSS样式。 构建渲染树。 布局，定位坐标、大小、z-index 等。（这里也叫回流） 绘制。 * 阻塞渲染渲染的过程需要先解析HTML，生成DOM Tree、CSSOM Tree并合成Render Tree 后才会进行。 所以说解析HTML、CSS时会阻塞渲染。 CSS阻塞 CSS下载时异步，不会阻塞浏览器构建DOM树 但是会阻塞渲染，也就是在构建render时，会等到css下载解析完毕后才进行（这点与浏览器优化有关，防止css规则不断改变，避免了重复的构建） 有例外，media query声明的CSS是不会阻塞渲染的 JS阻塞当 HTML 解析器遇到一个 script 标记时，它会暂停构建 DOM，将控制权移交给 JavaScript 引擎；等 JavaScript 引擎运行完毕，浏览器会从中断的地方恢复 DOM 构建。也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的原因。 但不一定都要放在底部。也可以给script标签加上defer 或者 async 属性。 Defer： html解析完成后才根据顺序执行下载。 Async：异步下载，谁先下载完先执行谁，这样也会阻塞，所以根据情况使用。 * 重绘（Reflow）、回流（Repaint） Reflow：元素的内容、结构、位置或尺寸发生了变化，需要重新计算样式和渲染树。 Repaint：元素发生的改变只是影响了元素的一些外观之类的时候（例如，背景色，边框颜色，文字颜色等），此时只需要应用新样式绘制这个元素就可以了。 在页面显示的过程中会多次进行Reflow和Repaint操作，而Reflow的成本比Repaint的成本高得多的多。因为Repaint只是将某个部分进行重新绘制而不用改变页面的布局，如：改变了某个元素的背景颜色。而如果将元素的display属性由block改为none则需要Reflow。 回流还要进行重绘。 引起回流的操作 页面首次渲染 浏览器窗口大小发生改变 元素尺寸或位置发生改变 元素内容变化（文字数量或图片大小等等） 元素字体大小变化 添加或者删除可见的DOM元素 激活CSS伪类（例如：:hover） 查询某些属性或调用某些方法 拾遗HTTPS https与http的区别就是： 在请求前，会建立ssl连接，确保接下来的通信都是加密的，无法被轻易截取分析。 开启https需要后端服务器支持（申请证书）。 https开销比http要大，因为要额外建立安全链接和加密。 加密 对称加密：两边拥有相同的秘钥，两边都知道如何将密文加密解密 非对称加密：服务端将公钥公布，客户端创建一个秘钥，然后通过服务端的公钥加密并发送给服务端，服务端接收到密文以后通过自己的私钥解密出正确的客户端秘钥，这时候两端就都知道秘钥是什么了。 SSL/TLS握手流程 客户端发送一个随机值（Client-Radom）以及需要的协议和加密方式。 服务端收到客户端发送的随机值，回复一个随机值（Server-Random），选出确定的加密算法，并将自己的身份信息以证书的方式发送。 客户端收到服务器发来的证书。 验证证书的合法性。 产生一个新的随机值，通过证书中的公钥以及指定的算法加密后发送给服务器。 利用三个随机值通过算法生成Http连接数据传输的对称加密key（session-key）。 使用约定好的HASH算法计算握手消息，并使用生成的session key对消息进行加密，最后将之前生成的所有信息发送给服务端。 服务器收到客户端回复 利用指定的加解密方式与自己的私钥进行解密，获得第三个随机值。 生成session-key。 使用session-key解密握手信息，验证hash值。 使用session key加密一段握手消息，发送给客户端 客户端解密并验证握手信息的hash，一致则握手结束。 之后所有的https通信数据将由之前浏览器生成的session key并利用对称加密算法进行加密 *浏览器安全 CSRF：跨站点请求伪造，通过伪造后台地址，诱导或者某些方式自动发送请求。 防御 使用Token验证。 cookie限制 阻止第三方站点请求（验证referrer） XSS：代码注入，跨站点脚本攻击。 攻击类型 存储型：通过用户提交表单等方式向后台DB注入恶意代码。 DOM：包含恶意代码的URL诱导用户点击。 反射型：拼接包含恶意代码的URL，通过用户点击传递。 防御 HTML转译。 CSP（content-security-policy）：建立白名单 禁止外域提交、加载代码。 禁止内联脚本运行。 用户提交需要验证码。 HTTP-Only-Cookie 前端渲染，代码数据分离。 跨域浏览器为了安全策略使用同源政策，协议、域名或者端口有一个不同就是跨域。 解决方式JSONP利用 &lt;script&gt; 标签没有跨域限制的漏洞。通过 &lt;script&gt; 标签指向一个需要访问的地址并提供一个回调函数来接收数据当需要通讯时。 12345678910111213141516171819202122&lt;script src=\"http://domain/api?param1=a&amp;param2=b&amp;callback=jsonp\"&gt;&lt;/script&gt;&lt;script&gt; function jsonp(data) &#123; console.log(data)&#125;// 封装function jsonp(url, jsonpCallback, success) &#123; let script = document.createElement('script') script.src = url script.async = true script.type = 'text/javascript' window[jsonpCallback] = function(data) &#123; success &amp;&amp; success(data) &#125; document.body.appendChild(script)&#125;jsonp('http://xxx', 'callback', function(value) &#123; console.log(value)&#125;)&lt;/script&gt; JSOPN 只能用于GET请求 CORSCROS 需要后端和浏览器同时支持。（万恶之源IE系列）。 后端则需要设置Access-Control-Allow-Origin：*。（值可以自己限制那些域名，*表示所有）。 虽然设置 CORS 和前端没什么关系，但是通过这种方式解决跨域问题的话，会在发送请求时出现两种情况，分别为简单请求和复杂请求。 简单请求： 请求类型 GET POST HEAD Content-Type text/plain multipart/form-data application/x-www-form-urlencoded 复杂请求 不符合以上条件的请求就肯定是复杂请求了。 复杂请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求,该请求是 option 方法的，通过该请求来知道服务端是否允许跨域请求。 Node.js (express) 123456789app.use((req, res, next) =&gt; &#123; res.header('Access-Control-Allow-Origin', '*') res.header('Access-Control-Allow-Methods', 'PUT, GET, POST, DELETE, OPTIONS') res.header( 'Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept, Authorization, Access-Control-Allow-Credentials' ) next()&#125;) Nginx反向代理document.domain该方式只能用于二级域名相同的情况下，比如 a.test.com 和 b.test.com 适用于该方式。只需要给页面添加 document.domain = &#39;test.com&#39; 表示二级域名都相同就可以实现跨域 postMessage这种方式通常用于获取嵌入页面中的第三方页面数据。一个页面发送消息，另一个页面判断来源并接收消息。 跨域cookie处理 设置withCredentials为true即可让该跨域请求携带 Cookie。 注意携带的是目标页面所在域的 Cookie。 服务器同时设置Access-Control-Allow-Credentials响应头为&quot;true&quot;， 即可允许跨域请求携带 Cookie。 Access-Control-Allow-Origin不允许使用通配符。 浏览器缓存机制缓存位置 Service Worker Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的。 当 Service Worker 没有命中缓存的时候，我们需要去调用 fetch 函数获取数据。也就是说，如果我们没有在 Service Worker 命中缓存的话，会根据缓存查找优先级去查找数据。但是不管我们是从 Memory Cache 中还是从网络请求中获取的数据，浏览器都会显示我们是从 Service Worker 中获取的内容。 Memory Cache Memory Cache 也就是内存中的缓存，读取内存中的数据肯定比磁盘快。但是内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。 一旦我们关闭 Tab 页面，内存中的缓存也就被释放 Disk Cache Disk Cache 也就是存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之 Memory Cache 胜在容量和存储时效性上。 在所有浏览器缓存中，Disk Cache 覆盖面基本是最大的。它会根据 HTTP Herder 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。 Push Cache Push Cache 是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用。并且缓存时间也很短暂，只在会话（Session）中存在，一旦会话结束就被释放。 网络请求 缓存策略浏览器缓存策略分为两种：强缓存和协商缓存，并且缓存策略都是通过设置 HTTP Header 来实现。 强缓存强缓存（200 from cache）时，浏览器如果判断本地缓存未过期，就直接使用，无需发起http请求。 通过设置HTTP Header实现：Expires、Cache-Control。 Cache-Control的优先级比Expires高。 一般使用Cache-control: max-age=XXX 协商缓存如果缓存过期，则需要发起请求验证是否需要更新资源，协商缓存可以通过设置HTTP Header的LastModified、Etag实现。 当发起请求验证资源时，如果资源不需要更新，则服务器会返回304状态码，并且更新缓存有效期。 Last-Modified：表示本地文件最后修改日期，If-Modified-Since 会将 Last-Modified 的值发送给服务器，询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来，否则返回 304 状态码。 Etag：是一种指纹机制，代表文件相关指纹只有文件变才会变，也只要文件变就会变，也没有精确时间的限制，只要文件一改变，立马E-tag就不一样了。 实际应用 对于频繁变动的资源，首先需要使用 Cache-Control: no-cache 使浏览器每次都请求服务器，然后配合 ETag 或者 Last-Modified 来验证资源是否有效。这样的做法虽然不能节省请求数量，但是能显著减少响应数据大小。 Javascript引擎解析过程 1","link":"/2019/08/20/从输入URL到页面加载的过程的知识梳理/"}],"tags":[],"categories":[{"name":"Web","slug":"Web","link":"/categories/Web/"},{"name":"Javascript","slug":"Web/Javascript","link":"/categories/Web/Javascript/"},{"name":"Webpack","slug":"Web/Webpack","link":"/categories/Web/Webpack/"},{"name":"Project","slug":"Project","link":"/categories/Project/"}]}