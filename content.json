{"pages":[{"title":"categories","text":"","link":"/categories/index.html"}],"posts":[{"title":"Hola","text":"心情不好～写点什么…","link":"/2019/03/01/Hola/"},{"title":"拾遗——JavaScript-Promise","text":"","link":"/2019/03/10/拾遗——JavaScript-Promise/"},{"title":"拾遗——JavaScript-async/await","text":"async/await async/await 同 Promise、callback 一样是一种编写异步代码的方法。 async/await 实际上是建立在promises之上的，其返回的是一个promise。 async/await 是非阻塞的。 async/await 更像是同步代码，如果多个异步代码没有依赖性却使用了 await 会导致性能上的降低。 描述当调用一个 async 函数时，会返回一个 Promise 对象。当这个 async 函数返回一个值时，Promise 的 resolve 方法会负责传递这个值；当 async 函数抛出异常时，Promise 的 reject 方法也会传递这个异常值。 async 函数中可能会有 await 表达式，这会使 async 函数暂停执行，等待 Promise 的结果出来，然后恢复async函数的执行并返回解析值（resolved）。 注意， await 关键字仅仅在 async function中有效。如果在 async function函数体外使用 await ，你只会得到一个语法错误（SyntaxError）。 https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/async_function 🌰假设一个函数getJsonData() 来获取Json数据。 promise 123456const request = (url)=&gt;&#123; getJsonData(url).then(response =&gt; &#123; console.log(response.data) &#125;)&#125; async/await 1234const request = async (url) =&gt; &#123; console.log(await getJsonData(url));&#125; 看这样看起来，async/await 是不是简洁了很多？ 毕竟写一堆 then 也是很烦的。 错误处理 (try/catch)12 async/await hell async/await 把我们从曾经的callback hell 中解放，而现在，我们陷入了async/await hell。","link":"/2019/03/12/拾遗——JavaScript-async-await/"},{"title":"拾遗——JavaScript-var/let/const","text":"变量的声明方式var声明局部变量和全局变量。 let声明一个块级作用域的局部变量。 const声明一个块级作用域的只读常量(需要初始值)。 变量提升123console.log(a);var a = 1; // undefined 实际上上部分的代码可以理解为:123var a;console.log(a); a = 1; 这就是变量提升。 对于函数来说，只有函数声明会被提升到顶部，而函数表达式不会被提升。 12345baz(); // baz is not a functionvar baz = function() &#123;console.log(\"bar2\"); &#125;; 暂时性死区let（const）将不会提升变量到代码块的顶部。因此，在变量声明之前引用这个变量，将抛出引用错误（ReferenceError）。这个变量将从代码块一开始的时候就处在一个“暂时性死区”，直到这个变量被声明为止。 123console.log(a);let a = 1; //a is not defined","link":"/2019/04/27/拾遗——JavaScript-var-let-const/"},{"title":"拾遗——JavaScript 深、浅拷贝","text":"数据类型JavaScript中变量的数据类型分两种： 基本类型 （存储与栈内存中，值存储） 引用类型 （存储堆内存中，通过指针去寻找所指向的内存空间） 对于值类型的复制操作是直接堆变量的值进行拷贝；对于引用类型的复制操作是对存储变量的指针进行拷贝，指向同一内存空间，修改其中一个会影响另一方。 深浅拷贝只针对于Array、Object 这样复杂的对象 浅拷贝只拷贝基本类型的数据，对于引用的类型数据，复制后也是会发生引用，这种拷贝就叫做浅拷贝 🌰： 对于对象来说，可以通过Object.assign()、...来实现浅拷贝1、Object.assign()1234567let obj = &#123; name: \"ken\"&#125;let newObj = Object.assign(&#123;&#125;, obj);obj.name = \"obi\";console.log(obj.name); // name:obiconsole.log(newObj.name); // name: ken 2、...展开运算符123456789let obj = &#123; name: \"ken\"&#125;let newObj = &#123; ...obj&#125;;obj.name = \"obi\";console.log(obj.name); // name:obiconsole.log(newObj.name); // name: ken 🌰：对于数组，可以通过concat()、slice() 来实现浅拷贝1、concat()concat() 方法用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。concat方法不会改变this或任何作为参数提供的数组，而是返回一个浅拷贝，它包含与原始数组相结合的相同元素的副本。 原始数组的元素将复制到新数组中。 https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/concat 12345let arr = [1, 2, 3];let newArr = arr.concat();arr.push(4);console.log(arr); //[1,2,3,4]console.log(newArr); //[1,2,3] 2、slice()slice() 方法返回一个新的数组对象，这一对象是一个由 begin和 end（不包括end）决定的原数组的浅拷贝。原始数组不会被改变。 https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/slice 12345let arr = [1, 2, 3];let newArr = arr.slice();arr.push(4);console.log(arr); //[1,2,3,4]console.log(newArr); //[1,2,3] 当面对复杂一点的对象或者数组，使用 Object.assign(),Array.slice() 会怎么样？例如:1234567891011121314let obj = &#123; a: 1, b: 2, c: &#123; d: 1, e: 2 &#125;&#125;let newObj = Object.assign(&#123;&#125;, obj);obj.a = 2;newObj.c.d = 2;console.log(obj); // &#123;a:2,b:2,c:&#123;d:2,e:2&#125;&#125;console.log(newObj); // &#123;a:1,b:2,c:&#123;d:2,e:2&#125;&#125; 12345678let arr = [1, 2, [1, 2], 3];let newArr = arr.concat();arr.push(4);arr[2].push(3);console.log(arr); //[1,2,[1,2,3],3,4]console.log(newArr); //[1,2,[1,2,3],3] 代码里修改了obj.a的值，并没对newObj造成影响，而修改了newObj.c.d的值，obj.c.d的值也随着改变。这是因为Object.assign()是浅拷贝，只拷贝了一层，对于obj.c是一个对象，所以newObj.c存储的是指向obj.c所指向的指针地址。同理...展开运算符、Array.concat()/Array.slice() 深拷贝解决上述问题最常见的实现方式就是：JSON.parse(JSON.stringify(object)) 123456789101112131415let obj = &#123; a: 1, b: 2, c: &#123; d: 1, e: 2 &#125;&#125;let newObj = JSON.parse(JSON.stringify(obj));obj.a = 2;newObj.c.d = 2;console.log(obj); //&#123;a:2,b:2,c:&#123;d:1,e:2&#125;&#125;console.log(newObj); //&#123;a:1,b:2,c:&#123;d:2,e:2&#125;&#125; 当然，对象的序列化反序列化JSON.parse(JSON.stringify())并不是万能的。 忽略 undefined 忽略 symbol 不能序列化函数 不能解决循环引用的对象 https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify 1234567891011121314151617181920212223242526let obj = &#123; a: () =&gt; &#123; console.log('copy'); &#125;, b: undefined, c: Symbol, d: 'obi'&#125;let newObj = JSON.parse(JSON.stringify(obj))console.log(newObj); // &#123;d:obi&#125; 忽略undefined、symbol、不能序列化化函数let obj = &#123; a: 1, b: &#123; c: 2 &#125;&#125;obj.c = obj.b; // `obj.c` 引用 `obj.b`obj.b.c = obj.c; // `obj.b.c` 又引用 `obj.c`let newObj = JSON.parse(JSON.stringify(obj));console.log(newObj); // 直接报错 实现简易的浅拷贝、深拷贝浅拷贝123456789101112131415161718192021const fn = (data, target = &#123;&#125;) =&gt; &#123; for (let item in data) &#123; if (data.hasOwnProperty(item)) &#123; target[item] = data[item] &#125; &#125; return target&#125;let obj = &#123; a: 1, b: 2&#125;let newObj = fn(obj);obj.a = 2;console.log(obj); //&#123;a:2,b:2&#125;console.log(newObj); //&#123;a:1,b:2&#125; 浅拷贝就是一个for..in循环,Object.prototype.hasOwnProperty的作用是检测目标是否属于自有属性,是则复制 深拷贝123456789101112131415161718192021222324252627282930const isObj = (o) =&gt; &#123; return ((typeof o === 'object') || (typeof o === 'function') &amp;&amp; o !== null)&#125;const deepClone = (obj) =&gt; &#123; if (!isObj(obj)) &#123; throw new Error('not a Object！') &#125; let newObj = Array.isArray(obj) ? [] : &#123;&#125; // 判断是否是数组或者是对象,设置初始值为空值 Object.keys(obj).forEach(key =&gt; &#123; newObj[key] = isObj(obj[key]) ? deepClone(obj[key]) : obj[key]; &#125;) return newObj;&#125;let obj = &#123; a: [1, 2, 3], b: &#123; c: 2, d: 3 &#125;&#125;let newObj = deepClone(obj)newObj.b.c = 1console.log(obj.b.c) // 2console.log(newObj.b.c) // 1 这只是简单的深拷贝，未考虑其他情况，其余另做探究。 参考来自Google、MDN","link":"/2019/03/05/拾遗——JavaScript-深、浅拷贝/"},{"title":"拾遗——webpack4（一）入门","text":"webpack4 初体验webpack 是一个现代 JavaScript 应用程序的静态模块打包工具。当 webpack 处理应用程序时，它会在内部构建一个 依赖图(dependency graph)，此依赖图会映射项目所需的每个模块，并生成一个或多个 bundle。 从4.0版本开始，webpack 抛弃以前版本的那种繁琐、晦涩令初学者怯步的配置文件，开始零配置靠拢； 这无疑对于初学者来说，亲和力上了一层楼。 但它仍然具有可配置性满足多种需求。 在开始之前先了解核心概念 入口（entry） 输出（output） loader 插件（plugin） 模式（mode） 浏览器兼容性（bowser compatibility） 项目搭建创建空文件夹webpack_demo，运行以下命令生成package.json1npm init 或者 npm init -y Tip-y 参数表示所有package.json 参为默认 引入 webpack 1npm install webpack --save-dev 这里还需要使用webpack-cli脚手架 1npm install webpack-cli --save-dev 查看package.json文件可以看到目前使用的版本12345\"devDependencies\": &#123; \"webpack\": \"^4.30.0\", \"webpack-cli\": \"^3.3.0\" &#125; 接下来在packege.json 中增加npm scripts 12345\"scripts\": &#123; \"build\": \"webpack\", \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" &#125; 到这里基本的项目搭建完毕，运行 npm run build 命令看看效果。 从图片里的报错信息可以得知：“未能找到入口文件” 回到文章开始讲的：webpack中的核心概念：入口(entry) 入口(entry)入口起点(entry point)指示 webpack 应该使用哪个模块，来作为构建其内部 依赖图(dependency graph) 的开始。进入入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的。 https://webpack.docschina.org/concepts/#%E5%85%A5%E5%8F%A3-entry- webpack的入口默认是 .src/index.js ,但我们可以通过webpack.config.js 中去配置指定具体的入口起点。 webpack.config.js12345module.exports = &#123; entry: &#123; app: \"./app.js\" &#125;&#125; 现在新建一个src目录并添加入口文件 index.js 运行npm run build,可以看到控制台输出打包成功 并在目录下创建了dist文件夹和里面已经打包压缩好的文件main.js 这里讲一个webpack的一个核心概念：输出（output） 输出(output)output 属性告诉 webpack 在哪里输出它所创建的 bundle，以及如何命名这些文件。主要输出文件的默认值是 ./dist/main.js，其他生成文件默认放置在 ./dist 文件夹中。 https://webpack.docschina.org/concepts/#%E5%85%A5%E5%8F%A3-entry- 同样我们也可以在webpack.config.js 中去自定义输出点(output) webpack.config.js1234567module.exports = &#123; output: &#123; publicPath: __dirname + '/dist/', // js 引用的路径或者CDN地址 path: path.resolve(__dirname, 'dist'), // 打包文件的输出目录 filename: 'bundle.js' // 打包后生产的js文件 &#125;&#125; 模式(mode)前面运行npm run build 的过程中，虽然打包成功，但是控制台还输出几行警告信息: “没有设置mode option” 这里就要讲到webpack中的一个核心点：mode， production development 我们可以在npm scripts 中告诉webpack-cli 以什么样的mode去构建例如:1234567&#123;\"scripts\": &#123; \"dev\": \"webpack --mode development\", \"build\": \"webpack --mode production\", \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" &#125;&#125; 或者在webpack.config.js中设置123module.exports = &#123; mode: \"production\"&#125; 如果不设置的话，默认mode为production 现在我们来看看两中模式下的简单区别 执行 npm run dev 执行 npm run build 通过对比，在dev模式下，js文件没有被压缩 一个完整的Web项目除了js脚本文件，应该还包含有CSS、HTML以及其他资源，如图片、字体等;那么在webpack中如何去处理这些资源呢？首先从处理CSS开始 loaderwebpack 只能理解 JavaScript 和 JSON 文件。loader 让 webpack 能够去处理其他类型的文件，并将它们转换为有效 模块，以供应用程序使用，以及被添加到依赖图中。 https://webpack.docschina.org/concepts/#loader 1、添加style.css2、处理css需要安装以下loader配合使用，执行npm i --save-dev style-loader css-loader css-loader：解析CSS代码，处理CSS中的依赖（@import、url()等） style-loader：将css-loader解析结果转变为js并动态插入style标签 123456\"devDependencies\": &#123; \"css-loader\": \"^2.1.1\", \"style-loader\": \"^0.23.1\", \"webpack\": \"^4.30.0\", \"webpack-cli\": \"^3.3.0\" &#125; 3、配置webpack.config.js 1234567891011module.exports = &#123; module: &#123; rules: [&#123; test: /\\.css$/, use: [ 'style-loader', 'css-loader' ] &#125;] &#125;&#125; 4、style.css 123.hola &#123; color: blue&#125; 5、在index.js中 引入style.css 1import './style.css'; 6、执行npm run build 7、在index.html中引入打包好的文件bundle.js 8、在浏览器中打开index.html,在控制台可以看到css样式已经通过&lt;style&gt; 标签注入 处理sass、less，可以使用less-loader\\sass-loader 插件（plugin）在html文件中引入打包好后的js文件，如果更改了打包后的文件名称或者代码分割成多个文件，又要去一个个引入，甚是麻烦，这个时候就要使用html-webpack-plugin，打包完之后自动生成 HTML 文件，并自动引入打包后的 js 文件。 1、执行npm i html-webpack-plugin html-loader --save-dev2、配置webpack.config.js 3、执行npm run build4、在dist文件夹下打开index.html 要部署到服务器前，这里要把webpack的output改为相对路径publicPath:&#39;./&#39;","link":"/2019/03/02/拾遗——webpack4（一）入门/"},{"title":"拾遗——webpack4（三）处理图片","text":"","link":"/2019/03/05/拾遗——webpack4（三）处理图片/"},{"title":"拾遗——webpack4（二）Babel","text":"BabelBabel 是什么？主要用于将 ECMAScript 2015+ 版本的代码转换为向后兼容的 JavaScript 语法，以便能够运行在当前和旧版本的浏览器或其他环境中。 1、执行以下命令安装所需要的package 12npm install --save-dev babel-loader @babel/core @babel/preset-envnpm install --save @babel/polyfill babel-loader : 这是Webpack的Babel插件，它将被添加到Webpack配置中，以指示它在捆绑过程中通过Babel运行目标文件； @babel/core @babel/preset-env：通过根据目标浏览器或运行时环境自动确定所需的Babel插件和polyfill，将代码编译为ES5 @babel/polyfill：垫片，转化ES6内置语法（Array.from,Object.assign等） 1234567891011\"devDependencies\": &#123; \"@babel/core\": \"^7.4.3\", \"@babel/preset-env\": \"^7.4.3\", \"babel-loader\": \"^8.0.5\", \"clean-webpack-plugin\": \"^2.0.1\", \"webpack\": \"^4.30.0\", \"webpack-cli\": \"^3.3.0\" &#125;, \"dependencies\": &#123; \"@babel/polyfill\": \"^7.4.3\" &#125; 2、新建babel配置文件.babelrc 来配置babel 123&#123; \"presets\": [\"@babel/preset-env\"]&#125; 3、在webpack.config.js中配置babel-loader 1234567module: &#123; rules: [&#123; test: /\\.js$/, //匹配js文件 exclude: /node_modules/, //忽略目标文件夹 loader: \"babel-loader\" // 使用babel-loader &#125;] &#125; 4、验证 在index.js中使用ES6语法 12345// import '@babel/polyfill'const arr = ['1', '2', '3'];const fn = () =&gt; console.log(...arr);fn(); 这里还需要import &#39;@babel/polyfill&#39; 全局引入打包后体积大、根据需要转译的文件按需引用又很麻烦，这里只需要配置一下babelrc，babel自动转译 .babelrc 123456789101112&#123; \"presets\": [ [ \"@babel/preset-env\", &#123; \"useBuiltIns\": \"usage\", \"corejs\": \"3\" //使用core-js@3版本 &#125; ] ]&#125; 这里遇到一个小坑，配置完.babelrc后执行npm run build，控制台首先会提示一段警告: 大概意思就是指定用什么版本的core-js,默认使用core-js@2版本 然后报错 这里配置一下core-js的版本 执行npm run build 浏览器中打开dist文件夹下的index.html，查看控制台输出。 Chrome最新版是支持ES6语法的，最好的还是在IE下测试。","link":"/2019/03/04/拾遗——webpack4（二）Babel/"}],"tags":[],"categories":[{"name":"Web","slug":"Web","link":"/categories/Web/"},{"name":"Javascript","slug":"Web/Javascript","link":"/categories/Web/Javascript/"},{"name":"Webpack","slug":"Web/Webpack","link":"/categories/Web/Webpack/"}]}