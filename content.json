{"pages":[{"title":"categories","text":"","link":"/categories/index.html"}],"posts":[{"title":"Hola","text":"心情不好～写点什么…","link":"/2019/03/01/Hola/"},{"title":"拾遗JavaScript——async-await","text":"async/await async/await 同 Promise、callback 一样是一种编写异步代码的方法。 async/await 实际上是建立在 promises 之上的，其返回的是一个 promise。 async/await 是非阻塞的。 async/await 更像是同步代码，如果多个异步代码没有依赖性却使用了 await 会导致性能上的降低。 描述当调用一个 async 函数时，会返回一个 Promise 对象。当这个 async 函数返回一个值时，Promise 的 resolve 方法会负责传递这个值；当 async 函数抛出异常时，Promise 的 reject 方法也会传递这个异常值。 async 函数中可能会有 await 表达式，这会使 async 函数暂停执行，等待 Promise 的结果出来，然后恢复 async 函数的执行并返回解析值（resolved）。 注意， await 关键字仅仅在 async function中有效。如果在 async function函数体外使用 await ，你只会得到一个语法错误（SyntaxError）。 https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/async_function 🌰假设一个函数getJsonData() 来获取 Json 数据。 promise 12345const request = url =&gt; &#123; getJsonData(url).then(response =&gt; &#123; console.log(response.data); &#125;);&#125;; async/await 123const request = async url =&gt; &#123; console.log(await getJsonData(url));&#125;; 看这样看起来，async/await 是不是简洁了很多？ 毕竟写一堆 then 也是很烦的。 错误处理 (try/catch)1code snippet async/await hellasync/await 把我们从曾经的callback hell 中解放，而现在，我们陷入了async/await hell。","link":"/2019/03/12/拾遗JavaScript——async-await/"},{"title":"拾遗JavaScript——var-let-const","text":"变量的声明方式var声明局部变量和全局变量。 let声明一个块级作用域的局部变量。 const声明一个块级作用域的只读常量(需要初始值)。 变量提升12console.log(a);var a = 1; // undefined 实际上上部分的代码可以理解为: 123var a;console.log(a);a = 1; 这就是变量提升。 对于函数来说，只有函数声明会被提升到顶部，而函数表达式不会被提升。 12345baz(); // baz is not a functionvar baz = function() &#123; console.log(\"bar2\");&#125;; 暂时性死区let（const）将不会提升变量到代码块的顶部。因此，在变量声明之前引用这个变量，将抛出引用错误（ReferenceError）。这个变量将从代码块一开始的时候就处在一个“暂时性死区”，直到这个变量被声明为止。 12console.log(a);let a = 1; //a is not defined","link":"/2019/03/27/拾遗JavaScript——var-let-const/"},{"title":"拾遗JavaScript——深、浅拷贝","text":"数据类型JavaScript 中变量的数据类型分两种： 基本类型 （存储与栈内存中，值存储） 引用类型 （存储堆内存中，通过指针去寻找所指向的内存空间） 对于值类型的复制操作是直接堆变量的值进行拷贝；对于引用类型的复制操作是对存储变量的指针进行拷贝，指向同一内存空间，修改其中一个会影响另一方。 深浅拷贝只针对于 Array、Object 这样复杂的对象 浅拷贝只拷贝基本类型的数据，对于引用的类型数据，复制后也是会发生引用，这种拷贝就叫做浅拷贝 🌰： 对于对象来说，可以通过Object.assign()、...来实现浅拷贝1、Object.assign()1234567let obj = &#123; name: \"ken\"&#125;;let newObj = Object.assign(&#123;&#125;, obj);obj.name = \"obi\";console.log(obj.name); // name:obiconsole.log(newObj.name); // name: ken 2、...展开运算符123456789let obj = &#123; name: \"ken\"&#125;;let newObj = &#123; ...obj&#125;;obj.name = \"obi\";console.log(obj.name); // name:obiconsole.log(newObj.name); // name: ken 🌰：对于数组，可以通过concat()、slice() 来实现浅拷贝1、concat()concat() 方法用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。concat 方法不会改变 this 或任何作为参数提供的数组，而是返回一个浅拷贝，它包含与原始数组相结合的相同元素的副本。 原始数组的元素将复制到新数组中。 https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/concat 12345let arr = [1, 2, 3];let newArr = arr.concat();arr.push(4);console.log(arr); //[1,2,3,4]console.log(newArr); //[1,2,3] 2、slice()slice() 方法返回一个新的数组对象，这一对象是一个由 begin 和 end（不包括 end）决定的原数组的浅拷贝。原始数组不会被改变。 https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/slice 12345let arr = [1, 2, 3];let newArr = arr.slice();arr.push(4);console.log(arr); //[1,2,3,4]console.log(newArr); //[1,2,3] 当面对复杂一点的对象或者数组，使用 Object.assign(),Array.slice() 会怎么样？例如:1234567891011121314let obj = &#123; a: 1, b: 2, c: &#123; d: 1, e: 2 &#125;&#125;;let newObj = Object.assign(&#123;&#125;, obj);obj.a = 2;newObj.c.d = 2;console.log(obj); // &#123;a:2,b:2,c:&#123;d:2,e:2&#125;&#125;console.log(newObj); // &#123;a:1,b:2,c:&#123;d:2,e:2&#125;&#125; 12345678let arr = [1, 2, [1, 2], 3];let newArr = arr.concat();arr.push(4);arr[2].push(3);console.log(arr); //[1,2,[1,2,3],3,4]console.log(newArr); //[1,2,[1,2,3],3] 代码里修改了obj.a的值，并没对newObj造成影响，而修改了newObj.c.d的值，obj.c.d的值也随着改变。这是因为Object.assign()是浅拷贝，只拷贝了一层，对于obj.c是一个对象，所以newObj.c存储的是指向obj.c所指向的指针地址。同理...展开运算符、Array.concat()/Array.slice() 深拷贝解决上述问题最常见的实现方式就是：JSON.parse(JSON.stringify(object)) 123456789101112131415let obj = &#123; a: 1, b: 2, c: &#123; d: 1, e: 2 &#125;&#125;;let newObj = JSON.parse(JSON.stringify(obj));obj.a = 2;newObj.c.d = 2;console.log(obj); //&#123;a:2,b:2,c:&#123;d:1,e:2&#125;&#125;console.log(newObj); //&#123;a:1,b:2,c:&#123;d:2,e:2&#125;&#125; 当然，对象的序列化反序列化JSON.parse(JSON.stringify())并不是万能的。 忽略 undefined 忽略 symbol 不能序列化函数 不能解决循环引用的对象 https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify 12345678910111213141516171819202122232425let obj = &#123; a: () =&gt; &#123; console.log(\"copy\"); &#125;, b: undefined, c: Symbol, d: \"obi\"&#125;;let newObj = JSON.parse(JSON.stringify(obj));console.log(newObj); // &#123;d:obi&#125; 忽略undefined、symbol、不能序列化化函数let obj = &#123; a: 1, b: &#123; c: 2 &#125;&#125;;obj.c = obj.b; // `obj.c` 引用 `obj.b`obj.b.c = obj.c; // `obj.b.c` 又引用 `obj.c`let newObj = JSON.parse(JSON.stringify(obj));console.log(newObj); // 直接报错 实现简易的浅拷贝、深拷贝浅拷贝1234567891011121314151617181920const fn = (data, target = &#123;&#125;) =&gt; &#123; for (let item in data) &#123; if (data.hasOwnProperty(item)) &#123; target[item] = data[item]; &#125; &#125; return target;&#125;;let obj = &#123; a: 1, b: 2&#125;;let newObj = fn(obj);obj.a = 2;console.log(obj); //&#123;a:2,b:2&#125;console.log(newObj); //&#123;a:1,b:2&#125; 浅拷贝就是一个for..in循环,Object.prototype.hasOwnProperty的作用是检测目标是否属于自有属性,是则复制 深拷贝123456789101112131415161718192021222324252627282930const isObj = o =&gt; &#123; return typeof o === \"object\" || (typeof o === \"function\" &amp;&amp; o !== null);&#125;;const deepClone = obj =&gt; &#123; if (!isObj(obj)) &#123; throw new Error(\"not a Object！\"); &#125; let newObj = Array.isArray(obj) ? [] : &#123;&#125;; // 判断是否是数组或者是对象,设置初始值为空值 Object.keys(obj).forEach(key =&gt; &#123; newObj[key] = isObj(obj[key]) ? deepClone(obj[key]) : obj[key]; &#125;); return newObj;&#125;;let obj = &#123; a: [1, 2, 3], b: &#123; c: 2, d: 3 &#125;&#125;;let newObj = deepClone(obj);newObj.b.c = 1;console.log(obj.b.c); // 2console.log(newObj.b.c); // 1 这只是简单的深拷贝，未考虑其他情况，其余另做探究。 参考来自 Google、MDN","link":"/2019/03/05/拾遗JavaScript——深、浅拷贝/"},{"title":"拾遗webpack4（一）——入门","text":"webpack4 初体验webpack 是一个现代 JavaScript 应用程序的静态模块打包工具。当 webpack 处理应用程序时，它会在内部构建一个 依赖图(dependency graph)，此依赖图会映射项目所需的每个模块，并生成一个或多个 bundle。 从 4.0 版本开始，webpack 抛弃以前版本的那种繁琐、晦涩令初学者怯步的配置文件，开始零配置靠拢； 这无疑对于初学者来说，亲和力上了一层楼。 但它仍然具有可配置性满足多种需求。 在开始之前先了解核心概念 入口（entry） 输出（output） loader 插件（plugin） 模式（mode） 浏览器兼容性（bowser compatibility） 项目搭建创建空文件夹 webpack_demo，运行以下命令生成 package.json 1npm init 或者 npm init -y Tip-y 参数表示所有 package.json 参为默认 引入 webpack 1npm install webpack --save-dev 这里还需要使用 webpack-cli 脚手架 1npm install webpack-cli --save-dev 查看 package.json 文件可以看到目前使用的版本 12345\"devDependencies\": &#123; \"webpack\": \"^4.30.0\", \"webpack-cli\": \"^3.3.0\" &#125; 接下来在 packege.json 中增加 npm scripts 12345\"scripts\": &#123; \"build\": \"webpack\", \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" &#125; 到这里基本的项目搭建完毕，运行 npm run build 命令看看效果。 从图片里的报错信息可以得知：“未能找到入口文件” 回到文章开始讲的：webpack 中的核心概念：入口(entry) 入口(entry)入口起点(entry point)指示 webpack 应该使用哪个模块，来作为构建其内部 依赖图(dependency graph) 的开始。进入入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的。 https://webpack.docschina.org/concepts/#%E5%85%A5%E5%8F%A3-entry- webpack 的入口默认是 .src/index.js ,但我们可以通过 webpack.config.js 中去配置指定具体的入口起点。 webpack.config.js 12345module.exports = &#123; entry: &#123; app: \"./app.js\" &#125;&#125;; 现在新建一个src目录并添加入口文件 index.js 运行npm run build,可以看到控制台输出打包成功 并在目录下创建了dist文件夹和里面已经打包压缩好的文件main.js 这里讲一个 webpack 的一个核心概念：输出（output） 输出(output)output 属性告诉 webpack 在哪里输出它所创建的 bundle，以及如何命名这些文件。主要输出文件的默认值是 ./dist/main.js，其他生成文件默认放置在 ./dist 文件夹中。 https://webpack.docschina.org/concepts/#%E5%85%A5%E5%8F%A3-entry- 同样我们也可以在webpack.config.js 中去自定义输出点(output) webpack.config.js 1234567module.exports = &#123; output: &#123; publicPath: __dirname + \"/dist/\", // js 引用的路径或者CDN地址 path: path.resolve(__dirname, \"dist\"), // 打包文件的输出目录 filename: \"bundle.js\" // 打包后生产的js文件 &#125;&#125;; 模式(mode)前面运行npm run build 的过程中，虽然打包成功，但是控制台还输出几行警告信息: “没有设置 mode option” 这里就要讲到 webpack 中的一个核心点：mode， production development 我们可以在npm scripts 中告诉webpack-cli 以什么样的 mode 去构建例如: 1234567&#123; \"scripts\": &#123; \"dev\": \"webpack --mode development\", \"build\": \"webpack --mode production\", \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" &#125;&#125; 或者在webpack.config.js中设置 123module.exports = &#123; mode: \"production\"&#125;; 如果不设置的话，默认mode为production 现在我们来看看两中模式下的简单区别 执行 npm run dev 执行 npm run build 通过对比，在 dev 模式下，js 文件没有被压缩 一个完整的 Web 项目除了 js 脚本文件，应该还包含有 CSS、HTML 以及其他资源，如图片、字体等;那么在 webpack 中如何去处理这些资源呢？首先从处理 CSS 开始 loaderwebpack 只能理解 JavaScript 和 JSON 文件。loader 让 webpack 能够去处理其他类型的文件，并将它们转换为有效 模块，以供应用程序使用，以及被添加到依赖图中。 https://webpack.docschina.org/concepts/#loader 1、添加style.css2、处理 css 需要安装以下 loader 配合使用，执行npm i --save-dev style-loader css-loader css-loader：解析 CSS 代码，处理 CSS 中的依赖（@import、url()等） style-loader：将css-loader解析结果转变为 js 并动态插入 style 标签 123456\"devDependencies\": &#123; \"css-loader\": \"^2.1.1\", \"style-loader\": \"^0.23.1\", \"webpack\": \"^4.30.0\", \"webpack-cli\": \"^3.3.0\" &#125; 3、配置webpack.config.js 12345678910module.exports = &#123; module: &#123; rules: [ &#123; test: /\\.css$/, use: [\"style-loader\", \"css-loader\"] &#125; ] &#125;&#125;; 4、style.css 123.hola &#123; color: blue;&#125; 5、在index.js中 引入style.css 1import \"./style.css\"; 6、执行npm run build 7、在index.html中引入打包好的文件bundle.js 8、在浏览器中打开 index.html,在控制台可以看到 css 样式已经通过&lt;style&gt; 标签注入 处理sass、less，可以使用less-loader\\sass-loader 插件（plugin）在 html 文件中引入打包好后的 js 文件，如果更改了打包后的文件名称或者代码分割成多个文件，又要去一个个引入，甚是麻烦，这个时候就要使用html-webpack-plugin，打包完之后自动生成 HTML 文件，并自动引入打包后的 js 文件。 1、执行npm i html-webpack-plugin html-loader --save-dev2、配置webpack.config.js3、执行npm run build4、在dist文件夹下打开index.html 要部署到服务器前，这里要把webpack的output改为相对路径publicPath:&#39;./&#39;","link":"/2019/03/02/拾遗webpack4（一）——入门/"},{"title":"拾遗webpack4（三）——处理图片","text":"","link":"/2019/03/05/拾遗webpack4（三）——处理图片/"},{"title":"拾遗JavaScript——this","text":"thisthis 到底是什么？如何确定 this 的指向性？ this 是让人困惑的东西～ this 在每个函数的作用域中被自动创建，当函数被调用时，一个执行上下文(execution context) 被创建 执行上下文 中包含一下信息 函数在哪调用（call-stack） 函数怎么被调用 作用域链 对象参数 this … this，指向函数执行期间的this对象。 1、this不是创建时绑定，而是动态绑定（runtime binding） 2、 this的上下文基于函数的调用情况，和函数在哪定义没有关系。 调用情况分析1.全局作用域（global context）1.1 浏览器中，this指向windowindex.js1console.log(this) // window; 1.2 在nodejs中，this指向 globalindex.js1console.log(this) // global; 2.函数作用域在函数内部，this由函数如何调用来确定指向 2.1 作为函数调用作为函数调用时，this并没有通过call指定，但this必须指定对象，因此默认指向window，所以调用foo()输出1。index.js12345function foo() &#123; return this.a;&#125;var a = 1;console.log(foo()); // 1 在严格模式下，this会保持在进入执行上下文时所设置的指向，如果没有设置，默认指向undefined。 index.js12345678910111213function fn() &#123; 'use strict' return this;&#125;console.log(fn()); //undefinedfunction foo() &#123; 'use strict' return this.a;&#125;var a = 1;console.log(foo()); // TypeError: Cannot read property 'a' of undefined 2.2 对象方法调用函数作为对象的方法调用时，this指向该对象。 index.js1234567const animal = &#123; name: \"animal\", sayName: function() &#123; console.log(this.name); &#125;&#125;;animal.sayName(); // animal 原型链上的方法调用与对象方法调用一样，this指向对象方法调用时的对象。 index.js12345678910function Person(name, age) &#123; this.name = name; this.age = age; &#125;Person.prototype.getName = function() &#123; return this.name;&#125;var p1 = new Person(‘Ken’, 20);p1.getName(); // Ken 下面讲new 调用构造函数所发生的事。 2.3 构造函数调用构造函数调用，this指向当前实例对象。 index.js1const a = new foo(); // this指向a; new调用构造函数： 1、创建一个新的对象 2、将新对象的原型设置为构造函数的原型对象prototype 3、执行构造函数，将this指向新对象 4、返回这个新对象 模拟实现： new.js123456789101112131415161718192021222324function create() &#123; let obj = new Object(); //从Object.prototype上克隆一个对象 //let obj = &#123;&#125;; let Constructor = [].shift.call(arguments); //获取传入的构造函数 obj.proto = Constructor.prototype; // 将新对象的proto指向构造函数的prototype let result = Constructor.apply(obj, arguments); // 将this指向新对象,并执行构造函数 return result instanceof Object ? result : obj; // 确保返回的是对象&#125;function animal(name, fit) &#123; this.name = name; this.fit = fit;&#125;animal.prototype.sayName = function() &#123; console.log(this.name);&#125;;const pig = create(animal, “Ken”, 12);pig.sayName(); // Ken 2.4 apply、call、bind2.4.1 apply、callcall： 使用一个指定的this和若干指定参数的前提下，调用某个函数或方法。apply： 与call类似，只是提供参数的方式不一样，apply的参数是数组。 12345678910function sum(c, d) &#123; return this.a + this.b + c + d;&#125;const obj = &#123; a: 1, b: 2&#125;;console.log(sum.call(obj, 1, 2)); // 6console.log(sum.apply(obj, [3, 4])); // 10 2.4.2 bind bind： 方法创建一个新的函数，在bind()被调用时，这个新函数的this被bind的第一个参数指定，其余的参数将作为新函数的参数供调用时使用。 MDN: https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind 与apply,call 不同的是，bind 返回一个原函数的拷贝。 123456789101112var a = 10;const module = &#123; a:1, getA:function() &#123; return this.a; &#125;&#125;module.getA(); // 1; 对象方法调用，`this`指向moduleconst getValueA = module.getA;getValueA(); // 10 全局作用域中调用getA()，所以这里输出10.const fn = getValueA.bind(module); //把 'this' 绑定到 module 对象fn(); // 1 如果将null/undefined作为this传入，在被调用的时候会被忽略，使用默认绑定（window）。可以传{}让this为空。 无论bind()多少次，this的指向永远由第一决定。 2.5 箭头函数 箭头函数的this继承于包裹它的第一个普通函数的this，如果没有普通函数，则为全局对象。 箭头函数的this在第一次绑定后就不会再改变。 不能使用new来调用 1234567891011121314151617181920212223242526function fn() &#123; return () =&gt; &#123; return () =&gt; &#123; console.log(this) &#125; &#125;&#125;console.log(fn()()()) // Windowvar name = \"Ken\"const module = &#123; name: \"module\", getName: function() &#123; const fn = ()=&gt; &#123; console.log(this.name) &#125; fn(); &#125;, // 外层没有普通函数包裹，因此`this`指向全局作用域 arrowFn: ()=&gt; &#123; console.log(this.name) &#125;&#125;module.getName(); // modulemodule.arrowFn(); // ken 总结this的绑定规则可以分为 new绑定 显示绑定：call、apply、bind 隐式绑定：作为对象方法调用 默认绑定：函数调用 优先级：new &gt; call、apply、bind &gt; obj.fn() &gt; fn()","link":"/2019/03/22/拾遗JavaScript——this/"},{"title":"拾遗webpack4（二）——Babel","text":"BabelBabel 是什么？主要用于将 ECMAScript 2015+ 版本的代码转换为向后兼容的 JavaScript 语法，以便能够运行在当前和旧版本的浏览器或其他环境中。 1、执行以下命令安装所需要的 package 12npm install --save-dev babel-loader @babel/core @babel/preset-envnpm install --save @babel/polyfill babel-loader : 这是 Webpack 的 Babel 插件，它将被添加到 Webpack 配置中，以指示它在捆绑过程中通过 Babel 运行目标文件； @babel/core @babel/preset-env：通过根据目标浏览器或运行时环境自动确定所需的 Babel 插件和 polyfill，将代码编译为 ES5 @babel/polyfill：垫片，转化 ES6 内置语法（Array.from,Object.assign 等） 1234567891011\"devDependencies\": &#123; \"@babel/core\": \"^7.4.3\", \"@babel/preset-env\": \"^7.4.3\", \"babel-loader\": \"^8.0.5\", \"clean-webpack-plugin\": \"^2.0.1\", \"webpack\": \"^4.30.0\", \"webpack-cli\": \"^3.3.0\" &#125;, \"dependencies\": &#123; \"@babel/polyfill\": \"^7.4.3\" &#125; 2、新建 babel 配置文件.babelrc 来配置 babel 123&#123; \"presets\": [\"@babel/preset-env\"]&#125; 3、在webpack.config.js中配置 babel-loader 123456789module: &#123; rules: [ &#123; test: /\\.js$/, //匹配js文件 exclude: /node_modules/, //忽略目标文件夹 loader: \"babel-loader\" // 使用babel-loader &#125; ];&#125; 4、验证 在 index.js 中使用 ES6 语法 12345// import '@babel/polyfill'const arr = [\"1\", \"2\", \"3\"];const fn = () =&gt; console.log(...arr);fn(); 这里还需要import &#39;@babel/polyfill&#39;全局引入打包后体积大、根据需要转译的文件按需引用又很麻烦，这里只需要配置一下babelrc，babel 自动转译 .babelrc1234567891011&#123; \"presets\": [ [ \"@babel/preset-env\", &#123; \"useBuiltIns\": \"usage\", \"corejs\": \"3\" //使用core-js@3版本 &#125; ] ]&#125; 这里遇到一个小坑，配置完.babelrc后执行npm run build，控制台首先会提示一段警告: 大概意思就是指定用什么版本的core-js,默认使用core-js@2版本 然后报错 这里配置一下core-js的版本 执行npm run build 浏览器中打开dist文件夹下的index.html，查看控制台输出。 Chrome 最新版是支持 ES6 语法的，最好的还是在 IE 下测试。","link":"/2019/03/04/拾遗webpack4（二）——Babel/"},{"title":"拾遗JavaScript——原型与原型链","text":"一、原型prototype基本上每个函数都有 一个特殊的属性——原型（prototype），它是一个显式属性。 当我们创建一个函数时，这个属性就自动被创建。 1function fn()&#123;&#125; 函数的prototype是什么？ prototype 属性：继承成员定义的地方。 通俗的理解为：当我们实例化一个对象时，该对象会从原型中“继承”属性和方法。 12345678910111213141516function animal()&#123;&#125;;animal.prototype.class = \"animal\";animal.prototype.eat = function() &#123; console.log(\"eat something\");&#125;var cat = new animal();cat.eat(); // eat somethingconsole.log(cat.class); // \"animal\" 😪 抽象能力差怎么办？————画图 当我们打印cat这个实例时…….. What？？？ OOP思想中的继承（java，C++等）是一种对属性方法的复制操作，但对象实例cat中并没有复制过来的属性和方法，但在调用class属性和eat()方法时都可以正常调用。这？？？在JavaScript 的继承操作其实是一种“链接”操作，是一种委托，通过__proto__ 链接到构造函数的prototype。 __proto____proto__ 是每一个对象（除了null）都有的隐式属性，它指向创建该对象的构造函数的[[prototype]]，因此我们可以访问到定义在构造函数的prototype上的属性和方法。 1console.log(cat.__proto__ == animal.prototype); // true 当使用cat.__proto__ 时，实际上是返回Object.getPrototypeOf(cat)。可以理解为一种getter/setter操作。 😪 抽象能力差怎么办？——画图 constructor 在animal.prototype中还有一个属性constructor,它是干什么用的？ constructor:每一个实例对象都从原型中继承一个 constructor 属性，它指向构造此实例对象的构造函数； 因此实例cat的构造函数是function animal() 12console.log(animal.prototype.constructor === animal); // trueconsole.log(cat.constructor === animal); // true 我们还可以这样去创建animal的实例，但一般来说知道原始构造器function animal()的情况下不会用这样的方式。 1234const dog = new cat.constructor();dog.class // animaldog.eat() // eat somethingconsole.log(dog.constructor === animal); // true 画图捋一捋～ 原型的原型 ？捋清了实例与原型的关系,那原型的原型是什么？ animal.prototype 中也有一个属性__proto__ , 这个__proto__属性指向哪？ 在JavaScript中，函数其实也是Object，animal.prototype.__proto__ 指向的是Object.prototype 而Object.prototype.__proto__ === null 原型链1234567891011121314function animal()&#123;&#125;;animal.prototype.class = \"animal\";var cat = new animal();cat.class = \"cat\";console.log(cat.class); // catdelete cat.class; // 删除 cat 的 class 属性console.log(cat.class); // animalcat.isPrototypeOf();cat.valueOf() 由以上代码可以看出:1、cat.class 首先在实例cat上寻找属性class，输出“cat”2、删除实例cat上的属性class，仍能调用，但输出的是&quot;animal&quot;这是因为当在实例上寻找不到属性class时，会通过__proto__找到aminal.prototype，在上面寻找到class，并输出&quot;animal&quot;3、并没有在实例cat或者animal.prototype上定义isPrototypeOf()/valueOf()，为什么还能调用？这是因为当在实例、实例原型animal.prototype上找不时，解析器会继续往上，即animal.prototype.__proto__，直到__proto__指向null则停止寻找。此时animal.prototype.__proto__指向的是Object.prototype，所以调用上面定义的方法isPrototypeOf()/valueOf() 实例cat、构造函数animal的原型prototype、Object.prototype 以__proto__链接起来的关系就形成了原型链。 图腾","link":"/2019/04/10/拾遗JavaScript——原型与原型链/"},{"title":"The Boring Project——驾校管理系统","text":"～ 1","link":"/2019/08/11/The-Boring-Project——驾校管理系统/"},{"title":"Javascript——防抖与节流","text":"防抖防止函数多次调用，例如一个用户一直触发这个函数，且每次触发函数的间隔小于 wait，防抖的情况下只会调用一次。 Code123456789101112131415161718192021222324252627/** *防抖函数 * @param &#123;function&#125; fn 需要执行的函数，（例如网络请求） * @param &#123;number&#125; wait 等待时间，预设 50ms * @returns &#123;function&#125; 需要进行防抖处理的函数 */const debounce = (fn, wait = 50) =&gt; &#123; let timer = 0; //初始化一个定时器 // 返回进行防抖处理的函数 return function(...arguments) &#123; // 如果定时器存在则清空上一次的定时器 if (timer) &#123; clearTimeout(timer); &#125; // 重新计时，延迟执行传入的函数 timer = setTimeout(() =&gt; &#123; fn.apply(this, arguments); &#125;, wait); &#125;;&#125;;// Button 按钮document.getElementById(\"btn\").addEventListener( \"click\", debounce(function(e) &#123; console.log(\"change\", e.target.value, new Date() - 0); &#125;, 350)); 一般防抖都会有一个选项：是否立即调用。在不同使用场景进行区分使用。例如： 在搜索引擎搜索问题的时候，我们当然是希望用户输入完最后一个字才调用查询接口，这个时候适用延迟执行的防抖函数，它总是在一连串（间隔小于 wait 的）函数触发之后调用。 文本输入的验证（连续输入文字后发送请求进行验证，验证一次就好)。 比如一个 start 按钮，当点击按钮的时候立刻改变按钮形状，这时候用户可以知道交互操作正在进行，那么需要立即执行函数。 改造：加入立即执行选项1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * 防抖 * @param &#123;function&#125; fn 需要执行的函数，（例如网络请求） * @param &#123;Boolean&#125; immediate 是否立即执行，默认 true * @param &#123;Number&#125; wait 等待时间，预设 50ms * @returns &#123;function&#125; 需要进行防抖处理的函数 */const debounce = (fn, immediate = true, wait = 50) =&gt; &#123; let timer = 0; //初始化一个定时器 let context, args; //执行上下文、参数 // 延迟执行函数 const later = () =&gt; setTimeout(() =&gt; &#123; // 延迟函数执行完毕，清空缓存的定时器 timer = null; if (!immediate) &#123; // 执行函数 fn.apply(context, args); // 重置执行上下文和参数 context = args = null; &#125; &#125;, wait); // 返回进行防抖处理的函数 return function(...arguments) &#123; // 如果定时器不存在则创建延迟定时器。 if (!timer) &#123; timer = later(); // 如果是立即执行，则执行函数 if (immediate) &#123; fn.apply(this, arguments); &#125; else &#123; //缓存执行上下文和参数 context = this; args = arguments; &#125; &#125; else &#123; // 如果已有延迟执行函数（later），调用的时候清除原来的并重新设定一个. // 这样做延迟函数会重新计时 clearTimeout(timer); timer = later(); &#125; &#125;;&#125;; 对于按钮的点击来说，假设你连续点击了 10 次，如果网络请求防抖是立即执行的，在这 10 次过程中，函数只在点击的第一次立即执行。其余的 9 次都在重置定时器，等到最后一次设定的计时器计时时间到，再次点击才重新执行。 节流简单可以理解为：将多次执行的函数固定成每隔一段时间执行。 一般情况下有 2 中不同的限制方式适用不同需求 首次是否执行 结束后是否执行 Code使用时间戳实现思路 变量previous记录调用方法的时间戳. 对比之前的时间错，如果大于设置的时间错，则执行函数。执行后更新时间戳为当前时间。 123456789101112const throttle = (func, delay) =&gt; &#123; let previous = 0; return function(...args) &#123; let now = +new Date(); // 将当前时间和上一次执行函数时间对比 // 如果差值大于设置的等待时间就执行函数 if (now - previous &gt; delay) &#123; previous = now; func.apply(this, args); &#125; &#125;;&#125;; 代码分析 1.第一次执行时，if (now - previous &gt; delay)，previous=0，所以方法立即执行，随后记录previous=now()，每隔 1s 执行一次方法。 2.但不会触发最后一次执行。 使用setTimeout实现思路 当执行 throttle 函数时，判断是否存在定时器，如果不存在，则开启一个定时器， 123456789101112const throttle = (func, delay) =&gt; &#123; let timer; return function(...args) &#123; // 如果定时器不存在，则开启一个定时器。 if (!timer) &#123; timer = setTimeout(() =&gt; &#123; func.apply(this, args); timer = null; &#125;, delay); &#125; &#125;;&#125;; 代码分析 当连续调用 throttle 函数时，方法func不会立即执行，之后根据设定的 delay 时间间隔执行。 结束调用后还会执行一次。 两者之间的区别在与是否首次执行和是否结束后执行。 完善思路 增加options选项，可选 leading:false 表示禁用第一次执行、trailing:false 表示禁用停止触发的回调 1234567891011121314151617181920212223242526272829const throttle = (func, delay, option) =&gt; &#123; let timer, previous = null; // const later = function() &#123; previous = option.leading === false ? 0 : +new Date(); func.apply(this, arguments); timer = null; &#125;; return function(...args) &#123; // 如果定时器不存在，则开启一个定时器。 let now = +new Date(); // 如果leading===false表示第一次调用不执行； if (option.leading === false &amp;&amp; !previous) &#123; previous = now; &#125; // 根据时间戳对比是否在限制时间内 if (now - previous &gt; delay) &#123; if (timer) &#123; clearTimeout(timer); timer = null; &#125; func.apply(this, args); previous = now; &#125; else if (!timer &amp;&amp; option.trailing !== false) &#123; timer = setTimeout(later, delay); &#125; &#125;;&#125;;","link":"/2019/08/09/防抖与节流/"},{"title":"拾遗JavaScript——Promise","text":"基本使用没啥好记录～ 具体参考 MDN Promise https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise Promise 具体用法 https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Using_promises Promise.all()Promise.all() 参数一个可迭代对象，如 Array 或 String。 返回值 如果传入的参数是一个空的对象，则返回一个已完成（already resolved）状态的 Promise。 如果传入的参数不包含任何 promise，则返回一个异步完成（asynchronously resolved） Promise。 1、Promise.all 返回的 promise 的完成状态的结果都是一个数组。2、如果所有传入的 promise 都变为完成状态，或者传入的可迭代对象内没有 promise，Promise.all 返回的 promise 异步地变为完成3、如果传入的 promise 中有一个失败（rejected），Promise.all 异步地将失败的那个结果给失败状态的回调函数，而不管其它 promise 是否完成，从而丢弃其他Promise的完成结果。 🌰当我们在同时发起多个网络请求时，可以用Promise.all()来处理。 promise.js12345678910111213141516function fetchData(url) &#123;return new Promise((resolve, reject) =&gt; &#123;const requet = new XMLHttpRequest();requet.open(\"GET\", url);requet.onload = () =&gt; resolve(requet.responseText);requet.onerror = () =&gt; reject(requet.statusText);requet.send();&#125;);&#125;const fetch_1 = fetchData(topNewsUrl)const fetch_2 = fetchData(topNewsUrl)const fetch_3 = fetchData(topNewsUrl)Promise.all([fetch_1,fetch_2,fetch_3]).then(res=&gt;&#123;console.log(res);&#125;) 但是当Promise.all()中有一个promise的状态为rejected，则会抛弃其他已完成的结果。 promise.js1234567891011const fetch_1 = fetchData(topNewsUrl);const fetch_2 = fetchData(topNewsUrl);const fetch_3 = Promise.reject(\"err\");Promise.all([fetch_1, fetch_2, fetch_3]).then(res =&gt; &#123;console.log(res);&#125;).catch(err =&gt; &#123;console.log(err);&#125;); 但是有时候我们想要同时得到正确处理的结果和失败结果，可以这样处理promise.js1234567891011121314151617const fetch_1 = fetchData(topNewsUrl);const fetch_2 = fetchData(topNewsUrl);// 用 catch()捕获当前 promise reject(\"err\")，并返回。// catch() 返回值是一个 promise，如果不被 rejected，则它显示为成功(resolved)const fetch_3 = Promise.reject(\"err\").catch(err =&gt;&#123;return err;&#125;);const fetchs = [fetch_1, fetch_2, fetch_3];Promise.all(fetchs).then(res =&gt; &#123;console.log(res);&#125;).catch(err =&gt; &#123;console.log(err);&#125;); 同时也可以使用Promise.allSettled() Promise.allSettled()Promise.allSettled()： 无论是成功或拒绝。返回数组包含原始promises集中每个promise的结果。 1234567const fetch_1 = Promise.resolve(1);const fetch_2 = Promise.reject(2);const fetch_3 = Promise.resolve(3);const fetchs = [fetch_1, fetch_2, fetch_3];console.log(Promise.allSettled(fetchs)); Promise.finally()finally() 方法返回一个Promise。在promise结束时，无论结果是fulfilled或者是rejected，都会执行指定的回调函数。这为在Promise是否成功完成后都需要执行的代码提供了一种方式 12345678Promise.resolve(1) .then(res =&gt; console.log(res)) // 1 .catch(err =&gt; console.log(err)) .finally(() =&gt; console.log(\"finally\")); // finallyPromise.reject(2) .then(res =&gt; console.log(res)) .catch(err =&gt; console.log(err)) // 2 .finally(() =&gt; console.log(\"finally\")); //finally Promise ? async/await当一个网络请求需要依赖上一个请求的结果时： Promise Promise.js12345678910fetchData(topNewsUrl) .then(res =&gt; &#123; return res.data[0].id; &#125;) .then(itemID =&gt; &#123; return fetchData(newsDetailUtl + itemID); &#125;) .then(res =&gt; &#123; console.log(res); &#125;); async/await async/await.js12345async function asyncFetch() &#123; const news = await fetchData(topNewsUrl) const res = await fetchData(newsDetailUtl + news.data[0].id); console.log(res);&#125; 对比两者显然async/await 代码更简洁容易理解。 实现一个 Promise基础简易版myPromise.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869// Promise三种状态;const PENDING = \"pendding\"; //等待const FULFILLED = \"fulfilled\"; // 完成const REJECTED = \"rejected\"; //拒绝class myPromise &#123; constructor(executor) &#123; this.state = PENDING; //初始状态 this.value = null; // 完成结果 this.reason = null; // 拒绝原因 const resolve = value =&gt; &#123; if (this.state === PENDING) &#123; this.value = value; // 保存完成结果 this.state = FULFILLED; // 保存状态为完成 &#125; &#125;; const reject = value =&gt; &#123; if (this.state == PENDING) &#123; this.reason = value; // 保留拒绝原因 this.state = REJECTED; // 保存状态为拒绝 &#125; &#125;; /** * executor: Promise中首先传了一个executor，它是一个函数 * executor函数中又传了两个函数，分别是resolve和reject * @param resolve:成功回调 * @param reject:拒绝回调 */ executor(resolve, reject); &#125; /** * 根据成功或失败的状态去执行相关成功onFilfulled()或者失败onRejected()的回调方法 * @param &#123;*&#125; onFulfilled ：成功 * @param &#123;*&#125; onRejected ：拒绝 */ then(onFulfilled, onRejected) &#123; switch (this.state) &#123; case FULFILLED: //执行成功的回调函数onFilfulled，传入成功结果 this.value onFulfilled(this.value); break; case REJECTED: //执行成功的回调函数onRejected，传入拒绝结果 this.reason onRejected(this.reason); break; default: break; &#125; &#125; /** * * @param &#123;*&#125; onRejected ：拒绝 */ catch(onRejected) &#123; return this.then(null, onRejected); &#125;&#125;const p = new myPromise((resolve, reject) =&gt; &#123; resolve(1);&#125;);p.then(res =&gt; &#123; console.log(res); // 1&#125;); 很显然，测试结果反应代码没有问题，但是如果加个异步函数呢？ 异步处理myPromise.js12345678const p = new myPromise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(1); &#125;, 1000);&#125;);p.then(res =&gt; &#123; console.log(res); &#125;); 很显然，控制台不会输出什么，因为setTimeout是异步任务，会被加入到Task Queue 当调用then()时，myPromise.state 还是 PENDING，此时then()函数并不知道到底是执行onFulfilled()，还是onRejected()。 改造….myPromise.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697// Promise三种状态;const PENDING = \"pendding\"; //等待const FULFILLED = \"fulfilled\"; // 完成const REJECTED = \"rejected\"; //拒绝class myPromise &#123; constructor(executor) &#123; this.state = PENDING; //初始状态 this.value = null; // 完成结果 this.reason = null; // 拒绝原因 this.onFulfilledCallbacks = []; // 保存完成回调 this.onRejectedCallbacks = []; // 保存拒绝回调 const resolve = value =&gt; &#123; if (this.state === PENDING) &#123; this.value = value; // 保存完成结果 this.state = FULFILLED; // 保存状态为完成 // 状态变更后 立即执行之前存放在相应数组中所有完成的回调函数. this.onFulfilledCallbacks.map(cb =&gt; &#123; cb(); &#125;); &#125; &#125;; const reject = value =&gt; &#123; if (this.state == PENDING) &#123; this.reason = value; // 保留拒绝原因 this.state = REJECTED; // 保存状态为拒绝 // 状态变更后 立即执行之前存放在相应数组中所有拒绝的回调函数 this.onRejectedCallbacks.map(cb =&gt; &#123; cb(); &#125;); &#125; &#125;; try &#123; /** * executor: Promise中首先传了一个executor，它是一个函数 * executor函数中又传了两个函数，分别是resolve和reject * @param resolve:成功回调 * @param reject:拒绝回调 */ executor(resolve, reject); &#125; catch (err) &#123; // 如果出错，直接进入reject() reject(err); &#125; &#125; /** * 根据成功或失败的状态去执行相关成功onFilfulled()或者失败onRejected()的回调方法 * @param &#123;*&#125; onFulfilled ：成功 * @param &#123;*&#125; onRejected ：拒绝 */ then(onFulfilled, onRejected) &#123; switch (this.state) &#123; // 针对可能存在的异步调用，在PENDING状态时将完成、失败的回调函数push到对应的数组中，待状态改变时执行。 // 这种方式可以称为订阅 case PENDING: this.onFulfilledCallbacks.push(() =&gt; &#123; onFulfilled(this.value); &#125;); this.onRejectedCallbacks.push(() =&gt; &#123; onRejected(this.reason); &#125;); break; case FULFILLED: //执行成功的回调函数onFilfulled，传入成功结果 this.value onFulfilled(this.value); break; case REJECTED: //执行成功的回调函数onRejected，传入拒绝结果 this.reason onRejected(this.reason); break; default: break; &#125; &#125; /** * 捕获reject * @param &#123;*&#125; onRejected ：拒绝 */ catch(onRejected) &#123; return this.then(null, onRejected); &#125;&#125;const p = new myPromise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(1); &#125;, 1000);&#125;);p.then(res =&gt; &#123; console.log(res); // 1&#125;); then()链式调用 如果一个then方法返回一个普通值的话，这个值会传递给下一个then中作为resolve成功的结果如果一个then方法返回一个promise的话，会根据返回的promise是成功还是失败，决定下一个then是成功还是失败 myPromise.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118// Promise三种状态;const PENDING = \"pendding\"; //等待const FULFILLED = \"fulfilled\"; // 完成const REJECTED = \"rejected\"; //拒绝class myPromise &#123; constructor(executor) &#123; this.state = PENDING; //初始状态 this.value = null; // 完成结果 this.reason = null; // 拒绝原因 this.onFulfilledCallbacks = []; // 保存完成回调 this.onRejectedCallbacks = []; // 保存拒绝回调 const resolve = value =&gt; &#123; // 为了保证函数执行顺序，需要将两个函数体代码使用 setTimeout 包裹起来 setTimeout(() =&gt; &#123; if (this.state === PENDING) &#123; this.value = value; // 保存完成结果 this.state = FULFILLED; // 保存状态为完成 // 状态变更后 立即执行之前存放在相应数组中所有完成的回调函数. this.onFulfilledCallbacks.forEach(cb =&gt; &#123; cb(); &#125;); &#125; &#125;, 0); &#125;; const reject = value =&gt; &#123; //为了保证函数执行顺序，需要将两个函数体代码使用 setTimeout 包裹起来 setTimeout(() =&gt; &#123; if (this.state == PENDING) &#123; this.reason = value; // 保留拒绝原因 this.state = REJECTED; // 保存状态为拒绝 // 状态变更后 立即执行之前存放在相应数组中所有拒绝的回调函数 this.onRejectedCallbacks.forEach(cb =&gt; &#123; cb(); &#125;); &#125; &#125;, 0); &#125;; try &#123; /** * executor: Promise中首先传了一个executor，它是一个函数 * executor函数中又传了两个函数，分别是resolve和reject * @param resolve:成功回调 * @param reject:拒绝回调 */ executor(resolve, reject); &#125; catch (err) &#123; // 如果出错，直接进入reject() reject(err); &#125; &#125; /** * 根据成功或失败的状态去执行相关成功onFilfulled()或者失败onRejected()的回调方法 * @param &#123;*&#125; onFulfilled ：成功 * @param &#123;*&#125; onRejected ：拒绝 */ then(onFulfilled, onRejected) &#123; // return 一个 promise return new myPromise((resolve, reject) =&gt; &#123; switch (this.state) &#123; // 针对可能存在的异步调用，在PENDING状态时将完成、失败的回调函数push到对应的数组中，待状态改变时执行。 // 这种方式可以称为订阅 case PENDING: this.onFulfilledCallbacks.push(() =&gt; &#123; try &#123; const x = onFulfilled(this.value); resolve(x); &#125; catch (err) &#123; reject(err); &#125; &#125;); this.onRejectedCallbacks.push(() =&gt; &#123; try &#123; const x = onRejected(this.reason); resolve(x); &#125; catch (err) &#123; reject(err); &#125; &#125;); break; case FULFILLED: //执行成功的回调函数onFilfulled，传入成功结果 this.value try &#123; const x = onFulfilled(this.value); resolve(x); &#125; catch (err) &#123; reject(err); &#125; break; case REJECTED: //执行成功的回调函数onRejected，传入拒绝结果 this.reason try &#123; const x = onRejected(this.reason); resolve(x); &#125; catch (err) &#123; reject(err); &#125; break; default: break; &#125; &#125;); &#125; /** * 捕获reject * @param &#123;*&#125; onRejected ：拒绝 */ catch(onRejected) &#123; return this.then(null, onRejected); &#125;&#125; 测试myPromise.js123456789101112131415161718192021222324const p = new myPromise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(1); &#125;, 1000);&#125;);p.then(res =&gt; &#123; console.log(res); // 1 return \"2\"; &#125;) .then(res =&gt; &#123; console.log(res); // 2 return &#123; a: 3 &#125;; &#125;) .then(res =&gt; &#123; console.log(res); // &#123;a:3&#125; return undefined; &#125;) .then(res =&gt; &#123; console.log(res); // undefined &#125;) .then(res =&gt; &#123; console.log(res); // undefined &#125;); then中函数返回值的处理 非普通值情况。 这里还有类型判断、参数透传等问题处理，后续完成 Promise/A+规范 Promise/A+ 规范","link":"/2019/03/10/拾遗JavaScript——Promise/"},{"title":"拾遗JavaScript——call、apply、bind","text":"call()call() 方法使用一个指定的 this 值和单独给出的一个或多个参数来调用一个函数。(MDN) https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call 🌰基本用法123456789101112var a = 2;function foo() &#123; console.log(this.a);&#125;const bar = &#123; a: 1&#125;;var a = 2;// 隐式调用，this指向windowfoo(); // 2 // 改变this指向barfoo.call(bar); // 2 构造函数式继承在一个子构造函数中，通过调用父构造函数的 call 方法来实现继承。 123456789101112function Product(name, price) &#123; this.name = name; this.price = price;&#125;function Food(name, price) &#123; // 在Food的构造函数中调用父类Product的构造函数 // this指向Food Product.call(this, name, price); this.categroy = \"food\";&#125;// 对象实例拥有在 Product 构造函数中添加的 name 属性和 price 属性。const cheese = new Food(\"cheese\", 10); 如何模拟实现call()语法：fun.call(thisArg, arg1, arg2, ...) 1234567891011function foo() &#123; console.log(this.a);&#125;const bar = &#123; a: 1, foo: function() &#123; console.log(this.a); &#125;&#125;;bar.foo(); // 1foo.call(bar); // 1 假设当调用foo.call(bar)时，其实是在bar上添加一个foo属性，这样foo函数中的this便指向了bar。 bar.fn = foo; bar.fn(); delete bar.fn Step 11234567891011121314Function.prototype.customizeCall = function(context) &#123; context.fn = this; // 获取调用customizeCall的函数，添加到临时属性fn context.fn(); // 执行函数 delete context.fn; // 删除fn属性&#125;;function foo() &#123; console.log(this.a);&#125;const bar = &#123; a: 1&#125;;foo.customizeCall(bar); // 1 Step 2fun.call() 除了传入运行时指定的绑定this的目标，还需要传入参数列表args 12345678910111213141516171819202122232425262728293031Function.prototype.customizeCall = function(context) &#123; // 获取调用customizeCall方法的函数，添加到临时属性fn context.fn = this; // 获取传入的参数 // 函数参数数组arguments是一个类数组，可以for循环 let args = []; // 保存参数 for (let i = 1; i &lt; arguments.length; i++) &#123; // 拼接参数为字符串push进args，后续需要用到eval() // args[\"arguments[1]\", \"arguments[2]\", ...] args.push(\"arguments[\" + i + \"]\"); &#125; // eval() 函数会将传入的字符串当做 JavaScript 代码进行执行。 // context.fn(arguments[1], ...); console.log(args); eval(\"context.fn(\" + args + \")\"); // context.fn(); delete context.fn;&#125;;function foo(name, age) &#123; console.log(this.a); console.log(name); console.log(age);&#125;const bar = &#123; a: 1&#125;;foo.customizeCall(bar, \"Ken\", 12); // 1, ken, 12 Step 3 call 方法可以不指定第一个参数的（this）的。 没有传递第一个参数，this 的值将会被绑定为全局对象。 严格模式下指向undefined。 call 方法是可以有返回值的。 123456789101112131415161718192021222324252627282930313233343536Function.prototype.customizeCall = function(context) &#123; //不传入this的情况下默认指向window // Object(context)：确保传入的是对象 context = Object(context) || window; // 获取调用customizeCall方法的函数，添加到临时属性fn context.fn = this; // 获取传入的参数 // 函数参数数组arguments是一个类数组，可以for循环 let args = []; // 保存参数 for (let i = 1; i &lt; arguments.length; i++) &#123; // 拼接参数为字符串 // args[\"arguments[1]\", \"arguments[2]\", ...] args.push(\"arguments[\" + i + \"]\"); &#125; // eval() 函数会将传入的字符串当做 JavaScript 代码进行执行。 // context.fn(arguments[1], ...); console.log(args); const result = eval(\"context.fn(\" + args + \")\"); // context.fn(); delete context.fn; return result;&#125;;function foo(name, age) &#123; return &#123; a: this.a, name: name, age: age &#125;;&#125;const bar = &#123; a: 1&#125;;console.log(foo.customizeCall(bar, \"Ken\", 12)); // &#123;a:1, name:ken, age:12&#125; 使用ES6语法实现 1234567891011Function.prototype.customizeCall = function(context, …args) &#123; //不传入this的情况下默认指向window // Object(context)：确保传入的是对象 context = Object(context) || window;; // 获取调用customizeCall方法的函数，添加到临时属性fn context.fn = this; // …扩展语法获取传入的参数，并添加到执行的函数里 const result = context.fn(…args); delete context.fn; return result;&#125;; apply()apply() 方法调用一个具有给定this值的函数，以及作为一个数组（或类似数组对象）提供的参数。 与call()方法类似，区别就是call()方法接受的是参数列表，而apply()方法接受的是一个参数数组。MDN:https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply 模拟实现1234567891011121314151617181920212223242526272829303132333435363738394041Function.prototype.customizeApply = function(context, arr) &#123; //不传入this的情况下默认指向window // Object(context)：确保传入的是对象 context = Object(context) || window; // 获取调用customizeCall方法的函数，添加到临时属性fn context.fn = this; let result = null; // 如果没有传入参数列表，则直接执行 if (!arr) &#123; result = context.fn(); &#125; else &#123; // 获取传入的参数 // for循环函数参数数组arr // 保存参数 let args = []; for (let i = 0; i &lt; arr.length; i++) &#123; // 拼接参数为字符串 // args[\"arr[1]\", \"arr[2]\", ...] args.push(\"arr[\" + i + \"]\"); &#125; // eval() 函数会将传入的字符串当做 JavaScript 代码进行执行。 // context.fn(arguments[1], ...); result = eval(\"context.fn(\" + args + \")\"); &#125; // context.fn(); delete context.fn; return result;&#125;;function foo(name, age) &#123; return &#123; a: this.a, name: name, age: age &#125;;&#125;const bar = &#123; a: 1&#125;;console.log(foo.customizeApply(bar, [\"Ken\", 12])); // &#123;a:1, name:ken, 12&#125; 使用ES6扩展语法实现 123456789101112131415Function.prototype.customizeApply = function(context, arr) &#123; //不传入this的情况下默认指向window // Object(context)：确保传入的是对象 context = Object(context) || window; // 获取调用customizeCall方法的函数，添加到临时属性fn context.fn = this; let result = null; if (!arr) &#123; result = context.fn(); &#125; else &#123; result = context.fn(…arr); &#125; delete context.fn; return result;&#125;; bind()bind()方法创建一个新的函数，在bind()被调用时，这个新函数的this被bind的第一个参数指定，其余的参数将作为新函数的参数供调用时使用。 bind() 最简单的用法是创建一个函数，不论怎么调用，这个函数都有同样的 this 值。 可以传参 返回一个函数 MDN:https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind 模拟实现123456789101112131415161718192021222324252627282930313233Function.prototype.customizeBind = function(toThis) &#123; //bind 的不是函数时抛出错误 if (typeof this !== \"function\") &#123; throw new Error( \"Function.prototype.bind - what is trying to be bound is not callable\" ); &#125; // 获取传入的参数 var args = Array.prototype.slice(arguments, 1), self = this, fNOP = function() &#123;&#125;, fBound = function() &#123; return self.apply( // this instanceof fBound === true时,说明返回的fBound被当做new的构造函数调用,将绑定函数的 this 指向该实例，可以让实例获得来自绑定函数的值; // this instanceof fBound === false时，说明fBound被当做普通函数调用，this 指向 window，将绑定函数的 this 指向 toThis; this instanceof fBound ? this : toThis, // 获取调用时(fBound)的传参 args.concat(Array.prototype.slice.call(arguments)) ); &#125;; // 维护原型关系 // 返回的函数 if (this.prototype) &#123; //返回函数的 prototype 为绑定函数的 prototype， fNOP.prototype = this.prototype; &#125; // 实例就可以继承绑定函数的原型中的值（__proto__指向fNOP的实例） fBound.prototype = new fNOP(); // 返回函数 // 返回一个原函数的拷贝，并拥有指定的this值和初始参数 return fBound;&#125;; 模拟实现参考mqyqingfeng:https://github.com/mqyqingfeng/Blog/issues/11","link":"/2019/06/10/拾遗JavaScript——call、apply、bind/"},{"title":"拾遗JavaScript——Event Loop","text":"Event Loop 一、基础知识1、进程与线程 进程：应用程序的执行实例，每一个进程都是由私有的虚拟地址空间、代码、数据个其他系统资源组成。 线程：线程是进程内的一个独立执行单元，在不同的线程之间可以进行资源共享。 进程拥有独立的堆栈空间和数据段，每当启动一个新的进程必须分配给它独立的地址空间，建立众多的数据表来维护它的代码段、堆栈段和数据段。 线程拥有独立的堆栈空间，但是共享数据段，它们彼此之间使用相同的地址空间，共享大部分数据，比进程更加节俭，开销比较小，切换速度快，效率高。 一句话总结: 进程：资源分配的最小单位 线程：程序执行的最小单位 Javascript是一门单线程语言Why??众所周知，多线程操作可以实现应用的并行处理，充分利用CPU资源提高性能和吞吐量。现在很多语言都支持多核并行处理技术。 但Javascript….😂 Javascript 是一门脚本语言，最初设计用于运行在浏览器环境，试想一下如果有2个同步线程在跑，一个在执行DOM的插入，另一个删除DOM，浏览器会？？？？ So…这意味着它可以一次处理一个任务或一次处理一段代码。它有一个调用堆栈，它与堆之类的其他部分一起构成了Javascript并发模型（在V8内部实现）。 Call StackCall Stack：它是一个记录函数调用的数据结构，当我们调用函数时，函数会被推入这个堆栈，但函数返回时按先入后出的规则依次推出。 123456789101112function multiply(a, b) &#123; return a * b;&#125;function square(n) &#123; return multiply(n, n);&#125;function printSquare(n) &#123; var squared = square(n); console.log(squared);&#125;printSquare(4); 通过断点调试可以很清楚的看到调用堆栈 当函数执行完返回时，依次从栈顶推出。 Heapheap：变量所有的内存分配都在在堆中进行。 QueueJavascript单线程任务被分为同步任务和异步任务，同步任务会在调用栈中按照顺序等待主线程依次执行，异步任务会在异步任务有了结果后，将注册的回调函数放入任务队列中等待主线程空闲的时候（调用栈被清空），被读取到栈内等待主线程的执行。 1234567891011console.log(\"1\");setTimeout(() =&gt; &#123; console.log(\"2\");&#125;, 3 * 1000);console.log(\"3\");// 1// 3// 2 如图所示：执行栈先处理同步任务console.log(&#39;1&#39;)，执行完后推出栈，控制台输出1,setTimeout()进入执行栈但不会执行，而是由Web API 处理完毕后，加入任务队列等待执行栈的同步任务执行完，同步任务console.log(&#39;3&#39;)进入执行栈，执行完毕后推出栈，当执行栈为null时，任务队列中的任务推入执行栈执行。 整个过程是循环不断的，这样的运行机制称为Event Loop Event Loop 侵删 补充宏任务/微任务宏任务（Task）： 整体代码script setTimeout setInterval setImmediate requestAnimationFrame I/O UI rendering 微任务(Microtask)： Promise（Promise中的then、catch才是宏任务，本身内部代码并不是） process.nextTick（nodejs环境中） MutationObserver： 提供了监视对DOM树所做更改的能力（https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver） 12345678910111213141516setTimeout(() =&gt; console.log('setTimeout1'), 0);setTimeout(() =&gt; &#123; console.log('setTimeout2'); Promise.resolve().then(() =&gt; &#123; console.log('promise2'); Promise.resolve().then(() =&gt; &#123; console.log('promise3'); &#125;) console.log(5) &#125;) setTimeout(() =&gt; console.log('setTimeout4'), 0);&#125;, 0);setTimeout(() =&gt; console.log('setTimeout3'), 0);Promise.resolve().then(() =&gt; &#123; console.log('promise1');&#125;) 逐步分析代码执行过程:1、Run Script2、开始轮询： setTimeout1、setTimeout2、setTimeout3 被推入Task Queue，promise1被推入Microtasks Queue。此时Task Queue中：[setTimeout1,setTimeout2,setTimeout3]，Microtasks Queue中：[promise1]。3、微任务优于宏任务之前执行，所以先执行Microtasks Queue中的队列promise1，控制台输出：promise1。随后依次执行setTimeout1、setTimeout2、setTimeout3，4、执行：setTimeout1： 输出setTimeout1；执行setTimeout2: 输出setTimeout2，发现一个微任务promise2,将它加入到Microtasks Queue，发现一个宏任务setTimeout4，将它加入Task；执行setTimeout3：输出 setTimeout3;5、此时Microtasks Queue中有[promise2]，执行promise2,输出promise2，这里又有个微任务promise3,将promise3加入Microtasks Queue，执行console.log(5),输出5。6、此时Microtasks Queue不为null，还有任务promise3,执行输出promise3。7、Microtasks Queue为null，检查Task Queue，发现还有一个宏任务 setTimeout4，执行并输出setTimeout4。 因此代码执行的结果为： 12345678promise1setTimeout1setTimeout2setTimeout3promise25promise3setTimeout4 微任务比宏任务优先执行，当微任务队列不为null时，继续处理微任务队列，等到全部处理完毕，则检查宏任务队列并处理队列的任务。 async/awaitasync/await 与 promise 一样同属于微任务。（async函数返回的是一个promise） 123456789101112131415161718192021async function async1() &#123; console.log(\"async1 start\"); await async2(); console.log(\"async1 end\");&#125;async function async2() &#123; console.log(\"async2\");&#125;console.log(\"script start\");setTimeout(function() &#123; console.log(\"setTimeout\");&#125;, 0);async1();new Promise(function(resolve) &#123; console.log(\"promise1\"); resolve();&#125;).then(function() &#123; console.log(\"promise2\");&#125;);console.log(\"script end\"); 以上代码执行过程：1、async1()、async2（）函数定义。2、同步任务，控制台输出：script start。3、setTimeout,加入宏任务队列。4、执行函数async1()。 a：同步任务，控制台输出async1 start。 b：await async2() ，此时线程被阻塞，无法执行当前函数下面的代码。 5、async2()：同步任务，控制台输出async2，6、由于async1()中，await阻塞里线程，无法回到async1()，因此继续执行async1()外面的代码。7、Promise，控制台输出promise1，将then()=&gt;{console.log(&quot;promise2&quot;)}回调加入微任务队列。8、同步任务,控制台输出script end，此时代码执行完。9、await阻塞线程结束。 a:回到函数async1()，async2()返回一个promise.resolve(undefined).then(undefined)，将then(undefined)加入微任务队列。 b:处理微任务队列then()=&gt;{console.log(&quot;promise2&quot;)}、then(undefined)，控制台输出promise2。 c:执行console.log(&quot;async1 end&quot;)，控制台输出async1 end。 10、处理宏任务队列，控制台输出setTimeout。 所以控制台输出：12345678script startasync1 startasync2promise1script endpromise2async1 endsetTimeout async/await本质上还是基于Promise的一些封装。执行async函数内遇到await fn()时，会阻塞线程跳出async函数，然后再次回到await fn()处，如果fn()返回的是Promise对象还要再次跳出async1()函数体外继续执行以外的代码。 补充在最新的Chrome（76.0.3809.87）中测试以上代码得到结果为： 12345678script startasync1 startasync2promise1script endasync1 endpromise2setTimeout","link":"/2019/04/09/拾遗JavaScript——Event-Loop/"},{"title":"Javascript——关于继承","text":"继承《JavaScript高级程序设计》看了忘，忘了记～ 原型链继承 每个对象都有一个隐式属性__proto__其指向该对象的构造函数的原型对象。prototype。 构造函数的原型对象prototype中包含一个constructor属性，其指向构造函数本身。 因此，可以通过重写原型对象，替换为父类的实例，从而拥有父类实例的全部属性及方法。这种方式即原型链继承 🌰123456789101112131415function Parent() &#123; this.name = \"Parent\"; this.numbers = [1, 2];&#125;Parent.prototype.getNumbers = function() &#123; console.log(this.numbers);&#125;;function Child() &#123;&#125;// 重写原型对象Child.prototype = new Parent();const child_1 = new Child();console.log(child_1.name); // Parentchild_1.getNumbers(); // [1, 2] 这种继承方式很明显的缺点是: 对于引用类型的属性，它会被所有实例共享。 无法向父类传递参数 123child_1.numbers.push(3);const child_2 = new Child();console.log(child_2.numbers); // [1, 2, 3] 借用构造函数🌰1234567891011121314function Parent(numbers) &#123; this.numbers = numbers;&#125;function Child(numbers) &#123; // 调用父类构造函数 Parent.call(this, numbers);&#125;const child_1 = new Child([3, 4]);console.log(child_1.numbers); //[3, 4]const child_2 = new Child([5]);console.log(child_2.numbers); // [5] 相较与原型式继承，借用构造函数的方式可以： 传递参数 引用类型属性不会被实例共享 但…. 12345678910// 父类原型属性中的方法，子类无法访问Parent.prototype.getNumbers = function() &#123; console.log(this.numbers);&#125;;const child_1 = new Child([3, 4]);child_1.getNumbers(); // TypeError: child_1.getNumbers is not a functionconst child_2 = new Child([5]);child_2.getNumbers(); // TypeError: child_1.getNumbers is not a function 很明显的缺点是: 父类的原型方法子类是无法访问到的，必须在构造函数中定义。因此，对于方法定义来说，每次创建实例都重新创建一遍方法。 组合继承（原型加借用构造函数的方式）🌰1234567891011121314151617181920212223242526272829303132function Parent(name) &#123; this.name = name; this.colors = [\"red\", \"blue\"];&#125;Parent.prototype.getColors = function() &#123; console.log(this.colors);&#125;;function Child(name, age) &#123; // 借用父类构造函数 Parent.call(this, name); this.age = age;&#125;// 重写原型对象（原型链继承）Child.prototype = new Parent();Child.prototype.constructor = Child;Child.prototype.getAge = function() &#123; console.log(this.age);&#125;;const child_1 = new Child(\"Ben\", 12);console.log(child_1.name); // Benchild_1.getAge(); // 12child_1.colors.push(\"gray\"); child_2.getColors(); // [\"red\",\"blue\",\"gray\"]const child_2 = new Child(\"Obi\", 20);console.log(child_2.name); // Obichild_2.getAge(); // 20child_2.getColors(); // [\"red\",\"blue\"] 组合继承很好的避开了原型链继承与借用构造函数继承的缺点，避免了引用类型属性共享又可以对方法进行复用。 但是…还有一个缺陷就是：在创建子类的实例时，会调用2次父类的的构造函数，从而子类的prototype上会有不必要多余的属性。 12345function Child(name, age) &#123; // 借用父类构造函数 Parent.call(this, name);&#125;Child.prototype = new Parent(); 原型继承 借助原型可以基于已有的的对象创建新对象，同时还不必因此创建自定义类型。—— 道格拉斯·克罗克福德 12345function object(obj) &#123; function F()&#123;&#125; F.prototype = o; retrun new F();&#125; 上面的方法object()，也是ES5中object.create()的模拟实现。 在object()函数内部，创建一个临时构造函数，将传入的对象作为这个构造函数的原型，然后返回这个临时类型的一个新的实例。 🌰12345678910111213var Parent = &#123; name: \"Parent\", colors: [\"red\", \"green\"]&#125;;const child_1 = object(Parent);child_1.name = \"child_1\";child_1.colors.push(\"blue\");console.log(child_1.name); // child_1const child_2 = object(Parent);child_2.name = \"child_2\";console.log(child_2.name); // child_2console.log(child_2.colors); //[\"red\", \"green\", \"blue\"] 这种方式与原型链继承一样，对于引用类型的属性会被所以实例共享。 寄生式继承寄生式继承依赖原型继承模式，类似与工厂模式，仅是在函数内部对对象进行增强，最后返回对象。 🌰1234567891011121314function factory(o) &#123; let clone = Object.create(o); clone.sayHi = function() &#123; console.log(\"Hi!\"); &#125;; return clone;&#125;var Parent = &#123; name: \"Parent\"&#125;;const child = factory(Parent);child.sayHi(); // Hi! 组合寄生式继承🌰1234567891011121314151617181920212223242526272829303132function Parent(name) &#123; this.name = name; this.colors = [\"red\", \"blue\"];&#125;Parent.prototype.getColors = function() &#123; console.log(this.colors);&#125;;function Child(name, age) &#123; // 借用父类构造函数 Parent.call(this, name); this.age = age;&#125;// 重写子类原型// 获得父类原型的副本Child.prototype = Object.create(Parent.prototype);Child.prototype.constructor = Child; // 上一行代码重写了子类的原型，因此要重新指定子类的构造函数Child.prototype.getAge = function() &#123; console.log(this.age);&#125;;const child_1 = new Child(\"Ben\", 12);console.log(child_1.name); // Benchild_1.getAge(); // 12child_1.colors.push(\"gray\");const child_2 = new Child(\"Obi\", 20);console.log(child_2.name); // Obichild_2.getAge(); // 20child_2.getColors(); // [\"red\", \"blue\"] 组合式继承有一个缺点就是会调用父类构造函数2次，寄生组合式继承避免了这一点，同时保持原型链不变，能正常instanceof、isPrototypeOf。因此是最理想的继承方式。 对比 组合继承 可以看到在子类的原型prototype上，多了colors,name属性 寄生组合继承 colors、name，是父类的实例属性，在重写子类原型属性prototype时（Child.prototype = new Parent()），子类的原型属性便获得了父类属性的副本colors,name。 const child = new Child()：调用子类Child()构造函数时又一次调用父类的构造函数(Parent.call(this, name))。子类实例child_1因此获得父类的实例属性colors,name，同时也屏蔽了子类原型属性prototype中的colors,name。 两次调用父类构造函数导致了子类Child()的原型属性prototype和子类实例child_1中都获得了父类的实例属性colors,name。 寄生组合式继承的基本思路就是：通过借用构造函数来继承属性，通过原型链来继承方法。 总结Javascript主要通过原型链实现继承。 原型链的构建是通过将一个类型的实例赋予另一个构造函数的原型属性prototype而实现的。通过这样的方式，子类就能访问父类的所有属性及方法。原型链的方式存在一个缺点就是所有实例共享所有属性及方法。因此需要借用构造函数的方式——在子类的构造函数中调用父类的构造函数，这样子类实例都会有单独的属性和方法。 原型链继承：通过重写子类原型的方式获得父类属性及方法及指向父类构造函数的指针。 缺点 引用类型所有实例共享。 无法传递参数。 构造函数继承：通过子类的构造函数中调用父类构造函数从而获父类属性。 优点 每个子类实例都有一份父类属性的拷贝，解决引用类型属性共享的问题。 缺点 子类实例无法访问父类prototype中定义的方法，因此方法必须定义在构造函数中，每次创建实例都要重新创建一次方法。 组合继承（经典继承）： 优点 避开了原型链继承及构造函数继承的缺点。 缺点 两次调用父类的构造函数。 原型式继承：无需定义构造函数的情况下实现继承。其本质是对目标对象的浅复制，从而得到对象的副本。 缺点 与原型链式继承一样，所有实例共享引用类型属性。 寄生式继承：类似与工厂模式，结合原型式继承的方式，对目标对象进行浅复制获得新对象，并对新对象进行增强加工，最后返回这个新对象 缺点 每次创建实例就是一次对象增强加工，因此都会创建一遍对象的方法。 寄生组合式继承: 结合寄生继承及组合式继承的优点，是继承最有效的方式。","link":"/2019/08/13/Javascript——关于继承/"}],"tags":[],"categories":[{"name":"Web","slug":"Web","link":"/categories/Web/"},{"name":"Webpack","slug":"Web/Webpack","link":"/categories/Web/Webpack/"},{"name":"Javascript","slug":"Web/Javascript","link":"/categories/Web/Javascript/"},{"name":"Project","slug":"Project","link":"/categories/Project/"}]}