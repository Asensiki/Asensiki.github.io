{"pages":[{"title":"categories","text":"","link":"/categories/index.html"}],"posts":[{"title":"拾遗JavaScript——async-await","text":"async/await async/await 同 Promise、callback 一样是一种编写异步代码的方法。 async/await 实际上是建立在 promises 之上的，其返回的是一个 promise。 async/await 是非阻塞的。 async/await 更像是同步代码，如果多个异步代码没有依赖性却使用了 await 会导致性能上的降低。 描述当调用一个 async 函数时，会返回一个 Promise 对象。当这个 async 函数返回一个值时，Promise 的 resolve 方法会负责传递这个值；当 async 函数抛出异常时，Promise 的 reject 方法也会传递这个异常值。 async 函数中可能会有 await 表达式，这会使 async 函数暂停执行，等待 Promise 的结果出来，然后恢复 async 函数的执行并返回解析值（resolved）。 注意， await 关键字仅仅在 async function中有效。如果在 async function函数体外使用 await ，你只会得到一个语法错误（SyntaxError）。 https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/async_function 🌰假设一个函数getJsonData() 来获取 Json 数据。 promise 12345const request = url =&gt; &#123; getJsonData(url).then(response =&gt; &#123; console.log(response.data); &#125;);&#125;; async/await 123const request = async url =&gt; &#123; console.log(await getJsonData(url));&#125;; 看这样看起来，async/await 是不是简洁了很多？ 毕竟写一堆 then 也是很烦的。 错误处理 (try/catch)1code snippet async/await hellasync/await 把我们从曾经的callback hell 中解放，而现在，我们陷入了async/await hell。","link":"/2019/03/12/拾遗JavaScript——async-await/"},{"title":"拾遗JavaScript——var-let-const","text":"变量的声明方式var声明局部变量和全局变量。 let声明一个块级作用域的局部变量。 const声明一个块级作用域的只读常量(需要初始值)。 变量提升12console.log(a);var a = 1; // undefined 实际上上部分的代码可以理解为: 123var a;console.log(a);a = 1; 这就是变量提升。 对于函数来说，只有函数声明会被提升到顶部，而函数表达式不会被提升。 12345baz(); // baz is not a functionvar baz = function() &#123; console.log(\"bar2\");&#125;; 暂时性死区let（const）将不会提升变量到代码块的顶部。因此，在变量声明之前引用这个变量，将抛出引用错误（ReferenceError）。这个变量将从代码块一开始的时候就处在一个“暂时性死区”，直到这个变量被声明为止。 12console.log(a);let a = 1; //a is not defined","link":"/2019/03/27/拾遗JavaScript——var-let-const/"},{"title":"拾遗JavaScript——this","text":"thisthis 到底是什么？如何确定 this 的指向性？ this 是让人困惑的东西～ this 在每个函数的作用域中被自动创建，当函数被调用时，一个执行上下文(execution context) 被创建 执行上下文 中包含一下信息 函数在哪调用（call-stack） 函数怎么被调用 作用域链 对象参数 this … this，指向函数执行期间的this对象。 1、this不是创建时绑定，而是动态绑定（runtime binding） 2、 this的上下文基于函数的调用情况，和函数在哪定义没有关系。 调用情况分析1.全局作用域（global context）1.1 浏览器中，this指向windowindex.js1console.log(this) // window; 1.2 在nodejs中，this指向 globalindex.js1console.log(this) // global; 2.函数作用域在函数内部，this由函数如何调用来确定指向 2.1 作为函数调用作为函数调用时，this并没有通过call指定，但this必须指定对象，因此默认指向window，所以调用foo()输出1。index.js12345function foo() &#123; return this.a;&#125;var a = 1;console.log(foo()); // 1 在严格模式下，this会保持在进入执行上下文时所设置的指向，如果没有设置，默认指向undefined。 index.js12345678910111213function fn() &#123; 'use strict' return this;&#125;console.log(fn()); //undefinedfunction foo() &#123; 'use strict' return this.a;&#125;var a = 1;console.log(foo()); // TypeError: Cannot read property 'a' of undefined 2.2 对象方法调用函数作为对象的方法调用时，this指向该对象。 index.js1234567const animal = &#123; name: \"animal\", sayName: function() &#123; console.log(this.name); &#125;&#125;;animal.sayName(); // animal 原型链上的方法调用与对象方法调用一样，this指向对象方法调用时的对象。 index.js12345678910function Person(name, age) &#123; this.name = name; this.age = age; &#125;Person.prototype.getName = function() &#123; return this.name;&#125;var p1 = new Person(‘Ken’, 20);p1.getName(); // Ken 下面讲new 调用构造函数所发生的事。 2.3 构造函数调用构造函数调用，this指向当前实例对象。 index.js1const a = new foo(); // this指向a; new调用构造函数： 1、创建一个新的对象 2、将新对象的原型设置为构造函数的原型对象prototype 3、执行构造函数，将this指向新对象 4、返回这个新对象 模拟实现： new.js123456789101112131415161718192021222324function create() &#123; let obj = new Object(); //从Object.prototype上克隆一个对象 //let obj = &#123;&#125;; let Constructor = [].shift.call(arguments); //获取传入的构造函数 obj.proto = Constructor.prototype; // 将新对象的proto指向构造函数的prototype let result = Constructor.apply(obj, arguments); // 将this指向新对象,并执行构造函数 return result instanceof Object ? result : obj; // 确保返回的是对象&#125;function animal(name, fit) &#123; this.name = name; this.fit = fit;&#125;animal.prototype.sayName = function() &#123; console.log(this.name);&#125;;const pig = create(animal, “Ken”, 12);pig.sayName(); // Ken 2.4 apply、call、bind2.4.1 apply、callcall： 使用一个指定的this和若干指定参数的前提下，调用某个函数或方法。apply： 与call类似，只是提供参数的方式不一样，apply的参数是数组。 12345678910function sum(c, d) &#123; return this.a + this.b + c + d;&#125;const obj = &#123; a: 1, b: 2&#125;;console.log(sum.call(obj, 1, 2)); // 6console.log(sum.apply(obj, [3, 4])); // 10 2.4.2 bind bind： 方法创建一个新的函数，在bind()被调用时，这个新函数的this被bind的第一个参数指定，其余的参数将作为新函数的参数供调用时使用。 MDN: https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind 与apply,call 不同的是，bind 返回一个原函数的拷贝。 123456789101112var a = 10;const module = &#123; a:1, getA:function() &#123; return this.a; &#125;&#125;module.getA(); // 1; 对象方法调用，`this`指向moduleconst getValueA = module.getA;getValueA(); // 10 全局作用域中调用getA()，所以这里输出10.const fn = getValueA.bind(module); //把 'this' 绑定到 module 对象fn(); // 1 如果将null/undefined作为this传入，在被调用的时候会被忽略，使用默认绑定（window）。可以传{}让this为空。 无论bind()多少次，this的指向永远由第一决定。 2.5 箭头函数 箭头函数的this继承于包裹它的第一个普通函数的this，如果没有普通函数，则为全局对象。 箭头函数的this在第一次绑定后就不会再改变。 不能使用new来调用 1234567891011121314151617181920212223242526function fn() &#123; return () =&gt; &#123; return () =&gt; &#123; console.log(this) &#125; &#125;&#125;console.log(fn()()()) // Windowvar name = \"Ken\"const module = &#123; name: \"module\", getName: function() &#123; const fn = ()=&gt; &#123; console.log(this.name) &#125; fn(); &#125;, // 外层没有普通函数包裹，因此`this`指向全局作用域 arrowFn: ()=&gt; &#123; console.log(this.name) &#125;&#125;module.getName(); // modulemodule.arrowFn(); // ken 总结this的绑定规则可以分为 new绑定 显示绑定：call、apply、bind 隐式绑定：作为对象方法调用 默认绑定：函数调用 优先级：new &gt; call、apply、bind &gt; obj.fn() &gt; fn()","link":"/2019/03/22/拾遗JavaScript——this/"},{"title":"拾遗JavaScript——深、浅拷贝","text":"数据类型JavaScript 中变量的数据类型分两种： 基本类型 （存储与栈内存中，值存储） 引用类型 （存储堆内存中，通过指针去寻找所指向的内存空间） 对于值类型的复制操作是直接堆变量的值进行拷贝；对于引用类型的复制操作是对存储变量的指针进行拷贝，指向同一内存空间，修改其中一个会影响另一方。 深浅拷贝只针对于 Array、Object 这样复杂的对象 浅拷贝只拷贝基本类型的数据，对于引用的类型数据，复制后也是会发生引用，这种拷贝就叫做浅拷贝 🌰： 对于对象来说，可以通过Object.assign()、...来实现浅拷贝1、Object.assign()1234567let obj = &#123; name: \"ken\"&#125;;let newObj = Object.assign(&#123;&#125;, obj);obj.name = \"obi\";console.log(obj.name); // name:obiconsole.log(newObj.name); // name: ken 2、...展开运算符123456789let obj = &#123; name: \"ken\"&#125;;let newObj = &#123; ...obj&#125;;obj.name = \"obi\";console.log(obj.name); // name:obiconsole.log(newObj.name); // name: ken 🌰：对于数组，可以通过concat()、slice() 来实现浅拷贝1、concat()concat() 方法用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。concat 方法不会改变 this 或任何作为参数提供的数组，而是返回一个浅拷贝，它包含与原始数组相结合的相同元素的副本。 原始数组的元素将复制到新数组中。 https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/concat 12345let arr = [1, 2, 3];let newArr = arr.concat();arr.push(4);console.log(arr); //[1,2,3,4]console.log(newArr); //[1,2,3] 2、slice()slice() 方法返回一个新的数组对象，这一对象是一个由 begin 和 end（不包括 end）决定的原数组的浅拷贝。原始数组不会被改变。 https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/slice 12345let arr = [1, 2, 3];let newArr = arr.slice();arr.push(4);console.log(arr); //[1,2,3,4]console.log(newArr); //[1,2,3] 当面对复杂一点的对象或者数组，使用 Object.assign(),Array.slice() 会怎么样？例如:1234567891011121314let obj = &#123; a: 1, b: 2, c: &#123; d: 1, e: 2 &#125;&#125;;let newObj = Object.assign(&#123;&#125;, obj);obj.a = 2;newObj.c.d = 2;console.log(obj); // &#123;a:2,b:2,c:&#123;d:2,e:2&#125;&#125;console.log(newObj); // &#123;a:1,b:2,c:&#123;d:2,e:2&#125;&#125; 12345678let arr = [1, 2, [1, 2], 3];let newArr = arr.concat();arr.push(4);arr[2].push(3);console.log(arr); //[1,2,[1,2,3],3,4]console.log(newArr); //[1,2,[1,2,3],3] 代码里修改了obj.a的值，并没对newObj造成影响，而修改了newObj.c.d的值，obj.c.d的值也随着改变。这是因为Object.assign()是浅拷贝，只拷贝了一层，对于obj.c是一个对象，所以newObj.c存储的是指向obj.c所指向的指针地址。同理...展开运算符、Array.concat()/Array.slice() 深拷贝解决上述问题最常见的实现方式就是：JSON.parse(JSON.stringify(object)) 123456789101112131415let obj = &#123; a: 1, b: 2, c: &#123; d: 1, e: 2 &#125;&#125;;let newObj = JSON.parse(JSON.stringify(obj));obj.a = 2;newObj.c.d = 2;console.log(obj); //&#123;a:2,b:2,c:&#123;d:1,e:2&#125;&#125;console.log(newObj); //&#123;a:1,b:2,c:&#123;d:2,e:2&#125;&#125; 当然，对象的序列化反序列化JSON.parse(JSON.stringify())并不是万能的。 忽略 undefined 忽略 symbol 不能序列化函数 不能解决循环引用的对象 https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify 12345678910111213141516171819202122232425let obj = &#123; a: () =&gt; &#123; console.log(\"copy\"); &#125;, b: undefined, c: Symbol, d: \"obi\"&#125;;let newObj = JSON.parse(JSON.stringify(obj));console.log(newObj); // &#123;d:obi&#125; 忽略undefined、symbol、不能序列化化函数let obj = &#123; a: 1, b: &#123; c: 2 &#125;&#125;;obj.c = obj.b; // `obj.c` 引用 `obj.b`obj.b.c = obj.c; // `obj.b.c` 又引用 `obj.c`let newObj = JSON.parse(JSON.stringify(obj));console.log(newObj); // 直接报错 实现简易的浅拷贝、深拷贝浅拷贝1234567891011121314151617181920const fn = (data, target = &#123;&#125;) =&gt; &#123; for (let item in data) &#123; if (data.hasOwnProperty(item)) &#123; target[item] = data[item]; &#125; &#125; return target;&#125;;let obj = &#123; a: 1, b: 2&#125;;let newObj = fn(obj);obj.a = 2;console.log(obj); //&#123;a:2,b:2&#125;console.log(newObj); //&#123;a:1,b:2&#125; 浅拷贝就是一个for..in循环,Object.prototype.hasOwnProperty的作用是检测目标是否属于自有属性,是则复制 深拷贝123456789101112131415161718192021222324252627282930const isObj = o =&gt; &#123; return typeof o === \"object\" || (typeof o === \"function\" &amp;&amp; o !== null);&#125;;const deepClone = obj =&gt; &#123; if (!isObj(obj)) &#123; throw new Error(\"not a Object！\"); &#125; let newObj = Array.isArray(obj) ? [] : &#123;&#125;; // 判断是否是数组或者是对象,设置初始值为空值 Object.keys(obj).forEach(key =&gt; &#123; newObj[key] = isObj(obj[key]) ? deepClone(obj[key]) : obj[key]; &#125;); return newObj;&#125;;let obj = &#123; a: [1, 2, 3], b: &#123; c: 2, d: 3 &#125;&#125;;let newObj = deepClone(obj);newObj.b.c = 1;console.log(obj.b.c); // 2console.log(newObj.b.c); // 1 这只是简单的深拷贝，未考虑其他情况，其余另做探究。 参考来自 Google、MDN","link":"/2019/03/05/拾遗JavaScript——深、浅拷贝/"},{"title":"Javascript——防抖与节流","text":"防抖防止函数多次调用，例如一个用户一直触发这个函数，且每次触发函数的间隔小于 wait，防抖的情况下只会调用一次。 Code1234567891011121314151617181920212223242526/\\*\\*- 防抖函数- @param &#123;function&#125; fn 需要执行的函数，（例如网络请求）- @param &#123;number&#125; wait 等待时间，预设 50ms- @returns &#123;function&#125; 需要进行防抖处理的函数 \\*/ const debounce = (fn, wait = 50) =&gt; &#123; let timer = 0; //初始化一个定时器 // 返回进行防抖处理的函数 return function(...arguments) &#123; // 如果定时器存在则清空上一次的定时器 if (timer) &#123; clearTimeout(timer); &#125; // 重新计时，延迟执行传入的函数 timer = setTimeout(() =&gt; &#123; fn.apply(this, arguments); &#125;, wait); &#125;; &#125;; // Button 按钮 document.getElementById('btn').addEventListener('click',debounce(function(e) &#123; console.log(\"change\", e.target.value, new Date() - 0); &#125;, 350)) 一般防抖都会有一个选项：是否立即调用。在不同使用场景进行区分使用。例如： 在搜索引擎搜索问题的时候，我们当然是希望用户输入完最后一个字才调用查询接口，这个时候适用延迟执行的防抖函数，它总是在一连串（间隔小于 wait 的）函数触发之后调用。 文本输入的验证（连续输入文字后发送请求进行验证，验证一次就好)。 比如一个 start 按钮，当点击按钮的时候立刻改变按钮形状，这时候用户可以知道交互操作正在进行，那么需要立即执行函数。 改造：加入立即执行选项123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 获取当时间const getNowDate = () =&gt; &#123;&#125;;/\\*\\*- 防抖- @param &#123;function&#125; fn 需要执行的函数，（例如网络请求）- @param &#123;Boolean&#125; immediate 是否立即执行，默认 true- @param &#123;Number&#125; wait 等待时间，预设 50ms- @returns &#123;function&#125; 需要进行防抖处理的函数 \\*/ const debounce = (fn, immediate = true, wait = 50) =&gt; &#123; let timer = 0; //初始化一个定时器 let context, args; //执行上下文、参数 // 延迟执行函数 const later = () =&gt; setTimeout(() =&gt; &#123; // 延迟函数执行完毕，清空缓存的定时器 timer = null; if (!immediate) &#123; // 执行函数 fn.apply(context, args); // 重置执行上下文和参数 context = args = null; &#125; &#125;, wait);// 返回进行防抖处理的函数return function(...arguments) &#123;// 如果定时器不存在则创建延迟定时器。if (!timer) &#123;timer = later();// 如果是立即执行，则执行函数if (immediate) &#123;fn.apply(this, arguments);&#125; else &#123;//缓存执行上下文和参数context = this;args = arguments;&#125;&#125; else &#123;// 如果已有延迟执行函数（later），调用的时候清除原来的并重新设定一个.// 这样做延迟函数会重新计时clearTimeout(timer);timer = later();&#125;&#125;;&#125;; 对于按钮的点击来说，假设你连续点击了 10 次，如果网络请求防抖是立即执行的，在这 10 次过程中，函数只在点击的第一次立即执行。其余的 9 次都在重置定时器，等到最后一次设定的计时器计时时间到，再次点击才重新执行。 节流简单可以理解为：将多次执行的函数固定成每隔一段时间执行。 一般情况下有 2 中不同的限制方式适用不同需求 首次是否执行 结束后是否执行 Code使用时间戳实现思路 变量previous记录调用方法的时间戳. 对比之前的时间错，如果大于设置的时间错，则执行函数。执行后更新时间戳为当前时间。 123456789101112const throttle = (func, delay) =&gt; &#123;let previous = 0;return function(...args) &#123;let now = +new Date();// 将当前时间和上一次执行函数时间对比// 如果差值大于设置的等待时间就执行函数if (now - previous &gt; delay) &#123;previous = now;func.apply(this, args);&#125;&#125;;&#125;; 代码分析 1.第一次执行时，if (now - previous &gt; delay)，previous=0，所以方法立即执行，随后记录previous=now()，每隔 1s 执行一次方法。 2.但不会触发最后一次执行。 使用setTimeout实现思路 当执行 throttle 函数时，判断是否存在定时器，如果不存在，则开启一个定时器， 123456789101112const throttle = (func, delay) =&gt; &#123;let timer;return function(...args) &#123;// 如果定时器不存在，则开启一个定时器。if (!timer) &#123;timer = setTimeout(() =&gt; &#123;func.apply(this, args);timer = null;&#125;, delay);&#125;&#125;;&#125;; 代码分析 当连续调用 throttle 函数时，方法func不会立即执行，之后根据设定的 delay 时间间隔执行。 结束调用后还会执行一次。 两者之间的区别在与是否首次执行和是否结束后执行。 完善思路 增加options选项，可选 leading:false 表示禁用第一次执行、trailing:false 表示禁用停止触发的回调 1234567891011121314151617181920212223242526272829const throttle = (func, delay, option) =&gt; &#123; let timer, previous = null; // const later = function() &#123; previous = option.leading === false ? 0 : +new Date(); func.apply(this, arguments); timer = null; &#125;; return function(...args) &#123; // 如果定时器不存在，则开启一个定时器。 let now = +new Date(); // 如果leading===false表示第一次调用不执行； if (option.leading === false &amp;&amp; !previous) &#123; previous = now; &#125; // 根据时间戳对比是否在限制时间内 if (now - previous &gt; delay) &#123; if (timer) &#123; clearTimeout(timer); timer = null; &#125; func.apply(this, args); previous = now; &#125; else if (!timer &amp;&amp; option.trailing !== false) &#123; timer = setTimeout(later, delay); &#125; &#125;; &#125;;","link":"/2019/08/09/防抖与节流/"},{"title":"Hola","text":"心情不好～写点什么…","link":"/2019/03/01/Hola/"},{"title":"拾遗webpack4（一）——入门","text":"webpack4 初体验webpack 是一个现代 JavaScript 应用程序的静态模块打包工具。当 webpack 处理应用程序时，它会在内部构建一个 依赖图(dependency graph)，此依赖图会映射项目所需的每个模块，并生成一个或多个 bundle。 从 4.0 版本开始，webpack 抛弃以前版本的那种繁琐、晦涩令初学者怯步的配置文件，开始零配置靠拢； 这无疑对于初学者来说，亲和力上了一层楼。 但它仍然具有可配置性满足多种需求。 在开始之前先了解核心概念 入口（entry） 输出（output） loader 插件（plugin） 模式（mode） 浏览器兼容性（bowser compatibility） 项目搭建创建空文件夹 webpack_demo，运行以下命令生成 package.json 1npm init 或者 npm init -y Tip-y 参数表示所有 package.json 参为默认 引入 webpack 1npm install webpack --save-dev 这里还需要使用 webpack-cli 脚手架 1npm install webpack-cli --save-dev 查看 package.json 文件可以看到目前使用的版本 12345\"devDependencies\": &#123; \"webpack\": \"^4.30.0\", \"webpack-cli\": \"^3.3.0\" &#125; 接下来在 packege.json 中增加 npm scripts 12345\"scripts\": &#123; \"build\": \"webpack\", \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" &#125; 到这里基本的项目搭建完毕，运行 npm run build 命令看看效果。 从图片里的报错信息可以得知：“未能找到入口文件” 回到文章开始讲的：webpack 中的核心概念：入口(entry) 入口(entry)入口起点(entry point)指示 webpack 应该使用哪个模块，来作为构建其内部 依赖图(dependency graph) 的开始。进入入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的。 https://webpack.docschina.org/concepts/#%E5%85%A5%E5%8F%A3-entry- webpack 的入口默认是 .src/index.js ,但我们可以通过 webpack.config.js 中去配置指定具体的入口起点。 webpack.config.js 12345module.exports = &#123; entry: &#123; app: \"./app.js\" &#125;&#125;; 现在新建一个src目录并添加入口文件 index.js 运行npm run build,可以看到控制台输出打包成功 并在目录下创建了dist文件夹和里面已经打包压缩好的文件main.js 这里讲一个 webpack 的一个核心概念：输出（output） 输出(output)output 属性告诉 webpack 在哪里输出它所创建的 bundle，以及如何命名这些文件。主要输出文件的默认值是 ./dist/main.js，其他生成文件默认放置在 ./dist 文件夹中。 https://webpack.docschina.org/concepts/#%E5%85%A5%E5%8F%A3-entry- 同样我们也可以在webpack.config.js 中去自定义输出点(output) webpack.config.js 1234567module.exports = &#123; output: &#123; publicPath: __dirname + \"/dist/\", // js 引用的路径或者CDN地址 path: path.resolve(__dirname, \"dist\"), // 打包文件的输出目录 filename: \"bundle.js\" // 打包后生产的js文件 &#125;&#125;; 模式(mode)前面运行npm run build 的过程中，虽然打包成功，但是控制台还输出几行警告信息: “没有设置 mode option” 这里就要讲到 webpack 中的一个核心点：mode， production development 我们可以在npm scripts 中告诉webpack-cli 以什么样的 mode 去构建例如: 1234567&#123; \"scripts\": &#123; \"dev\": \"webpack --mode development\", \"build\": \"webpack --mode production\", \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" &#125;&#125; 或者在webpack.config.js中设置 123module.exports = &#123; mode: \"production\"&#125;; 如果不设置的话，默认mode为production 现在我们来看看两中模式下的简单区别 执行 npm run dev 执行 npm run build 通过对比，在 dev 模式下，js 文件没有被压缩 一个完整的 Web 项目除了 js 脚本文件，应该还包含有 CSS、HTML 以及其他资源，如图片、字体等;那么在 webpack 中如何去处理这些资源呢？首先从处理 CSS 开始 loaderwebpack 只能理解 JavaScript 和 JSON 文件。loader 让 webpack 能够去处理其他类型的文件，并将它们转换为有效 模块，以供应用程序使用，以及被添加到依赖图中。 https://webpack.docschina.org/concepts/#loader 1、添加style.css2、处理 css 需要安装以下 loader 配合使用，执行npm i --save-dev style-loader css-loader css-loader：解析 CSS 代码，处理 CSS 中的依赖（@import、url()等） style-loader：将css-loader解析结果转变为 js 并动态插入 style 标签 123456\"devDependencies\": &#123; \"css-loader\": \"^2.1.1\", \"style-loader\": \"^0.23.1\", \"webpack\": \"^4.30.0\", \"webpack-cli\": \"^3.3.0\" &#125; 3、配置webpack.config.js 12345678910module.exports = &#123; module: &#123; rules: [ &#123; test: /\\.css$/, use: [\"style-loader\", \"css-loader\"] &#125; ] &#125;&#125;; 4、style.css 123.hola &#123; color: blue;&#125; 5、在index.js中 引入style.css 1import \"./style.css\"; 6、执行npm run build 7、在index.html中引入打包好的文件bundle.js 8、在浏览器中打开 index.html,在控制台可以看到 css 样式已经通过&lt;style&gt; 标签注入 处理sass、less，可以使用less-loader\\sass-loader 插件（plugin）在 html 文件中引入打包好后的 js 文件，如果更改了打包后的文件名称或者代码分割成多个文件，又要去一个个引入，甚是麻烦，这个时候就要使用html-webpack-plugin，打包完之后自动生成 HTML 文件，并自动引入打包后的 js 文件。 1、执行npm i html-webpack-plugin html-loader --save-dev2、配置webpack.config.js3、执行npm run build4、在dist文件夹下打开index.html 要部署到服务器前，这里要把webpack的output改为相对路径publicPath:&#39;./&#39;","link":"/2019/03/02/拾遗webpack4（一）——入门/"},{"title":"拾遗webpack4（三）——处理图片","text":"","link":"/2019/03/05/拾遗webpack4（三）——处理图片/"},{"title":"拾遗webpack4（二）——Babel","text":"BabelBabel 是什么？主要用于将 ECMAScript 2015+ 版本的代码转换为向后兼容的 JavaScript 语法，以便能够运行在当前和旧版本的浏览器或其他环境中。 1、执行以下命令安装所需要的 package 12npm install --save-dev babel-loader @babel/core @babel/preset-envnpm install --save @babel/polyfill babel-loader : 这是 Webpack 的 Babel 插件，它将被添加到 Webpack 配置中，以指示它在捆绑过程中通过 Babel 运行目标文件； @babel/core @babel/preset-env：通过根据目标浏览器或运行时环境自动确定所需的 Babel 插件和 polyfill，将代码编译为 ES5 @babel/polyfill：垫片，转化 ES6 内置语法（Array.from,Object.assign 等） 1234567891011\"devDependencies\": &#123; \"@babel/core\": \"^7.4.3\", \"@babel/preset-env\": \"^7.4.3\", \"babel-loader\": \"^8.0.5\", \"clean-webpack-plugin\": \"^2.0.1\", \"webpack\": \"^4.30.0\", \"webpack-cli\": \"^3.3.0\" &#125;, \"dependencies\": &#123; \"@babel/polyfill\": \"^7.4.3\" &#125; 2、新建 babel 配置文件.babelrc 来配置 babel 123&#123; \"presets\": [\"@babel/preset-env\"]&#125; 3、在webpack.config.js中配置 babel-loader 123456789module: &#123; rules: [ &#123; test: /\\.js$/, //匹配js文件 exclude: /node_modules/, //忽略目标文件夹 loader: \"babel-loader\" // 使用babel-loader &#125; ];&#125; 4、验证 在 index.js 中使用 ES6 语法 12345// import '@babel/polyfill'const arr = [\"1\", \"2\", \"3\"];const fn = () =&gt; console.log(...arr);fn(); 这里还需要import &#39;@babel/polyfill&#39;全局引入打包后体积大、根据需要转译的文件按需引用又很麻烦，这里只需要配置一下babelrc，babel 自动转译 .babelrc1234567891011&#123; \"presets\": [ [ \"@babel/preset-env\", &#123; \"useBuiltIns\": \"usage\", \"corejs\": \"3\" //使用core-js@3版本 &#125; ] ]&#125; 这里遇到一个小坑，配置完.babelrc后执行npm run build，控制台首先会提示一段警告: 大概意思就是指定用什么版本的core-js,默认使用core-js@2版本 然后报错 这里配置一下core-js的版本 执行npm run build 浏览器中打开dist文件夹下的index.html，查看控制台输出。 Chrome 最新版是支持 ES6 语法的，最好的还是在 IE 下测试。","link":"/2019/03/04/拾遗webpack4（二）——Babel/"},{"title":"The Boring Project——驾校管理系统","text":"～ 1","link":"/2019/08/11/The-Boring-Project——驾校管理系统/"},{"title":"拾遗JavaScript——原型与原型链","text":"一、原型prototype基本上每个函数都有 一个特殊的属性——原型（prototype），它是一个显式属性。 当我们创建一个函数时，这个属性就自动被创建。 1function fn()&#123;&#125; 函数的prototype是什么？ prototype 属性：继承成员定义的地方。 通俗的理解为：当我们实例化一个对象时，该对象会从原型中“继承”属性和方法。 12345678910111213141516function animal()&#123;&#125;;animal.prototype.class = \"animal\";animal.prototype.eat = function() &#123; console.log(\"eat something\");&#125;var cat = new animal();cat.eat(); // eat somethingconsole.log(cat.class); // \"animal\" 😪 抽象能力差怎么办？————画图 当我们打印cat这个实例时…….. What？？？ OOP思想中的继承（java，C++等）是一种对属性方法的复制操作，但对象实例cat中并没有复制过来的属性和方法，但在调用class属性和eat()方法时都可以正常调用。这？？？在JavaScript 的继承操作其实是一种“链接”操作，是一种委托，通过__proto__ 链接到构造函数的prototype。 __proto____proto__ 是每一个对象（除了null）都有的隐式属性，它指向创建该对象的构造函数的[[prototype]]，因此我们可以访问到定义在构造函数的prototype上的属性和方法。 1console.log(cat.__proto__ == animal.prototype); // true 当使用cat.__proto__ 时，实际上是返回Object.getPrototypeOf(cat)。可以理解为一种getter/setter操作。 😪 抽象能力差怎么办？——画图 constructor 在animal.prototype中还有一个属性constructor,它是干什么用的？ constructor:每一个实例对象都从原型中继承一个 constructor 属性，它指向构造此实例对象的构造函数； 因此实例cat的构造函数是function animal() 12console.log(animal.prototype.constructor === animal); // trueconsole.log(cat.constructor === animal); // true 我们还可以这样去创建animal的实例，但一般来说知道原始构造器function animal()的情况下不会用这样的方式。 1234const dog = new cat.constructor();dog.class // animaldog.eat() // eat somethingconsole.log(dog.constructor === animal); // true 画图捋一捋～ 原型的原型 ？捋清了实例与原型的关系,那原型的原型是什么？ animal.prototype 中也有一个属性__proto__ , 这个__proto__属性指向哪？ 在JavaScript中，函数其实也是Object，animal.prototype.__proto__ 指向的是Object.prototype 而Object.prototype.__proto__ === null 原型链1234567891011121314function animal()&#123;&#125;;animal.prototype.class = \"animal\";var cat = new animal();cat.class = \"cat\";console.log(cat.class); // catdelete cat.class; // 删除 cat 的 class 属性console.log(cat.class); // animalcat.isPrototypeOf();cat.valueOf() 由以上代码可以看出:1、cat.class 首先在实例cat上寻找属性class，输出“cat”2、删除实例cat上的属性class，仍能调用，但输出的是&quot;animal&quot;这是因为当在实例上寻找不到属性class时，会通过__proto__找到aminal.prototype，在上面寻找到class，并输出&quot;animal&quot;3、并没有在实例cat或者animal.prototype上定义isPrototypeOf()/valueOf()，为什么还能调用？这是因为当在实例、实例原型animal.prototype上找不时，解析器会继续往上，即animal.prototype.__proto__，直到__proto__指向null则停止寻找。此时animal.prototype.__proto__指向的是Object.prototype，所以调用上面定义的方法isPrototypeOf()/valueOf() 实例cat、构造函数animal的原型prototype、Object.prototype 以__proto__链接起来的关系就形成了原型链。 图腾","link":"/2019/04/10/拾遗JavaScript——原型与原型链/"},{"title":"拾遗JavaScript——Promise","text":"基本使用没啥好记录～ 具体参考 MDN Promise https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise Promise 具体用法 https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Using_promises Promise.all()Promise.all() 参数一个可迭代对象，如 Array 或 String。 返回值 如果传入的参数是一个空的对象，则返回一个已完成（already resolved）状态的 Promise。 如果传入的参数不包含任何 promise，则返回一个异步完成（asynchronously resolved） Promise。 1、Promise.all 返回的 promise 的完成状态的结果都是一个数组。2、如果所有传入的 promise 都变为完成状态，或者传入的可迭代对象内没有 promise，Promise.all 返回的 promise 异步地变为完成3、如果传入的 promise 中有一个失败（rejected），Promise.all 异步地将失败的那个结果给失败状态的回调函数，而不管其它 promise 是否完成，从而丢弃其他Promise的完成结果。 🌰当我们在同时发起多个网络请求时，可以用Promise.all()来处理。 promise.js12345678910111213141516function fetchData(url) &#123;return new Promise((resolve, reject) =&gt; &#123;const requet = new XMLHttpRequest();requet.open(\"GET\", url);requet.onload = () =&gt; resolve(requet.responseText);requet.onerror = () =&gt; reject(requet.statusText);requet.send();&#125;);&#125;const fetch_1 = fetchData(topNewsUrl)const fetch_2 = fetchData(topNewsUrl)const fetch_3 = fetchData(topNewsUrl)Promise.all([fetch_1,fetch_2,fetch_3]).then(res=&gt;&#123;console.log(res);&#125;) 但是当Promise.all()中有一个promise的状态为rejected，则会抛弃其他已完成的结果。 promise.js1234567891011const fetch_1 = fetchData(topNewsUrl);const fetch_2 = fetchData(topNewsUrl);const fetch_3 = Promise.reject(\"err\");Promise.all([fetch_1, fetch_2, fetch_3]).then(res =&gt; &#123;console.log(res);&#125;).catch(err =&gt; &#123;console.log(err);&#125;); 但是有时候我们想要同时得到正确处理的结果和失败结果，可以这样处理promise.js1234567891011121314151617const fetch_1 = fetchData(topNewsUrl);const fetch_2 = fetchData(topNewsUrl);// 用 catch()捕获当前 promise reject(\"err\")，并返回。// catch() 返回值是一个 promise，如果不被 rejected，则它显示为成功(resolved)const fetch_3 = Promise.reject(\"err\").catch(err =&gt;&#123;return err;&#125;);const fetchs = [fetch_1, fetch_2, fetch_3];Promise.all(fetchs).then(res =&gt; &#123;console.log(res);&#125;).catch(err =&gt; &#123;console.log(err);&#125;); 同时也可以使用Promise.allSettled() Promise.allSettled()Promise.allSettled()： 无论是成功或拒绝。返回数组包含原始promises集中每个promise的结果。 1234567const fetch_1 = Promise.resolve(1);const fetch_2 = Promise.reject(2);const fetch_3 = Promise.resolve(3);const fetchs = [fetch_1, fetch_2, fetch_3];console.log(Promise.allSettled(fetchs)); Promise.finally()finally() 方法返回一个Promise。在promise结束时，无论结果是fulfilled或者是rejected，都会执行指定的回调函数。这为在Promise是否成功完成后都需要执行的代码提供了一种方式 12345678Promise.resolve(1) .then(res =&gt; console.log(res)) // 1 .catch(err =&gt; console.log(err)) .finally(() =&gt; console.log(\"finally\")); // finallyPromise.reject(2) .then(res =&gt; console.log(res)) .catch(err =&gt; console.log(err)) // 2 .finally(() =&gt; console.log(\"finally\")); //finally Promise ? async/await当一个网络请求需要依赖上一个请求的结果时： Promise Promise.js12345678910fetchData(topNewsUrl) .then(res =&gt; &#123; return res.data[0].id; &#125;) .then(itemID =&gt; &#123; return fetchData(newsDetailUtl + itemID); &#125;) .then(res =&gt; &#123; console.log(res); &#125;); async/await async/await.js12345async function asyncFetch() &#123; const news = await fetchData(topNewsUrl) const res = await fetchData(newsDetailUtl + news.data[0].id); console.log(res);&#125; 对比两者显然async/await 代码更简洁容易理解。 实现一个 Promise基础简易版myPromise.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869// Promise三种状态;const PENDING = \"pendding\"; //等待const FULFILLED = \"fulfilled\"; // 完成const REJECTED = \"rejected\"; //拒绝class myPromise &#123; constructor(executor) &#123; this.state = PENDING; //初始状态 this.value = null; // 完成结果 this.reason = null; // 拒绝原因 const resolve = value =&gt; &#123; if (this.state === PENDING) &#123; this.value = value; // 保存完成结果 this.state = FULFILLED; // 保存状态为完成 &#125; &#125;; const reject = value =&gt; &#123; if (this.state == PENDING) &#123; this.reason = value; // 保留拒绝原因 this.state = REJECTED; // 保存状态为拒绝 &#125; &#125;; /** * executor: Promise中首先传了一个executor，它是一个函数 * executor函数中又传了两个函数，分别是resolve和reject * @param resolve:成功回调 * @param reject:拒绝回调 */ executor(resolve, reject); &#125; /** * 根据成功或失败的状态去执行相关成功onFilfulled()或者失败onRejected()的回调方法 * @param &#123;*&#125; onFulfilled ：成功 * @param &#123;*&#125; onRejected ：拒绝 */ then(onFulfilled, onRejected) &#123; switch (this.state) &#123; case FULFILLED: //执行成功的回调函数onFilfulled，传入成功结果 this.value onFulfilled(this.value); break; case REJECTED: //执行成功的回调函数onRejected，传入拒绝结果 this.reason onRejected(this.reason); break; default: break; &#125; &#125; /** * * @param &#123;*&#125; onRejected ：拒绝 */ catch(onRejected) &#123; return this.then(null, onRejected); &#125;&#125;const p = new myPromise((resolve, reject) =&gt; &#123; resolve(1);&#125;);p.then(res =&gt; &#123; console.log(res); // 1&#125;); 很显然，测试结果反应代码没有问题，但是如果加个异步函数呢？ 异步处理myPromise.js12345678const p = new myPromise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(1); &#125;, 1000);&#125;);p.then(res =&gt; &#123; console.log(res); &#125;); 很显然，控制台不会输出什么，因为setTimeout是异步任务，会被加入到Task Queue 当调用then()时，myPromise.state 还是 PENDING，此时then()函数并不知道到底是执行onFulfilled()，还是onRejected()。 改造….myPromise.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697// Promise三种状态;const PENDING = \"pendding\"; //等待const FULFILLED = \"fulfilled\"; // 完成const REJECTED = \"rejected\"; //拒绝class myPromise &#123; constructor(executor) &#123; this.state = PENDING; //初始状态 this.value = null; // 完成结果 this.reason = null; // 拒绝原因 this.onFulfilledCallbacks = []; // 保存完成回调 this.onRejectedCallbacks = []; // 保存拒绝回调 const resolve = value =&gt; &#123; if (this.state === PENDING) &#123; this.value = value; // 保存完成结果 this.state = FULFILLED; // 保存状态为完成 // 状态变更后 立即执行之前存放在相应数组中所有完成的回调函数. this.onFulfilledCallbacks.map(cb =&gt; &#123; cb(); &#125;); &#125; &#125;; const reject = value =&gt; &#123; if (this.state == PENDING) &#123; this.reason = value; // 保留拒绝原因 this.state = REJECTED; // 保存状态为拒绝 // 状态变更后 立即执行之前存放在相应数组中所有拒绝的回调函数 this.onRejectedCallbacks.map(cb =&gt; &#123; cb(); &#125;); &#125; &#125;; try &#123; /** * executor: Promise中首先传了一个executor，它是一个函数 * executor函数中又传了两个函数，分别是resolve和reject * @param resolve:成功回调 * @param reject:拒绝回调 */ executor(resolve, reject); &#125; catch (err) &#123; // 如果出错，直接进入reject() reject(err); &#125; &#125; /** * 根据成功或失败的状态去执行相关成功onFilfulled()或者失败onRejected()的回调方法 * @param &#123;*&#125; onFulfilled ：成功 * @param &#123;*&#125; onRejected ：拒绝 */ then(onFulfilled, onRejected) &#123; switch (this.state) &#123; // 针对可能存在的异步调用，在PENDING状态时将完成、失败的回调函数push到对应的数组中，待状态改变时执行。 // 这种方式可以称为订阅 case PENDING: this.onFulfilledCallbacks.push(() =&gt; &#123; onFulfilled(this.value); &#125;); this.onRejectedCallbacks.push(() =&gt; &#123; onRejected(this.reason); &#125;); break; case FULFILLED: //执行成功的回调函数onFilfulled，传入成功结果 this.value onFulfilled(this.value); break; case REJECTED: //执行成功的回调函数onRejected，传入拒绝结果 this.reason onRejected(this.reason); break; default: break; &#125; &#125; /** * 捕获reject * @param &#123;*&#125; onRejected ：拒绝 */ catch(onRejected) &#123; return this.then(null, onRejected); &#125;&#125;const p = new myPromise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(1); &#125;, 1000);&#125;);p.then(res =&gt; &#123; console.log(res); // 1&#125;); then()链式调用 如果一个then方法返回一个普通值的话，这个值会传递给下一个then中作为resolve成功的结果如果一个then方法返回一个promise的话，会根据返回的promise是成功还是失败，决定下一个then是成功还是失败 myPromise.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118// Promise三种状态;const PENDING = \"pendding\"; //等待const FULFILLED = \"fulfilled\"; // 完成const REJECTED = \"rejected\"; //拒绝class myPromise &#123; constructor(executor) &#123; this.state = PENDING; //初始状态 this.value = null; // 完成结果 this.reason = null; // 拒绝原因 this.onFulfilledCallbacks = []; // 保存完成回调 this.onRejectedCallbacks = []; // 保存拒绝回调 const resolve = value =&gt; &#123; // 为了保证函数执行顺序，需要将两个函数体代码使用 setTimeout 包裹起来 setTimeout(() =&gt; &#123; if (this.state === PENDING) &#123; this.value = value; // 保存完成结果 this.state = FULFILLED; // 保存状态为完成 // 状态变更后 立即执行之前存放在相应数组中所有完成的回调函数. this.onFulfilledCallbacks.forEach(cb =&gt; &#123; cb(); &#125;); &#125; &#125;, 0); &#125;; const reject = value =&gt; &#123; //为了保证函数执行顺序，需要将两个函数体代码使用 setTimeout 包裹起来 setTimeout(() =&gt; &#123; if (this.state == PENDING) &#123; this.reason = value; // 保留拒绝原因 this.state = REJECTED; // 保存状态为拒绝 // 状态变更后 立即执行之前存放在相应数组中所有拒绝的回调函数 this.onRejectedCallbacks.forEach(cb =&gt; &#123; cb(); &#125;); &#125; &#125;, 0); &#125;; try &#123; /** * executor: Promise中首先传了一个executor，它是一个函数 * executor函数中又传了两个函数，分别是resolve和reject * @param resolve:成功回调 * @param reject:拒绝回调 */ executor(resolve, reject); &#125; catch (err) &#123; // 如果出错，直接进入reject() reject(err); &#125; &#125; /** * 根据成功或失败的状态去执行相关成功onFilfulled()或者失败onRejected()的回调方法 * @param &#123;*&#125; onFulfilled ：成功 * @param &#123;*&#125; onRejected ：拒绝 */ then(onFulfilled, onRejected) &#123; // return 一个 promise return new myPromise((resolve, reject) =&gt; &#123; switch (this.state) &#123; // 针对可能存在的异步调用，在PENDING状态时将完成、失败的回调函数push到对应的数组中，待状态改变时执行。 // 这种方式可以称为订阅 case PENDING: this.onFulfilledCallbacks.push(() =&gt; &#123; try &#123; const x = onFulfilled(this.value); resolve(x); &#125; catch (err) &#123; reject(err); &#125; &#125;); this.onRejectedCallbacks.push(() =&gt; &#123; try &#123; const x = onRejected(this.reason); resolve(x); &#125; catch (err) &#123; reject(err); &#125; &#125;); break; case FULFILLED: //执行成功的回调函数onFilfulled，传入成功结果 this.value try &#123; const x = onFulfilled(this.value); resolve(x); &#125; catch (err) &#123; reject(err); &#125; break; case REJECTED: //执行成功的回调函数onRejected，传入拒绝结果 this.reason try &#123; const x = onRejected(this.reason); resolve(x); &#125; catch (err) &#123; reject(err); &#125; break; default: break; &#125; &#125;); &#125; /** * 捕获reject * @param &#123;*&#125; onRejected ：拒绝 */ catch(onRejected) &#123; return this.then(null, onRejected); &#125;&#125; 测试myPromise.js123456789101112131415161718192021222324const p = new myPromise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(1); &#125;, 1000);&#125;);p.then(res =&gt; &#123; console.log(res); // 1 return \"2\"; &#125;) .then(res =&gt; &#123; console.log(res); // 2 return &#123; a: 3 &#125;; &#125;) .then(res =&gt; &#123; console.log(res); // &#123;a:3&#125; return undefined; &#125;) .then(res =&gt; &#123; console.log(res); // undefined &#125;) .then(res =&gt; &#123; console.log(res); // undefined &#125;); then中函数返回值的处理 非普通值情况。 这里还有类型判断、参数透传等问题处理，后续完成 Promise/A+规范 Promise/A+ 规范","link":"/2019/03/10/拾遗JavaScript——Promise/"},{"title":"拾遗JavaScript——Event Loop","text":"Event Loop 一、基础知识1、进程与线程 进程：应用程序的执行实例，每一个进程都是由私有的虚拟地址空间、代码、数据个其他系统资源组成。 线程：线程是进程内的一个独立执行单元，在不同的线程之间可以进行资源共享。 进程拥有独立的堆栈空间和数据段，每当启动一个新的进程必须分配给它独立的地址空间，建立众多的数据表来维护它的代码段、堆栈段和数据段。 线程拥有独立的堆栈空间，但是共享数据段，它们彼此之间使用相同的地址空间，共享大部分数据，比进程更加节俭，开销比较小，切换速度快，效率高。 一句话总结: 进程：资源分配的最小单位 线程：程序执行的最小单位 Javascript是一门单线程语言Why??众所周知，多线程操作可以实现应用的并行处理，充分利用CPU资源提高性能和吞吐量。现在很多语言都支持多核并行处理技术。 但Javascript….😂 Javascript 是一门脚本语言，最初设计用于运行在浏览器环境，试想一下如果有2个同步线程在跑，一个在执行DOM的插入，另一个删除DOM，浏览器会？？？？ So…这意味着它可以一次处理一个任务或一次处理一段代码。它有一个调用堆栈，它与堆之类的其他部分一起构成了Javascript并发模型（在V8内部实现）。 Call StackCall Stack：它是一个记录函数调用的数据结构，当我们调用函数时，函数会被推入这个堆栈，但函数返回时按先入后出的规则依次推出。 123456789101112function multiply(a, b) &#123; return a * b;&#125;function square(n) &#123; return multiply(n, n);&#125;function printSquare(n) &#123; var squared = square(n); console.log(squared);&#125;printSquare(4); 通过断点调试可以很清楚的看到调用堆栈 当函数执行完返回时，依次从栈顶推出。 Heapheap：变量所有的内存分配都在在堆中进行。 QueueJavascript单线程任务被分为同步任务和异步任务，同步任务会在调用栈中按照顺序等待主线程依次执行，异步任务会在异步任务有了结果后，将注册的回调函数放入任务队列中等待主线程空闲的时候（调用栈被清空），被读取到栈内等待主线程的执行。 1234567891011console.log(\"1\");setTimeout(() =&gt; &#123; console.log(\"2\");&#125;, 3 * 1000);console.log(\"3\");// 1// 3// 2 如图所示：执行栈先处理同步任务console.log(&#39;1&#39;)，执行完后推出栈，控制台输出1,setTimeout()进入执行栈但不会执行，而是由Web API 处理完毕后，加入任务队列等待执行栈的同步任务执行完，同步任务console.log(&#39;3&#39;)进入执行栈，执行完毕后推出栈，当执行栈为null时，任务队列中的任务推入执行栈执行。 整个过程是循环不断的，这样的运行机制称为Event Loop Event Loop 侵删 补充宏任务/微任务宏任务（Task）： 整体代码script setTimeout setInterval setImmediate requestAnimationFrame I/O UI rendering 微任务(Microtask)： Promise（Promise中的then、catch才是宏任务，本身内部代码并不是） process.nextTick（nodejs环境中） MutationObserver： 提供了监视对DOM树所做更改的能力（https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver） 12345678910111213141516setTimeout(() =&gt; console.log('setTimeout1'), 0);setTimeout(() =&gt; &#123; console.log('setTimeout2'); Promise.resolve().then(() =&gt; &#123; console.log('promise2'); Promise.resolve().then(() =&gt; &#123; console.log('promise3'); &#125;) console.log(5) &#125;) setTimeout(() =&gt; console.log('setTimeout4'), 0);&#125;, 0);setTimeout(() =&gt; console.log('setTimeout3'), 0);Promise.resolve().then(() =&gt; &#123; console.log('promise1');&#125;) 逐步分析代码执行过程:1、Run Script2、开始轮询： setTimeout1、setTimeout2、setTimeout3 被推入Task Queue，promise1被推入Microtasks Queue。此时Task Queue中：[setTimeout1,setTimeout2,setTimeout3]，Microtasks Queue中：[promise1]。3、微任务优于宏任务之前执行，所以先执行Microtasks Queue中的队列promise1，控制台输出：promise1。随后依次执行setTimeout1、setTimeout2、setTimeout3，4、执行：setTimeout1： 输出setTimeout1；执行setTimeout2: 输出setTimeout2，发现一个微任务promise2,将它加入到Microtasks Queue，发现一个宏任务setTimeout4，将它加入Task；执行setTimeout3：输出 setTimeout3;5、此时Microtasks Queue中有[promise2]，执行promise2,输出promise2，这里又有个微任务promise3,将promise3加入Microtasks Queue，执行console.log(5),输出5。6、此时Microtasks Queue不为null，还有任务promise3,执行输出promise3。7、Microtasks Queue为null，检查Task Queue，发现还有一个宏任务 setTimeout4，执行并输出setTimeout4。 因此代码执行的结果为： 12345678promise1setTimeout1setTimeout2setTimeout3promise25promise3setTimeout4 微任务比宏任务优先执行，当微任务队列不为null时，继续处理微任务队列，等到全部处理完毕，则检查宏任务队列并处理队列的任务。 async/awaitasync/await 与 promise 一样同属于微任务。（async函数返回的是一个promise） 123456789101112131415161718192021async function async1() &#123; console.log(\"async1 start\"); await async2(); console.log(\"async1 end\");&#125;async function async2() &#123; console.log(\"async2\");&#125;console.log(\"script start\");setTimeout(function() &#123; console.log(\"setTimeout\");&#125;, 0);async1();new Promise(function(resolve) &#123; console.log(\"promise1\"); resolve();&#125;).then(function() &#123; console.log(\"promise2\");&#125;);console.log(\"script end\"); 以上代码执行过程：1、async1()、async2（）函数定义。2、同步任务，控制台输出：script start。3、setTimeout,加入宏任务队列。4、执行函数async1()。 a：同步任务，控制台输出async1 start。 b：await async2() ，此时线程被阻塞，无法执行当前函数下面的代码。 5、async2()：同步任务，控制台输出async2，6、由于async1()中，await阻塞里线程，无法回到async1()，因此继续执行async1()外面的代码。7、Promise，控制台输出promise1，将then()=&gt;{console.log(&quot;promise2&quot;)}回调加入微任务队列。8、同步任务,控制台输出script end，此时代码执行完。9、await阻塞线程结束。 a:回到函数async1()，async2()返回一个promise.resolve(undefined).then(undefined)，将then(undefined)加入微任务队列。 b:处理微任务队列then()=&gt;{console.log(&quot;promise2&quot;)}、then(undefined)，控制台输出promise2。 c:执行console.log(&quot;async1 end&quot;)，控制台输出async1 end。 10、处理宏任务队列，控制台输出setTimeout。 所以控制台输出：12345678script startasync1 startasync2promise1script endpromise2async1 endsetTimeout async/await本质上还是基于Promise的一些封装。执行async函数内遇到await fn()时，会阻塞线程跳出async函数，然后再次回到await fn()处，如果fn()返回的是Promise对象还要再次跳出async1()函数体外继续执行以外的代码。 补充在最新的Chrome（76.0.3809.87）中测试以上代码得到结果为： 12345678script startasync1 startasync2promise1script endasync1 endpromise2setTimeout","link":"/2019/04/09/拾遗JavaScript——Event-Loop/"}],"tags":[],"categories":[{"name":"Web","slug":"Web","link":"/categories/Web/"},{"name":"Javascript","slug":"Web/Javascript","link":"/categories/Web/Javascript/"},{"name":"Webpack","slug":"Web/Webpack","link":"/categories/Web/Webpack/"},{"name":"Project","slug":"Project","link":"/categories/Project/"}]}